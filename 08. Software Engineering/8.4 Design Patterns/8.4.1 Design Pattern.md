# 8.4 설계 패턴 (Design Patterns)

## 설계 패턴이란?

### 정의

설계 패턴은 소프트웨어 개발에서 **자주 발생하는 문제들에 대한 재사용 가능한 해결책**입니다. 객체지향 설계의 경험과 노하우를 체계화한 것으로, "바퀴를 다시 발명하지 않기" 위한 검증된 설계 방법들입니다.

### 패턴의 장점

- **검증된 해결책**: 많은 개발자들이 사용하고 검증한 방법
- **의사소통 도구**: 개발자 간 설계 의도를 쉽게 전달
- **코드 재사용성**: 반복되는 설계 문제를 효율적으로 해결
- **유지보수성**: 일관된 구조로 코드 이해와 수정 용이

### GoF 패턴 분류

- **생성 패턴**: 객체 생성 방식 (싱글톤, 팩토리 등)
- **구조 패턴**: 객체 조합 방식 (어댑터, 데코레이터 등)
- **행위 패턴**: 객체 간 상호작용 (옵저버, 전략 등)

---

## 1. 싱글톤 패턴 (Singleton Pattern)

### 정의

**클래스의 인스턴스가 프로그램 전체에서 단 하나만 존재**하도록 보장하는 패턴입니다.

### 사용 목적

- **전역 접근**: 어디서든 동일한 객체에 접근
- **자원 관리**: 데이터베이스 연결, 로그 파일 등 공유 자원
- **설정 관리**: 애플리케이션 전역 설정 정보

### 구현 예시

#### C++ 구현 (Thread-Safe)

```cpp
class DatabaseManager {
private:
    static DatabaseManager* instance;
    static std::mutex mutex_;

    // private 생성자
    DatabaseManager() = default;

public:
    // 복사 생성자와 대입 연산자 삭제
    DatabaseManager(const DatabaseManager&) = delete;
    DatabaseManager& operator=(const DatabaseManager&) = delete;

    static DatabaseManager* getInstance() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (instance == nullptr) {
            instance = new DatabaseManager();
        }
        return instance;
    }

    void connect() { /* DB 연결 로직 */ }
    void executeQuery(const std::string& query) { /* 쿼리 실행 */ }
};

// 정적 멤버 초기화
DatabaseManager* DatabaseManager::instance = nullptr;
std::mutex DatabaseManager::mutex_;
```

#### Java 구현 (Enum 방식 - 권장)

```java
public enum DatabaseManager {
    INSTANCE;

    public void connect() {
        // DB 연결 로직
    }

    public void executeQuery(String query) {
        // 쿼리 실행 로직
    }
}

// 사용
DatabaseManager.INSTANCE.connect();
DatabaseManager.INSTANCE.executeQuery("SELECT * FROM users");
```

#### Java 구현 (클래스 방식)

```java
public class DatabaseManager {
    private static volatile DatabaseManager instance;

    private DatabaseManager() {
        // private 생성자
    }

    public static DatabaseManager getInstance() {
        if (instance == null) {
            synchronized (DatabaseManager.class) {
                if (instance == null) {
                    instance = new DatabaseManager();
                }
            }
        }
        return instance;
    }

    public void connect() { /* DB 연결 로직 */ }
}
```

### 장단점

**장점**: 메모리 절약, 전역 접근, 데이터 공유  
**단점**: 테스트 어려움, 결합도 증가, 멀티스레드 복잡성

---

## 2. 팩토리 패턴 (Factory Pattern)

### 정의

**객체 생성 로직을 별도 클래스로 분리**하여 객체 생성을 캡슐화하는 패턴입니다.

### 사용 목적

- **생성 로직 은닉**: 복잡한 객체 생성 과정 숨김
- **유연한 객체 생성**: 조건에 따라 다른 타입 객체 생성
- **의존성 분리**: 클라이언트와 구체 클래스 간 결합도 감소

### 구현 예시

#### C++ 팩토리 메서드 패턴

```cpp
// 추상 클래스
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() = 0;
};

// 구체 클래스들
class Circle : public Shape {
public:
    void draw() override { std::cout << "Drawing Circle\n"; }
};

class Rectangle : public Shape {
public:
    void draw() override { std::cout << "Drawing Rectangle\n"; }
};

// 팩토리 클래스
class ShapeFactory {
public:
    static std::unique_ptr<Shape> createShape(const std::string& type) {
        if (type == "circle") {
            return std::make_unique<Circle>();
        } else if (type == "rectangle") {
            return std::make_unique<Rectangle>();
        }
        return nullptr;
    }
};

// 사용 예시
auto shape = ShapeFactory::createShape("circle");
shape->draw();
```

#### Java 팩토리 메서드 패턴

```java
// 추상 클래스
abstract class Shape {
    public abstract void draw();
}

// 구체 클래스들
class Circle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

class Rectangle extends Shape {
    @Override
    public void draw() {
        System.out.println("Drawing Rectangle");
    }
}

// 팩토리 클래스
class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type.toLowerCase()) {
            case "circle":
                return new Circle();
            case "rectangle":
                return new Rectangle();
            default:
                throw new IllegalArgumentException("Unknown shape type: " + type);
        }
    }
}

// 사용 예시
Shape shape = ShapeFactory.createShape("circle");
shape.draw();
```

### 장단점

**장점**: 객체 생성 캡슐화, 확장성, 코드 재사용  
**단점**: 코드 복잡도 증가, 클래스 수 증가

---

## 3. 옵저버 패턴 (Observer Pattern)

### 정의

**한 객체의 상태 변화를 여러 객체가 감시**하고, 상태 변화 시 자동으로 알림을 받는 패턴입니다.

### 사용 목적

- **느슨한 결합**: Subject와 Observer 간 의존성 최소화
- **일대다 관계**: 하나의 변화를 여러 객체가 감지
- **동적 구독**: 런타임에 관찰자 추가/제거 가능

### 구현 예시

#### C++ 구현

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

// Observer 인터페이스
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

// Subject 클래스
class NewsAgency {
private:
    std::vector<Observer*> observers;
    std::string news;

public:
    void addObserver(Observer* observer) {
        observers.push_back(observer);
    }

    void removeObserver(Observer* observer) {
        observers.erase(
            std::remove(observers.begin(), observers.end(), observer),
            observers.end()
        );
    }

    void setNews(const std::string& news) {
        this->news = news;
        notifyObservers();
    }

private:
    void notifyObservers() {
        for (auto* observer : observers) {
            observer->update(news);
        }
    }
};

// 구체적인 Observer
class NewsChannel : public Observer {
private:
    std::string name;

public:
    NewsChannel(const std::string& name) : name(name) {}

    void update(const std::string& message) override {
        std::cout << name << " received news: " << message << std::endl;
    }
};

// 사용 예시
NewsAgency agency;
NewsChannel cnn("CNN");
NewsChannel bbc("BBC");

agency.addObserver(&cnn);
agency.addObserver(&bbc);
agency.setNews("Breaking News!");  // 모든 채널이 알림 받음
```

#### Java 구현

```java
import java.util.*;

// Observer 인터페이스
interface Observer {
    void update(String message);
}

// Subject 클래스
class NewsAgency {
    private List<Observer> observers = new ArrayList<>();
    private String news;

    public void addObserver(Observer observer) {
        observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }

    private void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// 구체적인 Observer
class NewsChannel implements Observer {
    private String name;

    public NewsChannel(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " received news: " + message);
    }
}

// 사용 예시
NewsAgency agency = new NewsAgency();
NewsChannel cnn = new NewsChannel("CNN");
NewsChannel bbc = new NewsChannel("BBC");

agency.addObserver(cnn);
agency.addObserver(bbc);
agency.setNews("Breaking News!");  // 모든 채널이 알림 받음
```

### 장단점

**장점**: 느슨한 결합, 동적 관계, 개방-폐쇄 원칙  
**단점**: 메모리 누수 가능성, 순환 참조 위험, 성능 고려

---

## 기타 주요 패턴 (간략 소개)

### 전략 패턴 (Strategy Pattern)

**목적**: 알고리즘을 캡슐화하고 런타임에 교체 가능하게 함

```java
interface PaymentStrategy {
    void pay(int amount);
}

class CreditCardPayment implements PaymentStrategy {
    public void pay(int amount) { /* 신용카드 결제 */ }
}

class PayPalPayment implements PaymentStrategy {
    public void pay(int amount) { /* 페이팔 결제 */ }
}
```

### 어댑터 패턴 (Adapter Pattern)

**목적**: 호환되지 않는 인터페이스를 연결

```cpp
class LegacyPrinter {
public:
    void oldPrint(const std::string& text) { /* 구형 출력 */ }
};

class PrinterAdapter {
private:
    LegacyPrinter* legacyPrinter;
public:
    PrinterAdapter(LegacyPrinter* printer) : legacyPrinter(printer) {}
    void print(const std::string& text) {
        legacyPrinter->oldPrint(text);  // 인터페이스 변환
    }
};
```

### 데코레이터 패턴 (Decorator Pattern)

**목적**: 객체에 동적으로 기능 추가

```java
interface Coffee {
    String getDescription();
    double getCost();
}

class SimpleCoffee implements Coffee {
    public String getDescription() { return "Simple Coffee"; }
    public double getCost() { return 2.0; }
}

class MilkDecorator implements Coffee {
    private Coffee coffee;
    public MilkDecorator(Coffee coffee) { this.coffee = coffee; }
    public String getDescription() { return coffee.getDescription() + ", Milk"; }
    public double getCost() { return coffee.getCost() + 0.5; }
}
```

---

## 패턴 선택 가이드

### 언제 사용해야 할까?

| 패턴       | 사용 시점                                  | 실제 예시                   |
| ---------- | ------------------------------------------ | --------------------------- |
| **싱글톤** | 전역에서 하나의 인스턴스만 필요한 경우     | 설정 관리자, DB 커넥션 풀   |
| **팩토리** | 객체 생성 로직이 복잡하거나 조건부인 경우  | GUI 컴포넌트, 파일 파서     |
| **옵저버** | 상태 변화를 여러 객체가 감지해야 하는 경우 | 이벤트 시스템, 모델-뷰 구조 |
| **전략**   | 알고리즘을 런타임에 교체해야 하는 경우     | 결제 시스템, 정렬 알고리즘  |
| **어댑터** | 기존 클래스를 수정 없이 새 인터페이스 적용 | 레거시 시스템 연동          |

### 패턴 남용 주의

- **과도한 추상화**: 단순한 문제에 복잡한 패턴 적용 금지
- **패턴을 위한 패턴**: 실제 필요성 없이 패턴 사용 지양
- **적절한 수준**: 팀의 이해도와 프로젝트 복잡도 고려

---

## 요약

### 핵심 패턴 정리

| 패턴   | 핵심 아이디어                  | 해결하는 문제             |
| ------ | ------------------------------ | ------------------------- |
| 싱글톤 | 전역에서 하나의 인스턴스만     | 자원 공유, 전역 상태 관리 |
| 팩토리 | 객체 생성을 별도 클래스가 담당 | 복잡한 생성 로직, 확장성  |
| 옵저버 | 상태 변화를 여러 객체가 감지   | 느슨한 결합, 이벤트 처리  |

---
