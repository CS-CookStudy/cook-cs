# 8.3.2 TDD (Test-Driven Development) 개념

## TDD란?

### 정의

TDD(Test-Driven Development)는 **테스트를 먼저 작성하고 그 테스트를 통과하는 코드를 구현**하는 개발 방법론입니다.

### TDD의 핵심 철학

- **실패하는 테스트부터 시작**: 아직 구현되지 않은 기능의 테스트를 먼저 작성
- **최소한의 코드**: 테스트를 통과할 수 있는 최소한의 코드만 작성
- **지속적 개선**: 동작하는 코드를 지속적으로 리팩토링하여 품질 향상

---

## TDD 사이클: Red-Green-Refactor

### 🔴 Red (실패하는 테스트 작성)

**목적**: 구현하고자 하는 기능에 대한 테스트를 먼저 작성

**특징**:

- 테스트는 반드시 실패해야 함 (구현이 없으므로)
- 명확한 요구사항과 예상 결과를 정의
- 테스트 실패 이유가 "기능 미구현" 때문임을 확인

### 🟢 Green (테스트를 통과하는 최소 코드 작성)

**목적**: 테스트를 통과할 수 있는 가장 간단한 코드 구현

**특징**:

- 테스트를 통과하는 것이 유일한 목표
- 완벽한 구현보다는 동작하는 코드가 우선
- 예쁘지 않거나 효율적이지 않아도 OK

### 🔵 Refactor (코드 개선)

**목적**: 테스트를 통과하는 상태를 유지하면서 코드 품질 향상

**특징**:

- 기존 테스트는 여전히 통과해야 함
- 코드 가독성, 성능, 설계 개선
- 새로운 테스트 케이스 추가 가능

### 사이클 반복

```
Red → Green → Refactor → Red → Green → Refactor → ...
```

---

## TDD 실제 예시: 계산기 만들기

### 1차 사이클: 덧셈 기능

**🔴 Red**: 실패하는 테스트 작성

**C++ 예시**

```cpp
#include <gtest/gtest.h>
#include "Calculator.h"  // 아직 없는 파일

TEST(CalculatorTest, AddTwoNumbers) {
    Calculator calc;
    EXPECT_EQ(5, calc.add(2, 3));
}
// 컴파일 에러 발생 → Red 상태
```

**Java 예시**

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
    @Test
    void shouldAddTwoNumbers() {
        Calculator calc = new Calculator();  // 컴파일 에러
        assertEquals(5, calc.add(2, 3));
    }
}
```

**🟢 Green**: 최소 구현

**C++ 구현**

```cpp
// Calculator.h
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }
};
// 테스트 통과!
```

**Java 구현**

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
// 테스트 통과!
```

**🔵 Refactor**: 개선 (이 경우 개선할 것이 없음)

### 2차 사이클: 나눗셈 기능

**🔴 Red**: 나눗셈 테스트 추가

**C++**

```cpp
TEST(CalculatorTest, DivideTwoNumbers) {
    Calculator calc;
    EXPECT_DOUBLE_EQ(2.5, calc.divide(5, 2));
}

TEST(CalculatorTest, DivideByZeroThrowsException) {
    Calculator calc;
    EXPECT_THROW(calc.divide(10, 0), std::invalid_argument);
}
```

**Java**

```java
@Test
void shouldDivideTwoNumbers() {
    Calculator calc = new Calculator();
    assertEquals(2.5, calc.divide(5, 2), 0.001);
}

@Test
void shouldThrowExceptionWhenDividingByZero() {
    Calculator calc = new Calculator();
    assertThrows(IllegalArgumentException.class,
                () -> calc.divide(10, 0));
}
```

**🟢 Green**: 나눗셈 구현

**C++**

```cpp
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }

    double divide(int a, int b) {
        if (b == 0) {
            throw std::invalid_argument("Division by zero");
        }
        return static_cast<double>(a) / b;
    }
};
```

**Java**

```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public double divide(int a, int b) {
        if (b == 0) {
            throw new IllegalArgumentException("Division by zero");
        }
        return (double) a / b;
    }
}
```

**🔵 Refactor**: 입력값 검증 개선

**C++**

```cpp
class Calculator {
private:
    void validateNumbers(int a, int b) {
        // 필요시 추가 검증 로직
    }

public:
    int add(int a, int b) {
        validateNumbers(a, b);
        return a + b;
    }

    double divide(int a, int b) {
        validateNumbers(a, b);
        if (b == 0) {
            throw std::invalid_argument("Division by zero");
        }
        return static_cast<double>(a) / b;
    }
};
```

---

## TDD의 장점

### 1. 설계 개선

- **인터페이스 우선 설계**: 사용자 관점에서 API 설계
- **의존성 분리**: 테스트 가능한 코드는 결합도가 낮음
- **단순한 설계**: 과도한 설계를 방지하고 필요한 기능만 구현

### 2. 높은 테스트 커버리지

- **자연스러운 100% 커버리지**: 모든 코드가 테스트에 의해 작성됨
- **의미있는 테스트**: 실제 요구사항 기반의 테스트
- **회귀 테스트**: 기존 기능의 안정성 보장

### 3. 빠른 피드백

- **즉시 검증**: 코드 작성과 동시에 동작 확인
- **디버깅 시간 단축**: 문제 발생 시 범위가 작아 원인 파악 쉬움
- **자신감**: 코드 변경에 대한 두려움 감소

---

## TDD 적용 시 주의사항

### 학습 곡선

- **초기 속도 저하**: TDD에 익숙해지기까지 시간 필요
- **테스트 작성 기술**: 좋은 테스트 작성 방법 학습 필요

### 과도한 테스트

- **테스트를 위한 테스트** 지양
- **핵심 로직에 집중**: 중요한 비즈니스 로직 우선
- **적절한 수준**: 100% 커버리지가 항상 좋은 것은 아님

### 팀 적용

- **팀 전체 동의**: 팀원 모두가 TDD 방식에 동의해야 함
- **점진적 도입**: 중요한 모듈부터 단계적 적용
- **지속적 연습**: 꾸준한 연습과 개선 필요

---

## 요약

### TDD 핵심 포인트

- **Red-Green-Refactor 사이클**: 실패 → 성공 → 개선 반복
- **테스트 우선**: 구현보다 테스트가 먼저
- **최소 구현**: 테스트를 통과하는 최소한의 코드만 작성
- **지속적 개선**: 리팩토링을 통한 코드 품질 향상
