# 8.3.1 단위 테스트와 통합 테스트

## 소프트웨어 테스팅 개요

### 정의

소프트웨어 테스팅은 **개발한 프로그램이 요구사항에 맞게 동작하는지 검증**하는 과정입니다.

### 테스트의 중요성

- **버그 조기 발견**: 개발 초기 문제 발견으로 수정 비용 절감
- **품질 보장**: 요구사항에 맞는 동작 확인
- **리팩토링 안전성**: 코드 변경 시 기존 기능 보호
- **문서화 효과**: 테스트 코드가 사용법 설명

### 테스트 피라미드

```
    E2E 테스트 (느리고 비싸지만 실제와 유사)
   통합 테스트 (중간 속도, 중간 비용)
  단위 테스트 (빠르고 저렴하지만 범위 제한적)
```

---

## 단위 테스트 (Unit Test)

### 정의

**가장 작은 단위의 코드 조각**(함수, 메서드, 클래스)을 독립적으로 테스트하는 방법입니다.

### 특징

- **독립성**: 다른 테스트나 외부 시스템에 의존하지 않음
- **빠른 실행**: 수 밀리초 단위로 실행
- **자동화**: 코드 변경 시 자동 실행하여 즉시 피드백
- **명확한 범위**: 하나의 기능이나 메서드만 테스트

### C++ 단위 테스트 예시 (Google Test)

```cpp
// 테스트할 클래스
class Calculator {
public:
    int add(int a, int b) { return a + b; }
    double divide(int a, int b) {
        if (b == 0) throw std::invalid_argument("Cannot divide by zero");
        return static_cast<double>(a) / b;
    }
};

// 단위 테스트
TEST(CalculatorTest, AddTwoNumbers) {
    Calculator calc;
    EXPECT_EQ(5, calc.add(2, 3));
    EXPECT_EQ(0, calc.add(-1, 1));
}

TEST(CalculatorTest, DivideByZeroThrowsException) {
    Calculator calc;
    EXPECT_THROW(calc.divide(10, 0), std::invalid_argument);
}
```

### Java 단위 테스트 예시 (JUnit 5)

```java
class CalculatorTest {
    private Calculator calculator;

    @BeforeEach
    void setUp() {
        calculator = new Calculator();
    }

    @Test
    void testAdd() {
        assertEquals(5, calculator.add(2, 3));
        assertEquals(0, calculator.add(-1, 1));
    }

    @Test
    void testDivideByZero() {
        assertThrows(IllegalArgumentException.class,
                    () -> calculator.divide(10, 0));
    }
}
```

### AAA 패턴

- **Arrange (준비)**: 테스트 데이터와 환경 설정
- **Act (실행)**: 테스트하려는 코드 실행
- **Assert (검증)**: 결과가 예상과 일치하는지 확인

### FIRST 원칙

- **Fast**: 빠르게 실행
- **Independent**: 다른 테스트에 의존하지 않음
- **Repeatable**: 어떤 환경에서도 동일한 결과
- **Self-Validating**: 성공/실패가 명확
- **Timely**: 프로덕션 코드와 동시에 작성

---

## 통합 테스트 (Integration Test)

### 정의

**여러 컴포넌트나 모듈들이 함께 동작**할 때의 상호작용을 테스트하는 방법입니다.

### 특징

- **상호작용 중심**: 모듈 간 인터페이스와 데이터 흐름 검증
- **실제 환경**: 실제 운영 환경과 유사한 조건에서 테스트
- **의존성 포함**: 데이터베이스, 웹 서비스 등 외부 의존성 활용

### 통합 테스트 전략

- **Big Bang 통합**: 모든 모듈을 한 번에 통합 (간단하지만 오류 찾기 어려움)
- **점진적 통합**: 모듈을 단계적으로 통합 (상향식, 하향식, 샌드위치)

### Java 통합 테스트 예시

```java
@SpringBootTest
@Transactional
public class UserServiceIntegrationTest {

    @Autowired
    private UserService userService;

    @Autowired
    private UserRepository userRepository;

    @Test
    public void testCreateAndFindUser() {
        // Given
        User user = new User("testuser", "test@example.com");

        // When
        User savedUser = userService.createUser(user);
        User foundUser = userRepository.findById(savedUser.getId()).orElse(null);

        // Then
        assertNotNull(foundUser);
        assertEquals("testuser", foundUser.getUsername());
    }
}
```

---

## 테스트 더블 (Test Double)

### Mock 객체 활용

#### C++ Mock 예시 (GMock)

```cpp
class MockDatabase {
public:
    MOCK_METHOD(bool, saveUser, (const User& user));
    MOCK_METHOD(std::optional<User>, findUser, (int id));
};

TEST(UserServiceTest, CreateUserCallsDatabase) {
    MockDatabase mockDB;
    UserService service(&mockDB);
    User user{"john", "john@test.com"};

    EXPECT_CALL(mockDB, saveUser(user)).WillOnce(Return(true));

    bool result = service.createUser(user);
    EXPECT_TRUE(result);
}
```

#### Java Mock 예시 (Mockito)

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void createUserShouldSaveUser() {
        // Given
        User user = new User("john", "john@test.com");
        when(userRepository.save(any(User.class))).thenReturn(user);

        // When
        User result = userService.createUser("john", "john@test.com");

        // Then
        assertEquals("john", result.getUsername());
        verify(userRepository).save(any(User.class));
    }
}
```

---

## 테스트 작성 가이드

### 좋은 테스트 특징

1. **명확한 테스트 이름**: 기능과 예상 결과가 명시
2. **하나의 관심사**: 한 테스트는 하나의 기능만 검증
3. **예상 가능한 결과**: 경계값과 예외 상황 포함

### 테스트 도구

| 언어       | 단위 테스트         | 통합 테스트       | 특징                  |
| ---------- | ------------------- | ----------------- | --------------------- |
| **Java**   | JUnit, TestNG       | Spring Test       | JUnit 5가 표준        |
| **C++**    | Google Test, Catch2 | 프레임워크별 상이 | Google Test 널리 사용 |
| **Python** | pytest, unittest    | Django Test       | pytest가 권장         |

---

## 테스트 커버리지

### 커버리지 지표

- **라인 커버리지**: 실행된 코드 라인 비율
- **브랜치 커버리지**: 조건문의 모든 경우 실행 비율
- **함수 커버리지**: 호출된 함수 비율

### 커버리지 목표

- **일반적 목표**: 80% 이상
- **중요한 모듈**: 90% 이상
- **100% 추구 금지**: 의미 없는 테스트는 오히려 해로움

---

## 요약

### 단위 테스트 vs 통합 테스트

| 구분          | 단위 테스트      | 통합 테스트            |
| ------------- | ---------------- | ---------------------- |
| **범위**      | 개별 함수/메서드 | 여러 컴포넌트 상호작용 |
| **속도**      | 매우 빠름 (ms)   | 상대적으로 느림 (초)   |
| **의존성**    | 없음 (Mock 사용) | 실제 의존성 사용       |
| **목적**      | 로직 검증        | 연동 검증              |
| **실행 빈도** | 매우 자주        | 정기적                 |

---
