# 3.2 비선형 자료구조와 트리

## 1. 비선형 자료구조란?

**비선형 자료구조**는 데이터 요소들이 순차적으로 배열되지 않고, 하나의 원소 뒤에 여러 개의 원소가 존재할 수 있는 자료구조입니다.

## 2. 트리(Tree)

**트리**는 노드들이 계층적으로 연결된 비선형 자료구조로, 사이클이 없는 연결 그래프입니다.

### 2.1 트리 용어

#### 핵심 용어들

- **노드(Node)**: 트리의 구성 요소, 데이터를 저장하는 기본 단위
- **간선(Edge)**: 노드와 노드를 연결하는 선
- **루트(Root)**: 트리의 최상위 노드, 부모가 없는 유일한 노드
- **리프(Leaf)**: 자식이 없는 노드, 단말 노드라고도 함

#### 추가 용어들

- **부모 노드(Parent)**: 특정 노드의 상위 노드
- **자식 노드(Child)**: 특정 노드의 하위 노드
- **형제 노드(Sibling)**: 같은 부모를 가진 노드들
- **레벨(Level)**: 루트로부터의 거리 (루트는 레벨 0)
- **높이(Height)**: 트리의 최대 레벨 + 1
- **깊이(Depth)**: 루트에서 특정 노드까지의 경로 길이

```
        A (루트, 레벨 0)
       / \
      B   C (레벨 1)
     / \   \
    D   E   F (레벨 2)
   /
  G (리프, 레벨 3)

- 높이: 4
- B와 C는 형제 노드
- D, E, F, G는 리프 노드
```

### 2.2 이진 트리의 종류

#### 이진 트리 (Binary Tree)

- 각 노드가 **최대 2개의 자식**을 가지는 트리
- 왼쪽 자식과 오른쪽 자식으로 구분

#### 완전 이진 트리 (Complete Binary Tree)

- 마지막 레벨을 제외한 모든 레벨이 완전히 채워진 트리
- 마지막 레벨은 왼쪽부터 순서대로 채워짐
- **힙(Heap)** 구현에 주로 사용

```
완전 이진 트리 예시:
        1
       / \
      2   3
     / \ /
    4  5 6
```

#### 포화 이진 트리 (Full Binary Tree)

- 모든 레벨이 완전히 채워진 이진 트리
- 레벨 k에서 노드 개수: 2^k개
- 총 노드 개수: 2^h - 1개 (h는 높이)

```
포화 이진 트리 예시:
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

### 2.3 트리 순회 (Tree Traversal)

트리의 모든 노드를 특정 순서로 방문하는 방법입니다.

#### 전위 순회 (Preorder Traversal)

**순서**: 루트 → 왼쪽 서브트리 → 오른쪽 서브트리

```
전위 순회 알고리즘:
1. 현재 노드 방문
2. 왼쪽 서브트리 전위 순회
3. 오른쪽 서브트리 전위 순회
```

#### 중위 순회 (Inorder Traversal)

**순서**: 왼쪽 서브트리 → 루트 → 오른쪽 서브트리

```
중위 순회 알고리즘:
1. 왼쪽 서브트리 중위 순회
2. 현재 노드 방문
3. 오른쪽 서브트리 중위 순회
```

#### 후위 순회 (Postorder Traversal)

**순서**: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트

```
후위 순회 알고리즘:
1. 왼쪽 서브트리 후위 순회
2. 오른쪽 서브트리 후위 순회
3. 현재 노드 방문
```

#### 레벨 순회 (Level Order Traversal)

**순서**: 레벨 순서대로 왼쪽부터 오른쪽으로

```
레벨 순회 알고리즘:
1. 큐를 사용하여 구현
2. 루트를 큐에 삽입
3. 큐가 빌 때까지 반복:
   - 노드를 큐에서 제거하고 방문
   - 해당 노드의 자식들을 큐에 삽입
```

### 순회 예시

```
트리 구조:
        1
       / \
      2   3
     / \
    4   5

전위 순회: 1 → 2 → 4 → 5 → 3
중위 순회: 4 → 2 → 5 → 1 → 3
후위 순회: 4 → 5 → 2 → 3 → 1
레벨 순회: 1 → 2 → 3 → 4 → 5
```

## 3. 이진 탐색 트리 (Binary Search Tree, BST)

**이진 탐색 트리**는 이진 트리의 특별한 형태로, 효율적인 탐색을 위해 특정 규칙을 따르는 자료구조입니다.

### 3.1 BST의 성질

#### 핵심 규칙

- **왼쪽 서브트리**의 모든 값 < **부모 노드**의 값
- **오른쪽 서브트리**의 모든 값 > **부모 노드**의 값
- 모든 서브트리도 이진 탐색 트리여야 함

```
BST 예시:
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

중위 순회: 1, 3, 4, 6, 7, 8, 10, 13, 14 (정렬된 순서!)
```

### 3.2 BST의 연산

#### 탐색 (Search)

```
탐색 알고리즘:
1. 루트부터 시작
2. 찾는 값이 현재 노드보다 작으면 왼쪽으로
3. 찾는 값이 현재 노드보다 크면 오른쪽으로
4. 값을 찾거나 NULL에 도달할 때까지 반복

시간복잡도: O(h), h는 트리의 높이
```

#### 삽입 (Insert)

```
삽입 알고리즘:
1. 탐색과 동일한 방식으로 위치 찾기
2. 적절한 위치에 새 노드 삽입
3. BST 성질 유지

시간복잡도: O(h)
```

#### 삭제 (Delete)

```
삭제 알고리즘 (3가지 경우):

1. 리프 노드 삭제: 그냥 제거
2. 자식이 하나인 노드: 자식으로 대체
3. 자식이 둘인 노드:
   - 중위 순회 후계자(오른쪽 서브트리의 최솟값)로 대체
   - 또는 중위 순회 선행자(왼쪽 서브트리의 최댓값)로 대체

시간복잡도: O(h)
```

### 3.3 균형 트리

#### 문제점

- 일반 BST는 **불균형**해질 수 있음
- 최악의 경우 **연결 리스트**처럼 되어 O(n) 시간복잡도

```
불균형 BST:
1
 \
  2
   \
    3
     \
      4  (높이 = 4, 탐색 시간 = O(n))
```

#### AVL 트리

- **높이 균형** 이진 탐색 트리
- 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이 ≤ 1
- **회전(Rotation)** 연산으로 균형 유지
- 시간복잡도: **O(log n)** 보장

#### Red-Black 트리

- **색깔 균형** 이진 탐색 트리
- 각 노드는 **빨간색** 또는 **검은색**
- 특정 색깔 규칙으로 균형 유지
- 시간복잡도: **O(log n)** 보장

### 3.4 B-Tree와 B+ Tree

#### B-Tree

- **다진 탐색 트리** (각 노드가 여러 개의 키를 가짐)
- 모든 리프 노드가 **같은 레벨**에 있음
- **데이터베이스**와 **파일 시스템**에서 사용
- 디스크 I/O 효율성이 뛰어남

#### B+ Tree

- B-Tree의 변형
- **내부 노드**는 인덱스만, **리프 노드**에만 실제 데이터
- 리프 노드들이 **연결 리스트**로 연결
- **범위 검색**에 효율적
- **데이터베이스**에서 널리 사용

## 4. 힙 (Heap)

**힙**은 **완전 이진 트리** 형태의 자료구조로, 부모-자식 간의 대소관계가 일정한 규칙을 따릅니다.

### 4.1 힙의 종류

#### 최대 힙 (Max Heap)

- **부모 노드** ≥ **자식 노드**
- 루트 노드가 **최댓값**

```
최대 힙 예시:
        100
       /   \
      19    36
     / \   / \
    17  3 25  1
   / \
  2   7

루트(100)가 최댓값
```

#### 최소 힙 (Min Heap)

- **부모 노드** ≤ **자식 노드**
- 루트 노드가 **최솟값**

```
최소 힙 예시:
         1
       /   \
      3     6
     / \   / \
    5   9 8   10
   / \
  15  17

루트(1)가 최솟값
```

### 4.2 힙의 연산

#### 삽입 (Insert)

```
삽입 알고리즘:
1. 완전 이진 트리 마지막 위치에 새 원소 추가
2. 부모와 비교하여 힙 성질 위반 시 교환 (상향식)
3. 힙 성질을 만족할 때까지 반복

시간복잡도: O(log n)
```

#### 삭제 (Delete)

```
삭제 알고리즘 (보통 루트 삭제):
1. 루트 노드 제거
2. 마지막 노드를 루트로 이동
3. 자식들과 비교하여 힙 성질 위반 시 교환 (하향식)
4. 힙 성질을 만족할 때까지 반복

시간복잡도: O(log n)
```

### 4.3 힙 정렬 (Heap Sort)

```
힙 정렬 알고리즘:
1. 주어진 배열을 최대 힙으로 구성
2. 루트(최댓값)를 배열 끝으로 이동
3. 힙 크기를 1 줄이고 다시 힙 구성
4. 힙 크기가 1이 될 때까지 반복

시간복잡도: O(n log n)
공간복잡도: O(1) - 제자리 정렬
```

### 4.4 우선순위 큐 구현

**우선순위 큐**는 각 원소가 우선순위를 가지며, 우선순위가 높은 원소가 먼저 처리되는 자료구조입니다.

#### 힙을 이용한 구현

```
우선순위 큐 연산:
- Insert: 새 원소 삽입 → O(log n)
- ExtractMax/Min: 최우선순위 원소 제거 → O(log n)
- Peek: 최우선순위 원소 확인 → O(1)

최대 힙 → 최대 우선순위 큐
최소 힙 → 최소 우선순위 큐
```

#### 응용 분야

- **작업 스케줄링**: 우선순위가 높은 작업 먼저 처리
- **다익스트라 알고리즘**: 최단 경로 찾기
- **허프만 코딩**: 데이터 압축
- **이벤트 시뮬레이션**: 시간 순서대로 이벤트 처리

### 힙 vs 기타 자료구조 비교

| 연산          | 힙       | 정렬된 배열 | 정렬된 연결리스트 |
| ------------- | -------- | ----------- | ----------------- |
| 삽입          | O(log n) | O(n)        | O(n)              |
| 삭제          | O(log n) | O(n)        | O(n)              |
| 최댓값/최솟값 | O(1)     | O(1)        | O(1)              |

**힙의 장점**: 삽입과 삭제가 모두 O(log n)으로 효율적
