# 3.2 비선형 자료구조와 트리

## 1. 비선형 자료구조란?

**비선형 자료구조**는 데이터 요소들이 순차적으로 배열되지 않고, 하나의 원소 뒤에 여러 개의 원소가 존재할 수 있는 자료구조입니다.

## 2. 트리(Tree)

**트리**는 노드들이 계층적으로 연결된 비선형 자료구조로, 사이클이 없는 연결 그래프입니다.

### 2.1 트리 용어

#### 핵심 용어들

- **노드(Node)**: 트리의 구성 요소, 데이터를 저장하는 기본 단위
- **간선(Edge)**: 노드와 노드를 연결하는 선
- **루트(Root)**: 트리의 최상위 노드, 부모가 없는 유일한 노드
- **리프(Leaf)**: 자식이 없는 노드, 단말 노드라고도 함

#### 추가 용어들

- **부모 노드(Parent)**: 특정 노드의 상위 노드
- **자식 노드(Child)**: 특정 노드의 하위 노드
- **형제 노드(Sibling)**: 같은 부모를 가진 노드들
- **레벨(Level)**: 루트로부터의 거리 (루트는 레벨 0)
- **높이(Height)**: 트리의 최대 레벨 + 1
- **깊이(Depth)**: 루트에서 특정 노드까지의 경로 길이

```
        A (루트, 레벨 0)
       / \
      B   C (레벨 1)
     / \   \
    D   E   F (레벨 2)
   /
  G (리프, 레벨 3)

- 높이: 4
- B와 C는 형제 노드
- D, E, F, G는 리프 노드
```

### 2.2 이진 트리의 종류

#### 이진 트리 (Binary Tree)

- 각 노드가 **최대 2개의 자식**을 가지는 트리
- 왼쪽 자식과 오른쪽 자식으로 구분

#### 완전 이진 트리 (Complete Binary Tree)

- 마지막 레벨을 제외한 모든 레벨이 완전히 채워진 트리
- 마지막 레벨은 왼쪽부터 순서대로 채워짐
- **힙(Heap)** 구현에 주로 사용

```
완전 이진 트리 예시:
        1
       / \
      2   3
     / \ /
    4  5 6
```

#### 포화 이진 트리 (Full Binary Tree)

- 모든 레벨이 완전히 채워진 이진 트리
- 레벨 k에서 노드 개수: 2^k개
- 총 노드 개수: 2^h - 1개 (h는 높이)

```
포화 이진 트리 예시:
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

### 2.3 트리 순회 (Tree Traversal)

트리의 모든 노드를 특정 순서로 방문하는 방법입니다.

#### 전위 순회 (Preorder Traversal)

**순서**: 루트 → 왼쪽 서브트리 → 오른쪽 서브트리

```
전위 순회 알고리즘:
1. 현재 노드 방문
2. 왼쪽 서브트리 전위 순회
3. 오른쪽 서브트리 전위 순회
```

#### 중위 순회 (Inorder Traversal)

**순서**: 왼쪽 서브트리 → 루트 → 오른쪽 서브트리

```
중위 순회 알고리즘:
1. 왼쪽 서브트리 중위 순회
2. 현재 노드 방문
3. 오른쪽 서브트리 중위 순회
```

#### 후위 순회 (Postorder Traversal)

**순서**: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트

```
후위 순회 알고리즘:
1. 왼쪽 서브트리 후위 순회
2. 오른쪽 서브트리 후위 순회
3. 현재 노드 방문
```

#### 레벨 순회 (Level Order Traversal)

**순서**: 레벨 순서대로 왼쪽부터 오른쪽으로

```
레벨 순회 알고리즘:
1. 큐를 사용하여 구현
2. 루트를 큐에 삽입
3. 큐가 빌 때까지 반복:
   - 노드를 큐에서 제거하고 방문
   - 해당 노드의 자식들을 큐에 삽입
```

### 순회 예시

```
트리 구조:
        1
       / \
      2   3
     / \
    4   5

전위 순회: 1 → 2 → 4 → 5 → 3
중위 순회: 4 → 2 → 5 → 1 → 3
후위 순회: 4 → 5 → 2 → 3 → 1
레벨 순회: 1 → 2 → 3 → 4 → 5
```

## 3. 이진 탐색 트리 (Binary Search Tree, BST)

**이진 탐색 트리**는 이진 트리의 특별한 형태로, 효율적인 탐색을 위해 특정 규칙을 따르는 자료구조입니다.

### 3.1 BST의 성질

#### 핵심 규칙

- **왼쪽 서브트리**의 모든 값 < **부모 노드**의 값
- **오른쪽 서브트리**의 모든 값 > **부모 노드**의 값
- 모든 서브트리도 이진 탐색 트리여야 함

```
BST 예시:
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13

중위 순회: 1, 3, 4, 6, 7, 8, 10, 13, 14 (정렬된 순서!)
```

### 3.2 BST의 연산

#### 탐색 (Search)

```
탐색 알고리즘:
1. 루트부터 시작
2. 찾는 값이 현재 노드보다 작으면 왼쪽으로
3. 찾는 값이 현재 노드보다 크면 오른쪽으로
4. 값을 찾거나 NULL에 도달할 때까지 반복

시간복잡도: O(h), h는 트리의 높이
```

#### 삽입 (Insert)

```
삽입 알고리즘:
1. 탐색과 동일한 방식으로 위치 찾기
2. 적절한 위치에 새 노드 삽입
3. BST 성질 유지

시간복잡도: O(h)
```

#### 삭제 (Delete)

```
삭제 알고리즘 (3가지 경우):

1. 리프 노드 삭제: 그냥 제거
2. 자식이 하나인 노드: 자식으로 대체
3. 자식이 둘인 노드:
   - 중위 순회 후계자(오른쪽 서브트리의 최솟값)로 대체
   - 또는 중위 순회 선행자(왼쪽 서브트리의 최댓값)로 대체

시간복잡도: O(h)
```

### 3.3 균형 트리

#### 문제점

- 일반 BST는 **불균형**해질 수 있음
- 최악의 경우 **연결 리스트**처럼 되어 O(n) 시간복잡도

```
불균형 BST:
1
 \
  2
   \
    3
     \
      4  (높이 = 4, 탐색 시간 = O(n))
```

#### AVL 트리

- **높이 균형** 이진 탐색 트리
- 모든 노드에서 왼쪽과 오른쪽 서브트리의 높이 차이 ≤ 1
- **회전(Rotation)** 연산으로 균형 유지
- 시간복잡도: **O(log n)** 보장

#### Red-Black 트리

- **색깔 균형** 이진 탐색 트리
- 각 노드는 **빨간색** 또는 **검은색**
- 특정 색깔 규칙으로 균형 유지
- 시간복잡도: **O(log n)** 보장

### 3.4 B-Tree와 B+ Tree

#### B-Tree

- **다진 탐색 트리** (각 노드가 여러 개의 키를 가짐)
- 모든 리프 노드가 **같은 레벨**에 있음
- **데이터베이스**와 **파일 시스템**에서 사용
- 디스크 I/O 효율성이 뛰어남

#### B+ Tree

- B-Tree의 변형
- **내부 노드**는 인덱스만, **리프 노드**에만 실제 데이터
- 리프 노드들이 **연결 리스트**로 연결
- **범위 검색**에 효율적
- **데이터베이스**에서 널리 사용

## 4. 힙 (Heap)

**힙**은 **완전 이진 트리** 형태의 자료구조로, 부모-자식 간의 대소관계가 일정한 규칙을 따릅니다.

### 4.1 힙의 종류

#### 최대 힙 (Max Heap)

- **부모 노드** ≥ **자식 노드**
- 루트 노드가 **최댓값**

```
최대 힙 예시:
        100
       /   \
      19    36
     / \   / \
    17  3 25  1
   / \
  2   7

루트(100)가 최댓값
```

#### 최소 힙 (Min Heap)

- **부모 노드** ≤ **자식 노드**
- 루트 노드가 **최솟값**

```
최소 힙 예시:
         1
       /   \
      3     6
     / \   / \
    5   9 8   10
   / \
  15  17

루트(1)가 최솟값
```

### 4.2 힙의 연산

#### 삽입 (Insert)

```
삽입 알고리즘:
1. 완전 이진 트리 마지막 위치에 새 원소 추가
2. 부모와 비교하여 힙 성질 위반 시 교환 (상향식)
3. 힙 성질을 만족할 때까지 반복

시간복잡도: O(log n)
```

#### 삭제 (Delete)

```
삭제 알고리즘 (보통 루트 삭제):
1. 루트 노드 제거
2. 마지막 노드를 루트로 이동
3. 자식들과 비교하여 힙 성질 위반 시 교환 (하향식)
4. 힙 성질을 만족할 때까지 반복

시간복잡도: O(log n)
```

### 4.3 힙 정렬 (Heap Sort)

```
힙 정렬 알고리즘:
1. 주어진 배열을 최대 힙으로 구성
2. 루트(최댓값)를 배열 끝으로 이동
3. 힙 크기를 1 줄이고 다시 힙 구성
4. 힙 크기가 1이 될 때까지 반복

시간복잡도: O(n log n)
공간복잡도: O(1) - 제자리 정렬
```

### 4.4 우선순위 큐 구현

**우선순위 큐**는 각 원소가 우선순위를 가지며, 우선순위가 높은 원소가 먼저 처리되는 자료구조입니다.

#### 힙을 이용한 구현

```
우선순위 큐 연산:
- Insert: 새 원소 삽입 → O(log n)
- ExtractMax/Min: 최우선순위 원소 제거 → O(log n)
- Peek: 최우선순위 원소 확인 → O(1)

최대 힙 → 최대 우선순위 큐
최소 힙 → 최소 우선순위 큐
```

#### 응용 분야

- **작업 스케줄링**: 우선순위가 높은 작업 먼저 처리
- **다익스트라 알고리즘**: 최단 경로 찾기
- **허프만 코딩**: 데이터 압축
- **이벤트 시뮬레이션**: 시간 순서대로 이벤트 처리

### 힙 vs 기타 자료구조 비교

| 연산          | 힙       | 정렬된 배열 | 정렬된 연결리스트 |
| ------------- | -------- | ----------- | ----------------- |
| 삽입          | O(log n) | O(n)        | O(n)              |
| 삭제          | O(log n) | O(n)        | O(n)              |
| 최댓값/최솟값 | O(1)     | O(1)        | O(1)              |

**힙의 장점**: 삽입과 삭제가 모두 O(log n)으로 효율적

# 5. 그래프 (Graph)

**그래프**는 노드(정점)들과 이들을 연결하는 간선들의 집합으로 이루어진 비선형 자료구조입니다. 실제 세계의 다양한 관계를 모델링하는 데 사용됩니다.

## 5.1 그래프 기본 개념

### 그래프 정의

- **G = (V, E)**
- **V**: 정점(Vertex) 또는 노드(Node)의 집합
- **E**: 간선(Edge)의 집합

### 기본 용어

- **정점(Vertex)**: 그래프의 노드, 데이터를 저장하는 기본 단위
- **간선(Edge)**: 두 정점을 연결하는 선
- **인접(Adjacent)**: 두 정점이 간선으로 직접 연결된 관계
- **차수(Degree)**: 한 정점에 연결된 간선의 개수
- **경로(Path)**: 한 정점에서 다른 정점까지의 간선 순서
- **사이클(Cycle)**: 시작점과 끝점이 같은 경로

```
그래프 예시:
    A ---- B
    |    / |
    |   /  |
    |  /   |
    | /    |
    C ---- D

정점: {A, B, C, D}
간선: {(A,B), (A,C), (B,C), (B,D), (C,D)}
차수: A=2, B=3, C=3, D=2
```

## 5.2 그래프의 종류

### 방향 그래프 (Directed Graph, Digraph)

- 간선에 **방향**이 있는 그래프
- 간선을 화살표로 표현
- **진입 차수**: 정점으로 들어오는 간선 수
- **진출 차수**: 정점에서 나가는 간선 수

```
방향 그래프 예시:
    A ---> B
    ^    / |
    |   /  |
    |  /   v
    | /    |
    C <--- D

간선: A→B, B→C, B→D, C→A, D→C
A의 진출차수=1, 진입차수=1
```

### 무방향 그래프 (Undirected Graph)

- 간선에 **방향이 없는** 그래프
- 양방향으로 이동 가능
- 차수 = 연결된 간선의 총 개수

```
무방향 그래프 예시:
    A ---- B
    |      |
    |      |
    C ---- D

A-B, A-C, B-D, C-D로 연결
모든 간선이 양방향
```

### 가중치 그래프 (Weighted Graph)

- 각 간선에 **가중치(비용, 거리 등)**가 할당된 그래프
- 최단 경로, 최소 비용 등을 구할 때 사용

```
가중치 그래프 예시:
    A --5-- B
    |       |
    3       2
    |       |
    C --4-- D

간선 가중치: A-B=5, A-C=3, B-D=2, C-D=4
```

### 특수한 그래프

#### 완전 그래프 (Complete Graph)

- 모든 정점이 다른 모든 정점과 연결된 그래프
- n개 정점의 완전 그래프: n(n-1)/2개의 간선

```
완전 그래프 (n=4):
    A ---- B
    |\    /|
    | \  / |
    |  \/  |
    |  /\  |
    | /  \ |
    |/    \|
    C ---- D

모든 정점이 서로 연결됨
```

#### 순환 그래프 (Cyclic Graph)

- **사이클**이 존재하는 그래프

#### 비순환 그래프 (Acyclic Graph)

- **사이클**이 없는 그래프
- **DAG (Directed Acyclic Graph)**: 방향 비순환 그래프

## 5.3 그래프 표현 방법

### 인접 행렬 (Adjacency Matrix)

2차원 배열을 사용하여 그래프를 표현하는 방법입니다.

#### 특징

- **행렬 A[i][j]**: 정점 i에서 정점 j로의 간선 존재 여부
- 무방향 그래프: **대칭 행렬**
- 가중치 그래프: 가중치 값 저장

```
인접 행렬 예시:
그래프:  A --- B
         |     |
         C --- D

행렬 표현:
     A  B  C  D
A    0  1  1  0
B    1  0  0  1
C    1  0  0  1
D    0  1  1  0

1: 간선 존재, 0: 간선 없음
```

#### 장단점

**장점:**

- 두 정점 간 간선 존재 확인: **O(1)**
- 구현이 간단
- 간선 추가/삭제: **O(1)**

**단점:**

- 공간복잡도: **O(V²)** (정점 수에 비례)
- 희소 그래프에서 메모리 낭비
- 모든 간선 확인: **O(V²)**

### 인접 리스트 (Adjacency List)

각 정점마다 연결된 정점들의 리스트를 유지하는 방법입니다.

#### 특징

- 각 정점에 대해 **연결된 정점들의 리스트** 저장
- 배열 + 연결리스트 또는 벡터 사용

```
인접 리스트 예시:
그래프:  A --- B
         |     |
         C --- D

리스트 표현:
A: [B, C]
B: [A, D]
C: [A, D]
D: [B, C]
```

#### 장단점

**장점:**

- 공간복잡도: **O(V + E)** (정점 + 간선 수)
- 희소 그래프에 효율적
- 한 정점의 모든 인접 정점 확인: **O(차수)**

**단점:**

- 두 정점 간 간선 존재 확인: **O(차수)**
- 구현이 상대적으로 복잡

### 인접 행렬 vs 인접 리스트 비교

| 연산                | 인접 행렬 | 인접 리스트 |
| ------------------- | --------- | ----------- |
| 공간복잡도          | O(V²)     | O(V + E)    |
| 간선 존재 확인      | O(1)      | O(차수)     |
| 간선 추가           | O(1)      | O(1)        |
| 간선 삭제           | O(1)      | O(차수)     |
| 모든 인접 정점 찾기 | O(V)      | O(차수)     |
| 모든 간선 순회      | O(V²)     | O(V + E)    |

**선택 기준:**

- **밀집 그래프** (간선이 많음): 인접 행렬
- **희소 그래프** (간선이 적음): 인접 리스트

## 5.4 그래프 순회 (Graph Traversal)

그래프의 모든 정점을 체계적으로 방문하는 방법입니다.

### 깊이 우선 탐색 (DFS, Depth-First Search)

한 정점에서 시작하여 **가능한 깊이까지** 탐색한 후 되돌아가는 방법입니다.

#### DFS 알고리즘

```
DFS 알고리즘 (재귀):
1. 현재 정점을 방문 표시
2. 현재 정점과 인접한 모든 정점에 대해:
   - 방문하지 않은 정점이면 DFS 재귀 호출
3. 모든 인접 정점 처리 완료 후 종료

DFS 알고리즘 (스택):
1. 시작 정점을 스택에 삽입
2. 스택이 빌 때까지 반복:
   - 스택에서 정점 하나 꺼내기
   - 방문하지 않았으면 방문 표시
   - 해당 정점의 모든 인접 정점을 스택에 삽입
```

#### DFS 특징

- **스택** 또는 **재귀**로 구현
- 시간복잡도: **O(V + E)**
- 공간복잡도: **O(V)** (방문 배열 + 재귀 스택)

```
DFS 예시:
그래프:     1
           /|\
          2 3 4
         /   |
        5    6

시작점 1에서 DFS: 1 → 2 → 5 → 3 → 6 → 4
(인접 리스트 순서에 따라 달라질 수 있음)
```

### 너비 우선 탐색 (BFS, Breadth-First Search)

시작 정점에서 **같은 거리에 있는 정점들을 먼저** 방문하는 방법입니다.

#### BFS 알고리즘

```
BFS 알고리즘:
1. 시작 정점을 큐에 삽입하고 방문 표시
2. 큐가 빌 때까지 반복:
   - 큐에서 정점 하나 꺼내기
   - 해당 정점의 모든 인접 정점에 대해:
     * 방문하지 않았으면 큐에 삽입하고 방문 표시
```

#### BFS 특징

- **큐**로 구현
- 시간복잡도: **O(V + E)**
- 공간복잡도: **O(V)** (방문 배열 + 큐)
- **최단 경로** 보장 (가중치가 없는 그래프에서)

```
BFS 예시:
그래프:     1
           /|\
          2 3 4
         /   |
        5    6

시작점 1에서 BFS: 1 → 2 → 3 → 4 → 5 → 6
레벨별로 방문: [1] → [2,3,4] → [5,6]
```

### DFS vs BFS 비교

| 특성        | DFS                    | BFS                    |
| ----------- | ---------------------- | ---------------------- |
| 자료구조    | 스택 (재귀)            | 큐                     |
| 탐색 방식   | 깊이 우선              | 너비 우선              |
| 메모리 사용 | 적음 (재귀 깊이만큼)   | 많음 (한 레벨 전체)    |
| 최단 경로   | 보장 안함              | 보장 (무가중치)        |
| 응용        | 위상 정렬, 사이클 검출 | 최단 경로, 레벨별 처리 |
