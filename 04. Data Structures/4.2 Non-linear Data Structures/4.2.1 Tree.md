## 1. 트리의 기본 개념

### 정의와 특징

트리는 **계층적 구조**를 가진 비선형 자료구조로, 다음과 같은 핵심 특징을 가진다.

- **사이클이 없는 연결 그래프** : 임의의 두 노드 사이에는 정확히 하나의 경로만 존재
- **루트 노드** : 부모가 없는 유일한 최상위 노드
- **부모-자식 관계** : 각 노드는 최대 하나의 부모와 여러 자식을 가질 수 있음
- **n개의 노드 -> (n-1)개의 간선** : 이는 트리의 수학적 특성

### 핵심 용어 정리

#### 노드 관련 용어

- **루트(Root)** : 최상위 노드, 들어오는 간선이 없음
- **내부 노드(Internal Node)** : 적어도 하나의 자식을 가진 노드
- **리프/단말 노드(Leaf)** : 자식이 없는 노드
- **부모(Parent)**: 직접 상위에 연결된 노드
- **자식(Child)**: 직접 하위에 연결된 노드
- **형제(Sibling)**: 같은 부모를 가진 노드들
- **조상(Ancestor)**: 루트까지의 경로상에 있는 모든 상위 노드들
- **후손(Descendant)**: 특정 노드 아래의 모든 하위 노드들

#### 구조 관련 용어

- **서브트리(Subtree)**: 특정 노드를 루트로 하는 트리의 부분
- **깊이(Depth)**: 루트에서 특정 노드까지의 간선 수
- **높이(Height)**: 특정 노드에서 가장 깊은 리프까지의 간선 수
- **레벨(Level)**: 같은 깊이를 가진 노드들의 집합 (레벨 = 깊이 + 1)
- **차수(Degree)**: 노드가 가진 자식의 개수

### 트리 구조

```
        A (루트, 레벨 1, 깊이 0, 높이 3)
       / \
      B   C (레벨 2, 깊이 1)
     /|   |\
    D E   F G (레벨 3, 깊이 2)
   /
  H (리프, 레벨 4, 깊이 3, 높이 0)

- A의 자식: B, C
- B의 부모: A, 자식: D, E
- D, E, F, G, H: 리프 노드
- A의 서브트리: 전체 트리
- B의 서브트리: B-D-E-H
```

## 2. 이진 트리 (Binary Tree)

### 이진 트리의 정의

각 노드가 **최대 2개의 자식**을 가지는 트리

### 이진 트리의 종류

#### 완전 이진 트리 (Complete Binary Tree)

- 마지막 레벨을 제외한 모든 레벨이 완전히 채워짐
- 마지막 레벨은 왼쪽부터 순서대로 채워짐

```
        1
       / \
      2   3
     / \ /
    4  5 6
```

#### 포화 이진 트리 (Full Binary Tree)

- 모든 레벨이 완전히 채워진 트리
- 높이가 h일 때, 노드의 개수는 2^(h+1)-1

```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

#### 편향 트리 (Skewed Tree)

- 모든 노드가 하나의 자식만 가지는 트리
- 사실상 연결 리스트와 같은 구조

```
 왼쪽 편향 트리:       오른쪽 편향 트리:
        1                  1
       /                    \
      2                      2
     /                        \
    3                          3
```

## 3. 트리 순회 알고리즘

트리의 모든 노드를 체계적으로 방문하는 방법이다.

### 깊이 우선 탐색(DFS) 방식

#### 1. 전위 순회 (Preorder Traversal)

**순서** : 루트 -> 왼쪽 서브트리 -> 오른쪽 서브트리

```
        1
       / \
      2   3
     / \
    4   5

전위 순회 과정:
1. 루트 1 방문
2. 왼쪽 서브트리로 이동
   - 노드 2 방문
   - 2의 왼쪽 서브트리로 이동 → 노드 4 방문
   - 2의 오른쪽 서브트리로 이동 → 노드 5 방문
3. 오른쪽 서브트리로 이동
   - 노드 3 방문

결과: 1 → 2 → 4 → 5 → 3
```

**활용** : 트리 복사, 전위 표현식 계산, 디렉토리 구조 출력 등

#### 2. 중위 순회 (Inorder Traversal)

**순서** : 왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리

```
        1
       / \
      2   3
     / \
    4   5

중위 순회 과정:
1. 왼쪽 서브트리부터 시작
   - 노드 2로 이동
   - 2의 왼쪽 서브트리 → 노드 4 방문
   - 노드 2 방문
   - 2의 오른쪽 서브트리 → 노드 5 방문
2. 루트 1 방문
3. 오른쪽 서브트리 → 노드 3 방문

결과: 4 → 2 → 5 → 1 → 3
```

**활용** : 이진 탐색 트리에서 정렬된 순서로 출력, 중위 표현식 계산

#### 3. 후위 순회 (Postorder Traversal)

**순서**: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트

```
        1
       / \
      2   3
     / \
    4   5

후위 순회 과정:
1. 왼쪽 서브트리부터 시작
   - 노드 2로 이동
   - 2의 왼쪽 서브트리 → 노드 4 방문
   - 2의 오른쪽 서브트리 → 노드 5 방문
   - 노드 2 방문
2. 오른쪽 서브트리 → 노드 3 방문
3. 루트 1 방문

결과: 4 → 5 → 2 → 3 → 1
```

**활용**: 트리 삭제, 후위 표현식 계산, 디스크 용량 계산

### 너비 우선 탐색(BFS) 방식

#### 레벨 순회 (Level Order Traversal)

**순서**: 각 레벨을 왼쪽부터 오른쪽으로 순회

```
        1      ← 레벨 1
       / \
      2   3    ← 레벨 2
     / \
    4   5      ← 레벨 3

과정:
1. 큐에 루트(1) 삽입
2. 큐에서 1을 꺼내어 방문, 1의 자식들(2, 3)을 큐에 삽입
3. 큐에서 2를 꺼내어 방문, 2의 자식들(4, 5)을 큐에 삽입
4. 큐에서 3을 꺼내어 방문
5. 큐에서 4를 꺼내어 방문
6. 큐에서 5를 꺼내어 방문

결과: 1 → 2 → 3 → 4 → 5
```

**활용**: 최단 경로 찾기, 레벨별 노드 개수 계산, 트리의 너비 계산
