## 1. BST의 기본 개념

### 정의

**이진 탐색 트리(Binary Search Tree)**는 이진 트리에 탐색 조건을 추가한 자료구조이다.

### BST의 핵심 조건

1. 왼쪽 서브트리의 모든 값 < 현재 노드 값
2. 오른쪽 서브트리의 모든 값 > 현재 노드 값
3. 모든 서브트리도 BST 조건을 만족

### 구조

        50
       /  \
      30   70
     / \   / \
    20 40 60 80

- 50 기준: 왼쪽(20,30,40) < 50 < 오른쪽(60,70,80)
- 30 기준: 왼쪽(20) < 30 < 오른쪽(40)
- 70 기준: 왼쪽(60) < 70 < 오른쪽(80)

## 2. 주요 연산

### 탐색 (Search)

#### 과정

1. 루트에서 시작
2. 찾는 값 < 현재 노드 → 왼쪽으로
3. 찾는 값 > 현재 노드 → 오른쪽으로
4. 값을 찾거나 NULL에 도달할 때까지 반복

```
40 탐색 start
50 (40 < 50) → 왼쪽
30 (40 > 30) → 오른쪽
40 → 찾음!

경로: 50 → 30 → 40
```

### 삽입 (Insert)

#### 과정

1. 탐색과 동일한 방식으로 위치 찾기
2. NULL 위치에 새 노드 삽입

```
35 삽입
50 → 30 → 40 → NULL(왼쪽)

결과
        50
       /  \
      30   70
     / \   / \
    20 40 60 80
      /
     35 ← 새로 삽입
```

### 삭제 (Delete)

#### 3가지 경우

**케이스 1: 리프 노드**

```
20 삭제 → 그냥 제거
```

**케이스 2: 자식 1개**

```
자식으로 대체
```

**케이스 3: 자식 2개**

```
중위 순회 후계자 또는 전임자로 대체

50 삭제 시:
- 후계자: 오른쪽 서브트리의 최솟값 (60)
- 전임자: 왼쪽 서브트리의 최댓값 (40)
```

## 3. 순회와 특성

### 중위 순회의 특별한 성질

BST를 **중위 순회**하면 정렬된 순서로 출력된다.

```
        50
       /  \
      30   70
     / \   / \
    20 40 60 80

중위 순회: 20 → 30 → 40 → 50 → 60 → 70 → 80
결과: 오름차순 정렬
```

### BST 검증

- **방법 1**: 중위 순회 결과가 오름차순인지 확인
- **방법 2**: 각 노드가 허용된 범위 내에 있는지 확인

## 4. 성능

### 시간 복잡도

- 평균 : O(log n)
- 최악 : O(n)

#### 균형 잡힌 BST (이상적)

```
        50
       /  \
      25   75
     / \   / \
    12 37 62 87

- 높이: O(log n)
- 모든 연산이 효율적
```

#### 편향된 BST (최악)

```
    10
     \
      20
       \
        30
         \
          40

- 높이: O(n)
- 연결 리스트와 동일한 성능
```

## 5. BST의 장단점

### 장점

- **정렬된 데이터 출력**: 중위 순회로 정렬된 결과
- **효율적인 탐색**: 평균 O(log n)
- **동적 크기**: 삽입/삭제 시 크기 조절 가능
- **범위 검색**: 특정 구간의 값들 쉽게 찾기

### 단점

- **편향 가능성**: 최악의 경우 O(n) 성능
- **메모리 오버헤드**: 포인터 저장 공간 필요
- **캐시 비효율**: 메모리 접근 패턴이 불규칙

## 6. 균형 트리

### `AVL 트리 (Adelson-Velsky and Landis Tree)`

**조건**: 모든 노드에서 좌우 서브트리의 높이 차이가 **최대 1**

```
        10 (BF=0)
       /   \
    5(BF=1) 15(BF=-1)
    /         \
  3(BF=0)     20(BF=0)

BF(Balance Factor) = 왼쪽 높이 - 오른쪽 높이
AVL 조건: -1 ≤ BF ≤ 1
```

#### 회전 연산 (Rotation)

불균형 발생 시 트리를 회전시켜 균형 복구

#### 1. 단순 회전 (Single Rotation)

**LL 회전 (Left-Left Case)**

```
불균형:            회전 후:
    C                B
   /                / \
  B        →       A   C
 /
A

BF(C) = +2, BF(B) = +1인 경우
```

**RR 회전 (Right-Right Case)**

```
불균형:           회전 후:
A                   B
 \                 / \
  B        →      A   C
   \
    C

BF(A) = -2, BF(B) = -1인 경우
```

#### 2. 이중 회전 (Double Rotation)

**LR 회전 (Left-Right Case)**

```
불균형:      1단계:       2단계:
    C          C            B
   /          /            / \
  A    →     B      →     A   C
   \        /
    B      A

BF(C) = +2, BF(A) = -1인 경우
```

**RL 회전 (Right-Left Case)**

```
불균형:      1단계:       2단계:
A             A            B
 \             \          / \
  C      →      B   →    A   C
 /               \
B                 C

BF(A) = -2, BF(C) = +1인 경우
```

#### AVL 트리 특징

- **보장된 성능**: 항상 O(log n)
- **엄격한 균형**: 최대 높이 ≈ 1.44 × log₂(n)
- **빈번한 회전**: 삽입/삭제 시 회전 연산 많음

### `Red-Black 트리`

#### 기본 개념

**색깔 규칙**으로 균형을 유지하는 이진 탐색 트리

#### Red-Black 트리 조건

1. 모든 노드는 `빨간색` 또는 `검은색`
2. 루트 노드는 검은색
3. 모든 리프(NIL) 노드는 검은색
4. 빨간색 노드의 자식은 모두 검은색 (**연속된 빨간색 금지**)
5. 임의의 노드에서 리프까지의 모든 경로는 같은 수의 검은색 노드 포함

```
Red-Black 트리 예시:
       B(10)
      /     \
    R(5)   B(15)
    /  \      \
  B(3) B(7)  R(20)
                \
               B(25)

B = Black, R = Red
```

#### 색깔 변경과 회전

삽입/삭제 시 색깔 변경과 회전으로 조건 유지

#### 삽입 과정

1. 새 노드를 빨간색으로 삽입
2. Red-Black 조건 위반 시 수정
3. 색깔 변경 또는 회전 수행

### Red-Black vs AVL

| **특성**  | **AVL**            | **Red-Black**    |
| --------- | ------------------ | ---------------- |
| 균형 조건 | 엄격 (높이 차 ≤ 1) | 느슨 (색깔 규칙) |
| 최대 높이 | 1.44 log n         | 2 log n          |
| 삽입/삭제 | 느림 (많은 회전)   | 빠름 (적은 회전) |
| 탐색      | 빠름               | 상대적으로 느림  |
| 사용      | 탐색 위주          | 삽입/삭제 위주   |

### `B-Tree`

#### 기본 개념

**다진 탐색 트리**로, 한 노드에 여러 키와 자식을 저장

#### m차 B-Tree 조건

1. 모든 리프는 같은 레벨
2. 루트를 제외한 모든 노드는 최소 ⌈m/2⌉-1개의 키
3. 모든 노드는 최대 m-1개의 키
4. k개의 키를 가진 노드는 k+1개의 자식
5. 노드 내 키들은 정렬됨

```
5차 B-Tree 예시:
        [30, 60]
     /      |     \
[10,20]  [40,50] [70,80,90]

특징:
- 최대 4개 키, 최대 5개 자식
- 최소 2개 키 (루트 제외)
- 높이가 낮음
```

#### B-Tree 연산

```
5차 B-Tree 예시:
        [30, 60]
     /      |     \
[10,20]  [40,50] [70,80,90]
```

**탐색**

```
40 탐색
[30, 60] → 30 < 40 < 60 → 가운데 자식
[40, 50] → 40 찾음!
```

**삽입**

- 리프에 삽입
- 노드 오버플로우 시 분할 (Split)

```
35 삽입:
[40, 50]에 35 삽입 → [35, 40, 50]

분할:
     [40]      ← 중간값 승격
    /    \
  [35]   [50]  ← 좌우로 분할
```

**삭제**

- 리프에서 삭제: 그냥 제거
- 내부 노드에서 삭제: 후계자/전임자로 대체
- 언더플로우 시 병합 (Merge) 또는 재배치

#### B-Tree 장점

- **낮은 높이**: 디스크 I/O 최소화
- **높은 분기율**: 한 번에 많은 키 처리
- **캐시 효율성**: 연속된 메모리 접근

### `B+Tree`

#### B-Tree 구조

```
       [30, 60]          ← 내부 노드에도 데이터
      /    |    \
[10,20]  [40,50]  [70,80] ← 리프에도 데이터
```

#### B+Tree 구조

```
       [30, 60]          ← 내부 노드는 인덱스만
      /    |    \
[10,20] [30,40,50] [60,70,80] ← 리프에만 실제 데이터
   ↔       ↔         ↔         ← 리프들이 연결됨
```

#### B+Tree 특징

1. **내부 노드**: 인덱스 역할만 (실제 데이터 없음)
2. **리프 노드**: 모든 실제 데이터 저장
3. **리프 연결**: 모든 리프가 연결 리스트로 연결
4. **중복 키**: 내부 노드의 키가 리프에도 존재

#### B+Tree 장점

- **범위 검색 최적화**: 리프만 순차 접근하면 됨
- **더 많은 인덱스**: 내부 노드에 더 많은 키 저장 가능
- **일관된 성능**: 모든 데이터 접근이 리프까지 가야 함
- **순차 접근**: 연결된 리프로 빠른 순차 검색

## 7. BST 선택 가이드

### BST를 사용하기 좋은 경우

- 데이터가 정렬된 순서로 자주 필요
- 범위 검색이 빈번함
- 삽입/삭제와 탐색이 모두 중요함
- 메모리 사용량이 크게 제한되지 않음

### 다른 자료구조를 고려해야 하는 경우

- **정렬된 데이터 삽입** → AVL/Red-Black 트리
- **최댓값/최솟값 자주 접근** → 힙
- **빠른 탐색만 필요** → 해시 테이블
- **고정 크기 데이터** → 정렬된 배열
