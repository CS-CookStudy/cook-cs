## 1. 힙의 기본 개념

### 정의

**힙(Heap)**은 완전 이진 트리 기반의 자료구조로, 특정한 순서 조건을 만족한다.

### 힙의 두 가지 조건

1. 구조적 조건 : 완전 이진 트리
2. 순서 조건 : 힙 속성

## 2. 힙의 종류

### 최대 힙 (Max Heap)

**조건**: 부모 노드 ≥ 자식 노드

```
최대 힙 예시:
       90
      /  \
     80   70
    / \   / \
   60 50 40 30
  /
 20

특징:
- 루트에 최댓값 저장
- 모든 부모 ≥ 자식
```

### 최소 힙 (Min Heap)

**조건**: 부모 노드 ≤ 자식 노드

```
최소 힙 예시:
       10
      /  \
     20   30
    / \   / \
   40 50 60 70
  /
 80

특징:
- 루트에 최솟값 저장
- 모든 부모 ≤ 자식
```

## 3. 배열을 이용한 힙 구현

### 배열 인덱스 관계

완전 이진 트리의 특성상 배열로 효율적 구현 가능

### 인덱스 0부터 시작

- 부모 인덱스: (i-1)/2
- 왼쪽 자식: 2\*i+1
- 오른쪽 자식: 2\*i+2

### 인덱스 1부터 시작

- 부모 인덱스: i/2
- 왼쪽 자식: 2\*i
- 오른쪽 자식: 2\*i+1

### 배열 표현 예시

```
힙:        90
          /  \
         80   70
        / \   / \
       60 50 40 30

배열: [90, 80, 70, 60, 50, 40, 30]
인덱스: 0   1   2   3   4   5   6

관계:
- 90(0)의 자식: 80(1), 70(2)
- 80(1)의 자식: 60(3), 50(4)
- 70(2)의 자식: 40(5), 30(6)
```

## 4. 힙의 주요 연산

### 삽입 (Insert)

**과정**

1. 배열의 마지막에 새 원소 추가
2. 부모와 비교하며 힙 조건 만족할 때까지 위로 이동 (Heapify Up)

```
최대 힙에 85 삽입:

1단계: 마지막에 85 추가
       90
      /  \
     80   70
    / \   / \
   60 50 40 30
  /
 85

배열: [90, 80, 70, 60, 50, 40, 30, 85]

2단계: 85와 부모 60 비교 (85 > 60) → 교환
       90
      /  \
     80   70
    / \   / \
   85 50 40 30
  /
 60

3단계: 85와 부모 80 비교 (85 > 80) → 교환
       90
      /  \
     85   70
    / \   / \
   80 50 40 30
  /
 60

4단계: 85와 부모 90 비교 (85 < 90) → 완료
```

### 삭제 (Extract)

일반적으로 **루트 노드 삭제** (최댓값 / 최솟값 제거)
**과정**

1. 루트 노드 제거
2. 마지막 노드를 루트로 이동
3. 자식들과 비교하며 힙 조건 만족할 때까지 아래로 이동 (Heapify Down)

```
최대 힙에서 최댓값 90 삭제:

1단계: 루트 90 제거, 마지막 원소 60을 루트로
       60
      /  \
     85   70
    / \   / \
   80 50 40 30

2단계: 60과 자식들 비교 (85 > 60) → 더 큰 자식과 교환
       85
      /  \
     60   70
    / \   / \
   80 50 40 30

3단계: 60과 자식들 비교 (80 > 60) → 더 큰 자식과 교환
       85
      /  \
     80   70
    / \   / \
   60 50 40 30

4단계: 60이 리프에 도달 → 완료
```

### Heapify 연산 상세

#### Heapify Up (상향 이동)

```
조건: 자식 > 부모 (최대 힙)
과정:
while (현재 노드 > 부모 노드):
    부모와 교환
    부모 위치로 이동
```

#### Heapify Down (하향 이동)

```
조건: 부모 < 자식 (최대 힙)
과정:
while (자식이 존재):
    더 큰 자식 선택
    if (현재 노드 < 더 큰 자식):
        교환하고 해당 자식 위치로 이동
    else:
        종료
```

## 5. 힙 정렬 (Heap Sort)

### 과정

1. 주어진 배열을 최대 힙으로 구성
2. 루트(최댓값)를 마지막 원소와 교환
3. 힙 크기를 1 감소시키고 다시 힙 조건 반복
4. 모든 원소가 정렬될 때까지 반복

```
힙 정렬 과정:

초기 배열: [4, 10, 3, 5, 1]

1단계: 최대 힙 구성
       10
      /  \
     5    3
    / \
   4   1
배열: [10, 5, 3, 4, 1]

2단계: 10과 1 교환, 힙 크기 감소
       1
      / \
     5   3
    /
   4   |10|
배열: [1, 5, 3, 4, |10|]
Heapify Down으로 힙 복구

3단계: 반복...
최종: [1, 3, 4, 5, 10] (오름차순 정렬)
```

### 힙 정렬 특징

- **시간 복잡도**: O(n log n) - 모든 경우
- **공간 복잡도**: O(1) - 제자리 정렬
- **불안정 정렬**: 같은 값의 순서 바뀔 수 있음
- **비교 기반 정렬**: 원소 간 비교로 정렬

## 6. 우선순위 큐 (Priority Queue)

### 개념

**우선순위가 높은 원소를 먼저 처리**하는 자료구조

### 힙으로 구현하는 이유

- 효율적인 삽입: O(log n)
- 효율적인 최고 우선순위 접근: O(1)
- 효율적인 삭제: O(log n)

### 우선순위 큐 연산

```
최대 힙 기반 우선순위 큐:

삽입: enqueue(priority, data)
삭제: dequeue() → 최고 우선순위 원소 반환
조회: peek() → 최고 우선순위 원소 확인

예시:
enqueue(5, "작업A")
enqueue(3, "작업B")
enqueue(8, "작업C")
enqueue(1, "작업D")

힙 상태:
       8(작업C)
      /       \
   5(작업A)   3(작업B)
   /
1(작업D)

dequeue() → "작업C" (우선순위 8)
```

## 7. 힙이 필요한 경우

1. **최댓값/최솟값**에 자주 접근할 경우
2. **우선순위** 기반 처리 필요한 경우
3. **동적으로 원소 추가/제거**가 필요한 경우
4. **메모리 효율성** 중요한 경우
