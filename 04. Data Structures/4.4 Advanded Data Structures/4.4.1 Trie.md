## 1. 트라이(Trie)의 기본 개념

### 정의

**트라이(Trie)** 는 문자열을 효율적으로 저장하고 검색하기 위한 트리 자료구조이다.

- **Prefix Tree** 또는 **Digital Tree**라고도 불림
- 각 노드가 문자를 나타내며, 루트에서 리프까지의 경로가 하나의 문자열을 형성

### 이름의 유래

- **"retrieval"**에서 가운데 부분을 따온 것
- 정보 **검색(retrieval)**에 특화된 자료구조

### 기본 구조

```
단어들: "cat", "car", "card", "care", "careful"

트라이 구조:
         root
          |
          c
          |
          a
         / \
        t   r
       /   / \
      *   d   e
         /   / \
        *   *   f
               /
              u
              |
              l
              |
              *

* = 단어의 끝을 나타내는 표시
```

## 2. 트라이의 구조와 특징

### 노드 구조

각 트라이 노드는 다음 정보를 포함한다.

1. **자식 노드들** : 다음에 올 수 있는 문자들
2. **단어 끝 표시** : 현재 위치에서 완전한 단어가 끝나는지 표시
3. **추가 정보** : 필요에 따라 단어의 빈도, 의미 등

```
노드 구조 예시:
class TrieNode:
    children = {}     # 자식 노드들 (문자 → 노드)
    is_end_word = False  # 단어 끝 여부
    count = 0         # 해당 단어의 빈도 (선택적)
```

### 트라이의 핵심 특징

1. 공통 접두사 공유

```
"apple", "app", "application" 저장 시:

    root
     |
     a
     |
     p
     |
     p (*) ← "app" 끝
     |
     l
    / \
   e   i
   |   |
   *   c
       |
       a
       |
       t
       |
       i
       |
       o
       |
       n
       |
       *

"app"가 공통 접두사로 공유됨
```

2. 경로 = 문자열

- 루트에서 특정 노드까지의 경로가 하나의 문자열을 나타냄
- 문자열의 각 문자가 트리의 한 레벨에 대응

3. 효율적인 접두사 검색

- 특정 접두사로 시작하는 모든 단어를 쉽게 찾을 수 있음

## 3. 트라이의 주요 연산

### 삽입(Insert) 연산

#### 과정

1. 루트에서 시작
2. 문자열의 각 문자에 대해:
   - 해당 문자의 자식 노드가 있으면 이동
   - 없으면 새 노드 생성 후 이동
3. 마지막 노드에 단어 끝 표시

```
"cat" 삽입 과정:

1단계: 빈 트라이
    root

2단계: 'c' 삽입
    root
     |
     c

3단계: 'a' 삽입
    root
     |
     c
     |
     a

4단계: 't' 삽입 및 단어 끝 표시
    root
     |
     c
     |
     a
     |
     t (*)

"car" 추가 삽입:
    root
     |
     c
     |
     a
    / \
   t   r
  (*)  (*)
```

### 탐색(Search) 연산

#### 과정

1. 루트에서 시작
2. 문자열의 각 문자에 대해:
   - 해당 문자의 자식 노드로 이동
   - 자식 노드가 없으면 탐색 실패
3. 마지막 노드의 단어 끝 표시 확인

```
"car" 탐색:
root → c → a → r → 단어 끝 표시 확인 → 성공

"ca" 탐색:
root → c → a → 단어 끝 표시 없음 → 실패 (접두사는 존재)

"cap" 탐색:
root → c → a → p(없음) → 실패
```

### 삭제(Delete) 연산

#### 과정

1. 먼저 단어가 존재하는지 확인
2. 단어 끝 표시 제거
3. 필요시 불필요한 노드들 제거 (다른 단어에 영향 없을 때만)

```
트라이 상태: "cat", "car", "card"가 저장됨
    root
     |
     c
     |
     a
    / \
   t   r (*)
  (*)  |
       d
       |
       *

"car" 삭제:
1. 'r' 노드의 단어 끝 표시만 제거
2. 'r' 노드는 "card"에서 사용하므로 유지

"cat" 삭제:
1. 't' 노드의 단어 끝 표시 제거
2. 't' 노드는 다른 단어에서 사용되지 않으므로 제거 가능
```

### 접두사 검색 (Prefix Search)

#### 과정

1. 접두사까지 이동
2. 해당 노드부터 DFS로 모든 단어 수집

```
접두사 "ca"로 시작하는 모든 단어 찾기:

    root
     |
     c
     |
     a ← 여기서 시작
    / \
   t   r
  (*)  |\
      d e
      | |
      * *

결과: "cat", "car", "card", "care"
```

## 4. 트라이의 시간 및 공간 복잡도

### 시간 복잡도

| 연산        | 시간 복잡도 | 설명                                                 |
| ----------- | ----------- | ---------------------------------------------------- |
| 삽입        | O(m)        | m = 문자열 길이                                      |
| 탐색        | O(m)        | m = 문자열 길이                                      |
| 삭제        | O(m)        | m = 문자열 길이                                      |
| 접두사 검색 | O(p + n×k)  | p = 접두사 길이, n = 결과 개수, k = 평균 문자열 길이 |

#### **핵심**: 문자열의 개수와 무관하게 문자열 길이에만 비례!

### 공간 복잡도

#### 최악의 경우: O(ALPHABET_SIZE × N × M)

- ALPHABET_SIZE: 알파벳 크기 (영어 26개)
- N: 저장된 문자열 개수
- M: 평균 문자열 길이

#### 최선의 경우: O(총 문자 수)

- 공통 접두사가 많을 때 공간 절약

```
공간 효율성 예시:

일반 저장: ["apple", "application", "apply"]
- 총 문자 수: 5 + 11 + 5 = 21

트라이 저장:
    root
     |
     a-p-p-l (공통 부분)
          |\
          e y
          | |
          * *
          |
          i-c-a-t-i-o-n
                    |
                    *

실제 노드 수: 훨씬 적음 (공통 접두사 공유)
```

## 5. 트라이의 최적화

### 압축 트라이 (Compresses Trie, Radix Tree)

-> 연속된 단일 경로를 하나의 노드로 압축

```
기본 트라이:
    root
     |
     a
     |
     p
     |
     p
     |
     l
     |
     e
     |
     *

압축 트라이:
    root
     |
   "apple"
     |
     *

압축된 노드는 문자열을 저장
```

### 메모리 최적화 기법

`1. 배열 vs 해시맵`

```
// 배열 사용 (영어만)
children = new TrieNode[26]  // 고정 크기

// 해시맵 사용 (다국어 지원)
children = HashMap<Character, TrieNode>  // 동적 크기
```

`2. 비트 최적화`

- 소문자 영어만 사용 시 비트 연산으로 인덱스 계산
- char - 'a'로 0~25 인덱스 생성

`3. 지연 할당`

- 자식 노드를 실제 필요할 때만 생성

## 6. 트라이의 활용 사례

### 자동 완성 (Auto-completion)

#### **원리** : 사용자 입력에 대한 접두사 검색

```
검색창에 "pro" 입력 시:

트라이에서 "pro" 접두사 검색:
    root
     |
     p
     |
     r
     |
     o ← 여기서 시작
    /|\
   g d u
   | | |
   ... 각각 단어들

결과: "program", "project", "product", "proud" 등
```

### 맞춤법 검사 (Spell Checker)

#### **방법 1**: 정확한 단어 존재 확인

```
사용자 입력: "recieve"
트라이 탐색: 실패
→ 오타 가능성 제시
```

#### **방법 2**: 유사한 단어 제안

```
편집 거리 1 이내의 단어들:
- "receive" (철자 교정)
- "deceive" (비슷한 패턴)
```
