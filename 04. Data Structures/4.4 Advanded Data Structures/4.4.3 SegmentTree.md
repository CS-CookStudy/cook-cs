## 1. 세그먼트 트리의 기본 개념

### 정의

**세그먼트 트리(Segment Tree)** 는 배열의 **구간 쿼리(Range Query)** 와 원소 업데이트를 효율적으로 처리하는 트리 자료구조이다.

### 문제 예시 (구간 합)

```
배열: [1, 3, 5, 7, 9, 11]

쿼리들:
- sum(1, 3) = 3 + 5 + 7 = 15
- sum(0, 2) = 1 + 3 + 5 = 9
- update(2, 10): 인덱스 2를 10으로 변경
- sum(1, 3) = 3 + 10 + 7 = 20

일반적인 방법: O(n) 시간
세그먼트 트리: O(log n) 시간
```

### 핵심 아이디어

- **분할 정복**: 배열을 재귀적으로 반으로 나누어 트리 구성
- **구간 정보 저장**: 각 노드에 해당 구간의 집계 정보 저장
- **부분 결과 조합**: 자식 노드들의 결과를 합쳐서 부모 노드 계산

## 2. 세그먼트 트리 구조

### 트리 구성 원리

```
배열: [1, 3, 5, 7, 9, 11]  (인덱스 0~5)

세그먼트 트리 (구간 합):
                36 [0,5]
               /        \
          9 [0,2]        27 [3,5]
         /       \       /       \
    4 [0,1]   5 [2,2]  16 [3,4]  11 [5,5]
   /      \            /       \
1 [0,0] 3 [1,1]    7 [3,3]  9 [4,4]

각 노드 표기: 값 [구간시작, 구간끝]
```

### 노드의 의미

- **리프 노드**: 원본 배열의 단일 원소
- **내부 노드**: 특정 구간의 집계 값 (합, 최댓값, 최솟값 등)
- **루트 노드**: 전체 배열의 집계 값

### 배열 기반 구현

완전 이진 트리 특성을 활용한 배열 구현

```
tree 배열 인덱스 관계:
- 루트: 인덱스 1
- 노드 i의 왼쪽 자식: 2*i
- 노드 i의 오른쪽 자식: 2*i+1
- 노드 i의 부모: i/2

배열 크기: 4*n (여유있게)
```

## 3. 세그먼트 트리 주요 연산

### 구축(Build) 연산

#### 과정

1. 리프 노드부터 시작하여 상향식으로 구축
2. 각 내부 노드는 자식들의 값을 결합

```
build(node, start, end, arr):
    if start == end:
        tree[node] = arr[start]  // 리프 노드
    else:
        mid = (start + end) / 2
        build(2*node, start, mid, arr)      // 왼쪽 자식
        build(2*node+1, mid+1, end, arr)   // 오른쪽 자식
        tree[node] = tree[2*node] + tree[2*node+1]  // 합치기
```

#### 시각화

```
배열: [1, 3, 5, 7]

1단계: 리프 노드 설정
tree[4] = 1, tree[5] = 3, tree[6] = 5, tree[7] = 7

2단계: 레벨 2 노드 계산
tree[2] = tree[4] + tree[5] = 1 + 3 = 4
tree[3] = tree[6] + tree[7] = 5 + 7 = 12

3단계: 루트 노드 계산
tree[1] = tree[2] + tree[3] = 4 + 12 = 16

최종 트리:
      16
     /  \
    4    12
   / \   / \
  1   3 5   7
```

### 구간 쿼리(Range Query) 연산

#### 과정

1. 현재 노드의 구간과 쿼리 구간을 비교
2. 완전히 포함/벗어남/부분 겹침에 따라 처리

```
query(node, start, end, l, r):
    if r < start or end < l:
        return 0  // 구간이 벗어남

    if l <= start and end <= r:
        return tree[node]  // 완전히 포함됨

    // 부분적으로 겹침
    mid = (start + end) / 2
    left_sum = query(2*node, start, mid, l, r)
    right_sum = query(2*node+1, mid+1, end, l, r)
    return left_sum + right_sum
```

#### 예시

```
배열: [1, 3, 5, 7] (0-indexed)
쿼리: sum(1, 2) = 3 + 5 = 8

트리 탐색:
1. 루트 [0,3]: 부분 겹침 → 자식들 탐색
2. 왼쪽 [0,1]: 부분 겹침 → 자식들 탐색
   - [0,0]: 벗어남 → 0 반환
   - [1,1]: 완전 포함 → 3 반환
3. 오른쪽 [2,3]: 부분 겹침 → 자식들 탐색
   - [2,2]: 완전 포함 → 5 반환
   - [3,3]: 벗어남 → 0 반환

결과: 0 + 3 + 5 + 0 = 8
```

### 업데이트(Update) 연산

#### 과정

1. 해당 인덱스까지 내려가며 경로상 모든 노드 업데이트
2. 리프에서 루트까지 값 재계산

```
update(node, start, end, idx, val):
    if start == end:
        tree[node] = val  // 리프 노드 업데이트
    else:
        mid = (start + end) / 2
        if idx <= mid:
            update(2*node, start, mid, idx, val)
        else:
            update(2*node+1, mid+1, end, idx, val)

        tree[node] = tree[2*node] + tree[2*node+1]  // 재계산
```

### 예시

- arr[2] = 10으로 변경

```
기존: [1, 3, 5, 7]
변경: [1, 3, 10, 7]

업데이트 경로: 루트 → 오른쪽 → 왼쪽 → 리프

1. tree[6] = 10 (리프 업데이트)
2. tree[3] = tree[6] + tree[7] = 10 + 7 = 17
3. tree[1] = tree[2] + tree[3] = 4 + 17 = 21

최종 트리:
      21
     /  \
    4    17
   / \   / \
  1   3 10  7
```
