# 선형 자료 구조

# 면접 단골 질문 & 답안

## Q1. 배열과 연결리스트의 차이점을 설명하고, 각각 언제 사용해야 하나요?

**A:**
배열은 메모리에 연속적으로 저장되어 인덱스로 O(1) 접근이 가능하지만, 중간 삽입/삭제 시 O(n)이 걸립니다. 연결리스트는 노드들이 포인터로 연결되어 있어 순차 접근만 가능하지만(O(n)), 위치를 알고 있다면 삽입/삭제가 O(1)입니다.

**사용 시기:**

- **배열**: 데이터에 자주 접근하고 크기가 고정적일 때
- **연결리스트**: 데이터 삽입/삭제가 빈번하고 크기가 가변적일 때

## Q2. 동적 배열이 크기를 확장할 때의 시간 복잡도는?

**A:**
크기 확장 시에는 O(n) 시간이 걸립니다. 새로운 메모리를 할당하고 기존 데이터를 모두 복사해야 하기 때문입니다. 하지만 확장 빈도가 낮기 때문에 평균적으로(amortized) O(1)의 삽입 시간을 가집니다. ArrayList는 보통 1.5배로 확장합니다.

## Q3. 원형 큐를 사용하는 이유는?

**A:**
선형 큐에서는 dequeue 연산 후 front가 이동하면서 앞쪽 공간이 낭비되는 문제가 있습니다. 원형 큐는 배열의 끝과 시작을 연결하여 공간을 효율적으로 재사용할 수 있습니다. 모듈로 연산 `(index + 1) % size`을 사용하여 인덱스를 순환시킵니다.

## Q4. 스택과 큐의 실제 사용 사례를 설명해주세요.

**A:**
**스택:**

- 함수 호출 관리 (Call Stack)
- 웹 브라우저 뒤로가기 기능
- 수식 계산 및 괄호 매칭
- Undo/Redo 기능
- DFS 알고리즘

**큐:**

- 프로세스 스케줄링
- BFS 알고리즘
- 프린터 스풀링
- 네트워크 패킷 버퍼링
- 캐시 구현 (LRU)

## Q5. 배열의 캐시 효율성이 좋은 이유는?

**A:**
배열은 메모리에 연속적으로 저장되어 있어 공간 지역성(spatial locality)이 좋습니다. CPU가 한 번에 여러 요소를 캐시로 가져올 수 있어, 인접한 데이터에 접근할 때 캐시 히트율이 높아집니다. 반면 연결리스트는 노드들이 메모리에 흩어져 있어 캐시 미스가 빈번하게 발생합니다.

## Q6. 이중 연결리스트의 장단점은?

**A:**
**장점:**

- 양방향 순회 가능
- 특정 노드 삭제 시 이전 노드 탐색 불필요
- 역순 탐색 가능

**단점:**

- 추가 메모리 필요 (prev 포인터)
- 구현 복잡도 증가
- 포인터 관리 부담 증가

## Q7. 우선순위 큐를 배열로 구현할 때와 힙으로 구현할 때의 차이는?

**A:**
**배열 구현:**

- 삽입: O(1) - 맨 뒤에 추가
- 삭제: O(n) - 최우선순위 요소 탐색 필요

**힙 구현:**

- 삽입: O(log n) - 힙 성질 유지
- 삭제: O(log n) - 루트 제거 후 재정렬

대용량 데이터에서는 힙 구현이 더 효율적입니다. Java의 PriorityQueue는 힙으로 구현되어 있습니다.

## Q8. ArrayList와 LinkedList의 성능 차이는?

**A:**

```java
// ArrayList
- get(index): O(1)
- add(element): O(1) amortized
- add(index, element): O(n)
- remove(index): O(n)

// LinkedList
- get(index): O(n)
- add(element): O(1)
- add(index, element): O(n) - 인덱스 탐색 때문
- remove(index): O(n) - 인덱스 탐색 때문
```

빈번한 인덱스 접근이 필요하면 ArrayList, 빈번한 삽입/삭제가 필요하면 LinkedList를 사용합니다.

## Q9. Java의 Stack 클래스 대신 Deque를 권장하는 이유는?

**A:**
Java의 Stack 클래스는 Vector를 상속받아 동기화 오버헤드가 있고, LIFO가 아닌 다른 방법으로도 접근할 수 있어 진정한 스택이 아닙니다. ArrayDeque는 더 빠르고 메모리 효율적이며, 스택과 큐 기능을 모두 제공합니다.

```java
// 권장하지 않음
Stack<Integer> stack = new Stack<>();

// 권장
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
int top = stack.pop();
```

## Q10. 원형 연결 리스트에서 무한 루프를 방지하는 방법은?

**A:**
원형 연결 리스트에서는 NULL 포인터가 없으므로 종료 조건을 명확히 설정해야 합니다:

```java
// ❌ 무한 루프 위험
public void printAll() {
    ListNode current = head;
    while (current != null) { // null이 없으므로 무한 루프!
        System.out.println(current.data);
        current = current.next;
    }
}

// ✅ 올바른 구현
public void printAll() {
    if (head == null) return;

    ListNode current = head;
    do {
        System.out.println(current.data);
        current = current.next;
    } while (current != head); // head로 돌아올 때까지
}
```

## Q11. 언제 단일/이중/원형 연결 리스트를 각각 사용해야 하나요?

**A:**

**단일 연결 리스트:**

- 메모리 사용량을 최소화하고 싶을 때
- 스택이나 간단한 큐 구현
- 단순한 순차 처리만 필요할 때

**이중 연결 리스트:**

- 양방향 순회가 자주 필요할 때 (브라우저 히스토리)
- 임의 위치에서의 삭제가 빈번할 때
- 덱(Deque) 기능이 필요할 때

**원형 연결 리스트:**

- 라운드 로빈 알고리즘 구현
- 게임에서 플레이어 턴 관리
- 순환적인 처리가 필요할 때

## Q12. 메모리 누수를 방지하는 방법은?

**A:**
연결 리스트에서 노드 삭제 시 참조를 명시적으로 해제해야 합니다:

```java
// 이중 연결 리스트 노드 삭제 시
public void deleteNode(DoublyListNode node) {
    // 연결 해제
    if (node.prev != null) node.prev.next = node.next;
    if (node.next != null) node.next.prev = node.prev;

    // 메모리 누수 방지를 위한 참조 해제
    node.prev = null;
    node.next = null;
}
```

특히 원형 연결 리스트에서는 순환 참조로 인한 메모리 누수에 주의해야 합니다.

# 시간 복잡도 요약표

| 자료구조            | 접근 | 탐색 | 삽입     | 삭제     | 공간복잡도 |
| ------------------- | ---- | ---- | -------- | -------- | ---------- |
| **배열**            | O(1) | O(n) | O(n)     | O(n)     | O(n)       |
| **동적배열**        | O(1) | O(n) | O(1)\*   | O(n)     | O(n)       |
| **단일 연결리스트** | O(n) | O(n) | O(1)\*\* | O(1)\*\* | O(n)       |
| **이중 연결리스트** | O(n) | O(n) | O(1)\*\* | O(1)\*\* | O(n)       |
| **스택**            | O(n) | O(n) | O(1)     | O(1)     | O(n)       |
| **큐**              | O(n) | O(n) | O(1)     | O(1)     | O(n)       |

\* Amortized (평균적으로)  
\*\* 위치를 알고 있을 때

---
