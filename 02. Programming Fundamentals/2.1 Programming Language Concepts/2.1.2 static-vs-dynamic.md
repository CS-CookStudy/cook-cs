# 정적 타입 vs 동적 타입

변수의 **타입이 언제 결정**되는지에 따른 프로그래밍 언어의 분류

### 🔑 핵심 차이점: **타입 결정 시점**

---

## 🔒 정적 타입 (Static Typing)

### 정의

변수의 타입이 **컴파일 시점(소스 코드 작성 시)**에 결정되며, 타입을 **명시적으로 선언**해야 하는 방식

### 특징

```c
int age = 25;           // 정수형으로 선언
char name[] = "김철수";  // 문자열로 선언
age = "안녕하세요";      // ❌ 컴파일 오류 발생!
```

### 동작 원리

```
📝 코드 작성 시 타입 명시
      ↓
🔍 컴파일러가 타입 검사
      ↓
✅ 타입 오류 사전 검출
      ↓
⚡ 최적화된 기계어 생성
```

### ✅ 장점

#### 1. 타입 안정성 (Type Safety)

- 컴파일 시점에 타입 오류를 미리 발견
- 런타임 타입 오류 방지
- 예상치 못한 버그 크게 감소

#### 2. 성능 최적화

- 타입 정보를 미리 알고 있어 컴파일러 최적화 가능
- 메모리 사용량 예측 가능
- 빠른 실행 속도

#### 3. 개발자 도구 지원

- 정확한 자동완성 (IntelliSense)
- 리팩토링 도구 지원
- 정적 분석 도구 활용 가능

#### 4. 코드 문서화 효과

- 타입 선언 자체가 문서 역할
- 함수의 입력/출력 타입이 명확
- 코드 의도 파악 용이

#### 5. 대규모 프로젝트 적합

- 팀 협업 시 인터페이스 명확
- 유지보수성 향상
- 버전 업그레이드 시 호환성 검사

### ❌ 단점

#### 1. 개발 속도 저하

- 모든 변수의 타입을 미리 선언
- 타입 관련 보일러플레이트 코드 증가
- 빠른 프로토타이핑에 부적합

#### 2. 유연성 제한

- 타입 변경이 어려움
- 동적인 데이터 처리 복잡
- 제네릭/템플릿 등 고급 문법 필요

#### 3. 학습 곡선

- 타입 시스템 이해 필요
- 복잡한 타입 선언 방법 학습
- 초보자에게 진입 장벽

### 대표 언어

- **C/C++**: 시스템 프로그래밍의 기본
- **Java**: 엔터프라이즈 애플리케이션
- **C#**: .NET 생태계
- **Swift**: iOS 개발
- **Kotlin**: Android 개발 + 멀티플랫폼
- **TypeScript**: JavaScript + 정적 타입
- **Rust**: 메모리 안전성 + 성능

---

## 🔄 동적 타입 (Dynamic Typing)

### 정의

변수의 타입이 **런타임 시점(프로그램 실행 중)**에 결정되며, 타입 선언이 **선택사항**인 방식

### 특징

```python
# Python 예시
age = 25              # 정수
age = "스물다섯"       # 문자열로 변경 가능
age = [1, 2, 3]       # 리스트로 변경 가능
age = {"한국": 25}     # 딕셔너리로 변경 가능
```

### 동작 원리

```
📝 코드 작성 (타입 선언 없음)
      ↓
⚡ 실행 시 값에 따라 타입 결정
      ↓
🔄 실행 중 타입 변경 가능
      ↓
🔍 타입 오류는 실행 중 발견
```

### ✅ 장점

#### 1. 빠른 개발 속도

- 타입 선언 없이 바로 코딩
- 프로토타이핑에 최적
- 아이디어를 빠르게 구현

#### 2. 코드 간결성

- 보일러플레이트 코드 최소화
- 읽기 쉬운 코드
- 핵심 로직에 집중

#### 3. 유연성

- 변수에 다양한 타입 할당 가능
- 런타임에 동적 타입 변경
- 메타프로그래밍 용이

#### 4. 학습 용이성

- 초보자 친화적
- 타입 시스템 학습 부담 없음
- 바로 실행하며 학습 가능

#### 5. 대화형 개발

- REPL 환경에서 즉시 테스트
- 실험적 코딩에 적합
- 데이터 탐색에 유리

### ❌ 단점

#### 1. 런타임 오류 위험

- 타입 오류가 실행 중에만 발견
- 예상치 못한 TypeError 발생
- 배포 후 오류 발견 가능성

#### 2. 성능 오버헤드

- 런타임 타입 검사 필요
- 메모리 사용량 증가
- 실행 속도 상대적으로 느림

#### 3. 개발 도구 지원 제한

- 정확한 자동완성 어려움
- 리팩토링 도구 한계
- 정적 분석 도구 활용 제한

#### 4. 대규모 프로젝트 한계

- 인터페이스 불명확
- 유지보수 어려움
- 팀 협업 시 의사소통 비용 증가

#### 5. 암묵적 타입 변환

- 예상치 못한 타입 변환
- 미묘한 버그 발생 가능
- 디버깅 어려움

### 대표 언어

- **Python**: 데이터 과학, AI/ML, 웹 개발
- **JavaScript**: 웹 프론트엔드/백엔드
- **Ruby**: 웹 개발, 스크립팅
- **PHP**: 웹 서버 사이드
- **Lua**: 게임 스크립팅, 임베디드

---

## 📊 상세 비교표

| 항목                | 정적 타입          | 동적 타입          |
| ------------------- | ------------------ | ------------------ |
| **타입 결정 시점**  | 컴파일 시점        | 런타임 시점        |
| **타입 선언**       | 필수               | 선택사항           |
| **타입 안정성**     | 🟢 높음            | 🟡 낮음            |
| **개발 속도**       | 🟡 상대적으로 느림 | 🟢 빠름            |
| **실행 성능**       | 🟢 빠름            | 🟡 상대적으로 느림 |
| **오류 발견**       | 🟢 컴파일 시점     | 🟡 런타임 시점     |
| **코드 길이**       | 🟡 상대적으로 김   | 🟢 간결함          |
| **유지보수성**      | 🟢 높음            | 🟡 낮음            |
| **학습 난이도**     | 🟡 높음            | 🟢 낮음            |
| **IDE 지원**        | 🟢 우수함          | 🟡 제한적          |
| **리팩토링**        | 🟢 안전함          | 🟡 위험함          |
| **대규모 프로젝트** | 🟢 적합            | 🟡 부적합          |

## 🎯 현실적인 예시 비교

### 정적 타입 (Java)

```java
// 명확하지만 길어짐
public class Calculator {
    public static int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        int result = add(5, 3);
        System.out.println(result);
    }
}
```

### 동적 타입 (Python)

```python
# 간결하지만 타입이 불명확
def add(a, b):
    return a + b

result = add(5, 3)
print(result)

# 하지만 이런 실수도 가능
result = add("Hello", "World")  # 문자열 연결
result = add([1, 2], [3, 4])    # 리스트 합치기
```

## 🔄 현대적 접근법

### 점진적 타입 (Gradual Typing)

동적 타입 언어에 선택적으로 타입 힌트 추가

#### Python 타입 힌트

```python
from typing import List, Optional

def process_numbers(numbers: List[int]) -> Optional[int]:
    if not numbers:
        return None
    return sum(numbers)

# 런타임에는 동적 타입으로 동작
# 개발 도구에서는 정적 타입 검사 지원
```

#### TypeScript

```typescript
// JavaScript의 유연성 + 정적 타입의 안정성
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// 타입 추론도 지원
const message = greet("World"); // string으로 자동 추론
```

## 💡 선택 기준

### 정적 타입을 선택해야 할 때

- 대규모 팀 프로젝트
- 장기간 유지보수가 필요한 시스템
- 성능이 중요한 애플리케이션
- 금융, 의료 등 오류 비용이 높은 분야
- API 서버 개발
- 라이브러리/프레임워크 개발

### 동적 타입을 선택해야 할 때

- 빠른 프로토타이핑
- 데이터 분석 및 실험
- 스크립팅 자동화
- 교육 및 학습 목적
- 작은 규모의 개인 프로젝트
- 요구사항 변화가 잦은 프로젝트
