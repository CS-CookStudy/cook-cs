# 컴파일러 vs 인터프리터

## 🎯 학습 목표

- 컴파일러와 인터프리터의 동작 원리를 이해한다
- 각각의 장단점을 비교 분석한다
- 실제 언어 예시를 통해 차이점을 파악한다

## 📌 핵심 개념

사람이 작성한 고급 언어(C, Python, Java...)를 컴퓨터가 이해할 수 있는 **기계어(Machine Code)**로 번역하는 두 가지 방식

### 🔑 핵심 차이점: **빌드 과정의 유무**

---

## 🏗️ 컴파일러 (Compiler)

### 정의

전체 소스 코드를 **한 번에** 읽어서 기계어로 변환하여 **실행 파일을 생성**하는 프로그램

### 동작 과정

```
📝 소스 코드 전체 분석
      ↓ (컴파일)
⚙️ 목적 코드 생성
      ↓ (최적화)
🔧 기계어 코드 변환
      ↓ (링크)
🚀 실행 파일 생성
```

### ✅ 장점

- **빠른 실행 속도**: 이미 기계어로 변환되어 있어 실행이 매우 빠름
- **코드 최적화**: 컴파일 과정에서 다양한 성능 최적화 적용
- **사전 오류 발견**: 컴파일 시점에 문법/타입 오류를 미리 검출
- **독립 실행**: 컴파일 후 원본 코드 없이도 실행 가능

### ❌ 단점

- **긴 컴파일 시간**: 대규모 프로젝트에서 초기 빌드 시간이 오래 걸림
- **플랫폼 종속성**: OS/하드웨어별로 다른 실행 파일 필요
- **전체 재컴파일**: 작은 변경에도 전체 코드를 다시 컴파일해야 함
- **디버깅 복잡성**: 런타임 디버깅이 상대적으로 어려움

### 대표 언어

- **C/C++**: 시스템 프로그래밍, 고성능 애플리케이션
- **Rust**: 시스템 안전성과 성능을 동시에 추구
- **Go**: 간결함과 성능을 균형있게 제공
- **Java**: 바이트코드로 컴파일 후 JVM에서 실행

---

## 🔄 인터프리터 (Interpreter)

### 정의

소스 코드를 **한 줄씩** 읽어서 해석하고 **즉시 실행**하는 프로그램 (별도 실행 파일 생성 없음)

### 동작 과정

```
📝 소스 코드 한 줄 읽기
      ↓
🔍 즉시 해석
      ↓
⚡ 바로 실행
      ↓
🔄 다음 줄로 반복
```

### ✅ 장점

- **빠른 개발 사이클**: 코드 수정 후 즉시 실행 가능
- **플랫폼 독립성**: 인터프리터만 있으면 어디서든 실행
- **빌드 과정 불필요**: 별도 컴파일 단계 없이 바로 실행
- **쉬운 디버깅**: 실행 중 상태 확인과 수정이 용이
- **대화형 실행**: REPL 환경에서 즉시 테스트 가능

### ❌ 단점

- **느린 실행 속도**: 매번 해석이 필요하므로 성능 저하
- **런타임 오류**: 실행 중에만 오류 발견 가능
- **소스 코드 노출**: 실행 시 원본 코드가 필요
- **메모리 사용량**: 인터프리터 자체의 메모리 오버헤드

### 대표 언어

- **Python**: 데이터 분석, AI/ML, 웹 개발
- **JavaScript**: 웹 프론트엔드, Node.js 백엔드
- **Ruby**: 웹 개발(Ruby on Rails)
- **PHP**: 웹 서버 사이드 개발

---

## 📊 상세 비교표

| 항목              | 컴파일러                  | 인터프리터               |
| ----------------- | ------------------------- | ------------------------ |
| **실행 방식**     | 전체 코드 → 기계어 → 실행 | 한 줄씩 해석하며 실행    |
| **실행 파일**     | ✅ 생성됨                 | ❌ 생성 안됨             |
| **실행 속도**     | 🟢 매우 빠름              | 🟡 상대적으로 느림       |
| **개발 속도**     | 🟡 컴파일 시간 필요       | 🟢 즉시 실행             |
| **메모리 사용**   | 🟢 효율적                 | 🟡 인터프리터 오버헤드   |
| **오류 발견**     | 🟢 컴파일 시점            | 🟡 실행 시점             |
| **디버깅**        | 🟡 복잡함                 | 🟢 쉬움                  |
| **플랫폼 호환성** | 🟡 종속적                 | 🟢 독립적                |
| **배포**          | 🟢 실행파일만             | 🟡 소스코드 + 인터프리터 |

## 💡 선택 기준

### 컴파일러 언어를 선택해야 할 때

- 성능이 매우 중요한 시스템 (OS, 임베디드, 게임 엔진)
- 대용량 데이터 처리
- 실시간 시스템
- 메모리 사용량이 제한적인 환경

### 인터프리터 언어를 선택해야 할 때

- 빠른 프로토타이핑이 필요할 때
- 스크립팅 자동화
- 웹 개발
- 데이터 분석 및 실험
- 교육 및 학습 목적

---
