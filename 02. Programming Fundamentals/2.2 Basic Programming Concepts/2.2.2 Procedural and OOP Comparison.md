# 절차지향 VS 객체지향 프로그래밍

## 1. 프로그래밍 패러다임
> 코드를 어떻게 구조화하고 사고화할 것인가

- 종류 : 
   - `절차적 프로그래밍` : 순차적인 실행 흐름을 강조
   - `객체지향 프로그래밍` : 데이터를 객체 단위로 묶어 모듈화를 강화
   - `함수형 프로그래밍` : 상태 변화를 최소화하고 순수 함수를 조합하여 예측 가능한 코드를 작성

<br>

### 1.1 절차적 프로그래밍(절차 지향, Procedural Programming)
<br>

#### 1.1.1 개념 설명
- 정의 : 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법
- 대표 언어 : C언어, Pascal
- **활용** : 단순한 스크립트나 시스템 프로그래밍, 임베디드 시스템 등에서 활용
- 중요특징 : 
  - 순차적  실행 : 각 단계가 명확한 순서를 가지며, 조건문이나 반복문을 통해 분기와 반복을 제어
  - 함수와 서브루틴 : 코드의 재사용과 모듈화를 위해 기능별로 함수를 정의
  - 데이터와 변수 : 데이터를 저장하는 변수는 전역 변수 또는 지역 변수로 구분되며, 함수 간에 데이터를 주고받는 방식으로 프로그램이 동작

<br>

#### 1.1.2 절차적 프로그래밍의 장단점
- 장점 : 
  - 구조 단순하고 흐름 직관적임 → 작은 프로젝트나 단순한 문제 해결에 적합함 
  - 복잡한 설계 없이 순차적으로 구현 가능 → 빠른 프로토타입 제작에 유리함

- 단점 : 
  - 확장성이 낮고 유지보수 및 디버깅이 어려움
  - 큰 규모 시스템에서는 코드가 하나의 흐름에 얽매여 있어, 역할 분담이 어렵고 변경 시 다른 부분에 연쇄적으로 영향을 미침

<br>

#### 1.1.3 예시

##### 두수 합을 구하는 프로그램(C언어)

```C
#include <stdio.h>

// 두 수의 합을 구하는 함수
int add(int a, int b) {
    return a + b;
}

int main() {
    int num1, num2, sum;

    // 사용자로부터 두 개의 숫자 입력 받기
    printf("첫 번째 숫자를 입력하세요: ");
    scanf("%d", &num1);
    printf("두 번째 숫자를 입력하세요: ");
    scanf("%d", &num2);

    // 함수 호출을 통해 합 계산
    sum = add(num1, num2);

    // 결과 출력
    printf("두 수의 합은 %d 입니다.\n", sum);

    return 0;
}
```
- 전형적인 절차적 프로그래밍의 구조
- main() 함수는 프로그램 시작점이며, 순차적으로 입력, 함수호출, 결과 출력의 과정을 거침

### 1.2 객체지향 프로그래밍(OOP, Object Oriented Programming)
<br>

#### 1.2.1 개념 설명
- 정의 : 데이터와 기능을 하나의 객체로 묶어 프로그램을 보다 직관적이고 유연하게 설계하는 방식
- 등장 계기 : 소프트웨어 언어의 발달과 컴파일러의 발달로 하드웨어가 소프트웨어의 발달을 따라오지 못하는 상황이 발생
- 대표 언어 : Java, Python, C++ 등
- 객체와 클래스 : 
  - `객체` : 데이터(상태)와 함수(행동)를 함께 가지는 독립적인 존재
  - `클래스` : 객체를 만들기 위한 설계도, 어떤 속성과 기능을 가질지 정의

<br>

#### 1.2.2 객체지향 프로그램밍의 장단점
- 장점 : 
  - 유지보수성 용이 -> 캡슐화로 이루어져 코드 변경시 영향 최소화
  - 클래스·객체 추가로 확장 유연함
  - 상속과 인터페이스로 코드 재사용 가능

- 단점 : 
  - 구조 설계 복잡해서 초기 진입장벽 있음
  - 객체 생성, 다형성 등으로 오버헤드 발생 가능함

<br>

#### 1.2.3 객체지향의 3대 원칙(기본 설계 원칙)
> 객체지향에서 객체들은 **캡슐화**된 구조를 가지며, 기존 객체를 **상속**해서 확장하고, 공통된 방식으로 호출하되 객체에 따라 다르게 반응하는 **다형성**을 가짐

- 캡슐화(Encapsulation)
  - 정의 : 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없게 하는 것으로 객체의 가장 본질적인 특징
  - 특징 : 
    - 데이터 은닉 : 클래스 내부의 데이터를 외부에서 직접 접근하지 못하도록 하고, 필요한 경우 공개된 메서드를 통해서만 접근 가능
    - 안정성 및 유지 보수성 : 데이터의 무결성을 보장하고, 클래스 내부 구현이 변경되더라도 외부에 미치는 영향을 최소화
  - 접근 제어자(Access Modifiers, 언어마다 약간씩 다르게 구현됨)
    - public: 외부에서 자유롭게 접근 가능한 멤버 
    - private: 클래스 내부에서만 접근할 수 있는 멤버 
    - protected: 같은 패키지 혹은 상속 받은 클래스에서 접근 가능한 멤버

- 상속(Inheritance)
  - 정의 : 상위 개체의 속성을 하위 개체에 물려줘 하위 개체가 상위 개체의 속성을 모두 가지는 관계
  - 목적: 
    - 코드 재사용성 증가: 중복 코드를 줄이고, 공통 기능을 부모 클래스에 정의하여 여러 자식 클래스에서 활용
    - 계층적 구조 구성: 클래스 간의 관계를 계층적으로 정리하여 시스템을 보다 직관적으로 설계

- 다형성(Polymorphism)
  - 정의 : 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
  - 비유 : “동물”이라는 개념이 있을 때, 개, 고양이, 새 등이 각기 다른 소리를 내지만 모두 “동물”이라는 범주에 속하는 것과 유사
  - 유형 : 
    - 오버로딩(overLoading, Java의 메서드 오버로딩) : 같은 이름의 메서드가 매개변수의 타입이나 개수에 따라 다르게 작동
    - 오버라이딩(overriding, Java/python/c++ 등) : 부모 클래스에서 정의된 메서드를 자식 클래스에서 재정의하여 서로 다른 작동을 구현


#### 1.2.4 예제

##### 사과장수 시물레이션(C++)
```C++
#include <iostream>

using namespace std;

class FruitSeller
{
private:
    int applePrice;
    int numOfApples;
    int myMoney;
public:
    void InitMembers(int price, int num, int money)
    {
        applePrice = price;
        numOfApples = num;
        myMoney = money;
    }
    int  SaleApples(int money)
    {
        int num = money / applePrice;
        numOfApples -= num;
        myMoney += money;
        return num;
    }
    void ShowSalesResult()
    {
        cout << "남은 사과: " << numOfApples << endl;
        cout << "판매 수익: " << myMoney << endl << endl;
    }
};

class FruitBuyer
{
private:
    int myMoney;
    int numOfApples;
public:
    void InitMembers(int money)
    {
        myMoney = money;
        numOfApples = 0;
    }
    void BuyApples(FruitSeller& seller, int money)
    {
        numOfApples += seller.SaleApples(money);  // 메시지 전달(Message Passing)
        myMoney -= money;
    }
    void ShowBuyResult()
    {
        cout << "현재 잔액: " << myMoney << endl;
        cout << "사과 개수: " << numOfApples << endl << endl;
    }
};


int main(void)
{
    FruitSeller seller;
    seller.InitMembers(1000, 20, 0);
    FruitBuyer buyer;
    buyer.InitMembers(5000);
    buyer.BuyApples(seller, 2000);

    cout << "과일 판매자의 현황: " << endl;
    seller.ShowSalesResult();
    cout << "과일 구매자의 현황: " << endl;
    buyer.ShowBuyResult();

    system("pause");  // VC++ 에서만 필요

    return 0;
}

```
<br>

### 1.3 절차 지향 vs 객체 지향
- 절차 지향 :
  - 구조가 단순한 경우에 효율적이지만, 복잡한 시스템에서는 모듈화와 재사용성이 떨어질 수 있음.
  - 객체 지향에 비해 빠름

- 객체 지향 :
  - 복잡한 시스템을 설계할 때, 현실 세계의 문제를 효과적으로 모델링하고, 모듈화된 구조로 유지보수 및 확장을 용이
  - 기능별로 묶어 모듈화를 함으로써 하드웨어가 같은 기능을 중복으로 연산하지 않도록 하고, 모듈을 재활용하기 때문에 하드웨어의 처리량을 획기적으로 줄여줌

> 절차적 프로그래밍이 단순한 명령어의 순차적 실행에 초점을 맞춘다면, 객체지향 프로그래밍은 데이터와 기능의 결합, 재사용성, 확장성에 중점을 둡니다


| 항목                        | 절차지향 (POP) | 객체지향 (OOP) |
|---------------------------|----------------|----------------|
| 접근 방식                     | Top-Down<br>(시스템 동작 방식을 먼저 생각, 그 다음 세부 모델 디자인) | Bottom-Up<br>(세부 모델 디자인 후 조립) |
| 구현 관점                     | 전체적인 기능 동작을 고려 → 각 단계별로 기능 구현 | 필요한 속성의 객체를 설계<br>(보안성, 데이터, 함수 등) → 각 객체의 상호작용(절차) 설계 |
| 구성 요소                     | 함수 | 객체 |
| 접근 제어                     | Public | Public, Protected, Private |
| 오버로딩 / 다형성                | 불가능 | 함수, 생성자, 연산자 오버로딩 가능 |
| 상속                        | 불가능 | 가능 (Public, Protected, Private) |
| 보안성                       | 낮음 | 높음 |
| 데이터 공유                    | 모든 함수가 공유 가능 | 객체 간 멤버함수를 통해서만 공유 |
| 가상 클래스 / 가상 함수(C++ 중심 설명) | 없음 | 상속 개념 하에 존재 |
| 예시 언어                     | C, Visual Basic, Fortran, Pascal | C++, Java, VB.NET, C#, Python |
| 장점                        | 설계하기 쉬움 | 구조 파악 용이, 코드 절약 가능 |
| 단점                        | 구조 복잡, 중복 코드 발생 가능 | 오버헤드 최적화 안 하면 상대적으로 느림 |
| 용도                        | 한정된 자원, 초기부터 전체 설계 | 큰 규모, 잦은 협업, 생산성 중시 |

---
### 부연설명
- UML 다이어그램을 통한 캡슐화 이해([참고](https://wikidocs.net/274926))
---
### 용어 설명
- **오버헤드** : 필요한 기능을 구현하려다 보니 생기는 추가적인 시간이나 자원 낭비
---
[참고 : 소프트웨어 개발 입문](https://wikidocs.net/book/17361)  
[참고 : 절차 지향 vs 객체 지향](https://blackvill.tistory.com/221)
