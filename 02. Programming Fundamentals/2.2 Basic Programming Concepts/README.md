# 변수와 자료형
- **변수** : 데이터를 저장할 수 있는 메모리 공간에 붙여진 이름
- **자료형** : 변수에 저장될 수 있는 데이터의 종류

## 변수와 자료형의 관계
1. **변수는 자료형에 따라 선언** : 변수는 특정 자료형으로 선언되며, 이 자료형에 맞는 데이터만 저장 가능.

2. **자료형에 따른 메모리 할당** : 자료형은 변수에 할당되는 메모리 크기를 결정하며, 이는 연산의 효율성과도 관련.

3. **동적, 정적에 따른 차이 존재** : Python 같은 동적 언어는 변수의 자료형이 런타임에 결정되지만, Jave 나 C++ 같은 정적 언어는 변수의 자료형을 명시적으로 선언해야함.

## 변수 사용 시 유의사항
- 의미 있는 변수 이름 사용하기
- 반드시 초기값을 할당하여 예기치 않은 오류 방지하기
- 자료형에 맞는 연산을 수행하기

## 자료형과 메모리
![자료형과메모리](/images/2-2_data_type.png)

---

# 제어문
> 프로그램의 실행 흐름을 제어 하는 데 사용. 조건에 따라 다른 코드를 사용하거나, 특정 작업 반복 수행을 도와줌

## 1. 조건문
### `if`, `else if`, `else`

- if문: 조건이 참일 때만 실행.
- else if / elif: 앞선 조건들이 거짓일 경우 추가 조건을 평가.
- else: 모든 조건이 거짓일 때 실행.

### `switch`
- 크고 작다를 표현하는 것이 아닌 동등조건 검사에서 사용.
- 즉, 범위를 조건부호로 나타낼 수는 없음.

```c
switch (grade) {
case 4:
    printf("훌륭해요!")
case 3:
    printf("좋아요!");
case 2:
    printf("평균이네요!");
case 1:
    printf("좋지 않아요!");
case 0:
    printf("좀 더 노력하세요!");
default:
    printf("잘못된 학점입니다");
}
```
- `default`가 필수는 아니다. : 제어식의 그 어떤 조건과도 만족하지 않는 다면 프로그램은 단순히 switch문 다음 구문으로 넘어감.


## 2. 반복문
### `for문`
- 정해진 횟수만큼 반복 실행하기 위해 사용.

### `while문`
- 조건이 참인 동안 계속 반복 실행할 때 사용.

### `do문`
- 사실상 `while문`과 동일한 반복문. 다만, 제어식을 루프 본문 실행 이후에 판별할 뿐.
```c
do   statement   while   (  expression  )   ;
```
- statement가 우선 실행되고 expression이 평가됨.
```c
i = 10;
do {
    printf("T 빼기 %d, 세는 중\n", i);
    --i;
} while (i > 0);
```
> 📘 `do문` 풀이
>
> 1. 우선 `T 빼기 10, 세는 중`이라는 메세지가 출력.
> 2. i는 감소.
> 3. 뒤 조건 `i > 0`가 평가.
> 4. 아직 0보다 크므로 다시 1번으로 반복.
> 5. `i = 0` 이 되자마자 루프 종료
> 
> **while과 차이점?** : 본문(statement)이 적어도 한 번은 실행됨.


---

# 함수
> 프로그래밍에서 함수란, 특정 작업을 수행하는 코드 블록. 함수로 인해 코드를 재사용 할 수 있고 모듈화하여 프로그램을 체계적으로 구성할 수 있음

- **정의** : 입력(매개변수)을 받아 일정한 작업을 수행한 후 결과(반환값)를 돌려주는 코드의 집합.

## 함수의 구성요소
1. 함수 이름 : 함수를 호출할 때 사용하는 식별자.

2. **매개변수(Parameter)** : 함수에 전달되는 입력값들을 의미하며, 함수 내에서 변수처럼 사용됨.

3. 함수 본문(Body): 함수가 수행하는 실제 작업을 담고 있는 코드 블록.

4. **반환값(Return Value)** : 함수가 작업을 마치고 돌려주는 결과값입. 반환값이 없는 경우도 존재 (예: void 함수)

5. **입력변수(Argument)** : 함수를 호출하기 위해 함수에 정보를 제공하는데 필요한 변수.

## 함수의 장점
1. **코드의 재사용성 증가** : 동일한 작업을 반복할 때, 함수를 호출하는 것만으로 코드를 재사용할 수 있음.

2. **프로그램의 구조화** : 기능별로 코드를 분리하여, 프로그램 전체를 보다 체계적으로 구성할 수 있음.

3. **유지보수 용이** : 코드의 특정 부분을 함수로 분리하면, 해당 기능만 수정하거나 업데이트하기가 쉬워짐.

4. **디버깅과 테스트의 용이성** : 함수를 개별 단위로 테스트할 수 있어, 오류를 쉽게 찾고 수정할 수 있음.

## 예시
### Python
- `def` 키워드를 사용하여 함수를 선언.
```python
# 함수 정의: 인사말을 출력하는 함수
def greet(name):
    """지정된 이름을 인자로 받아 인사말을 반환하는 함수"""
    return f"Hello, {name}!"

# 함수 호출
print(greet("Alice"))
print(greet("Bob"))
```

### Java
- 함수 대신 메서드(Method)라는 용어를 사용하며, 클래스 내부에 정의.
- 매개변수와 반환값의 타입을 명확히 선언해야 하며, 타입 일치에 주의해야 함.
```java
public class FunctionExample {

    // 인사말을 반환하는 메서드 정의
    public static String greet(String name) {
        return "Hello, " + name + "!";
    }

    public static void main(String[] args) {
        // 메서드 호출 및 결과 출력
        System.out.println(greet("Alice"));
        System.out.println(greet("Bob"));
    }
}
```

### C++
- 매개변수와 반환값의 타입을 명확히 선언해야 하며, 타입 일치에 주의해야 함.
```cpp
#include <iostream>
#include <string>
using namespace std;

// 인사말을 반환하는 함수 정의
string greet(const string &name) {
    return "Hello, " + name + "!";
}

int main() {
    // 함수 호출 및 결과 출력
    cout << greet("Alice") << endl;
    cout << greet("Bob") << endl;
    return 0;
}
```