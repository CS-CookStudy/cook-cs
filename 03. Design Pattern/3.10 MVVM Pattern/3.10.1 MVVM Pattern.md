# ğŸ“˜ ë””ìì¸ íŒ¨í„´

# MVVM íŒ¨í„´ (Model-View-ViewModel Pattern)

## 1. ì •ì˜

MVVM íŒ¨í„´ì€ **ë°ì´í„° ë°”ì¸ë”©ì„ í†µí•´ Viewì™€ ViewModel ê°„ì˜ ìë™ ë™ê¸°í™”ë¥¼ ì œê³µ**í•˜ëŠ” ì•„í‚¤í…ì²˜ íŒ¨í„´ì´ë‹¤. MVP íŒ¨í„´ì—ì„œ ë°œì „ëœ í˜•íƒœë¡œ, **ê°œë°œìê°€ ìˆ˜ë™ìœ¼ë¡œ Viewë¥¼ ì—…ë°ì´íŠ¸í•  í•„ìš” ì—†ì´** ViewModelì˜ ë°ì´í„°ë§Œ ë³€ê²½í•˜ë©´ Viewê°€ ìë™ìœ¼ë¡œ ë°˜ì˜ë˜ëŠ” êµ¬ì¡°ë¥¼ ì œê³µí•œë‹¤.

ì–‘ë°©í–¥ ë°ì´í„° ë°”ì¸ë”©ì„ í†µí•´ **ì‚¬ìš©ì ì…ë ¥ë„ ìë™ìœ¼ë¡œ ViewModelì— ë°˜ì˜**ë˜ë©°, ì´ë¥¼ í†µí•´ ê°œë°œìëŠ” UI ì¡°ì‘ ë¡œì§ë³´ë‹¤ëŠ” **ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ì§‘ì¤‘**í•  ìˆ˜ ìˆê²Œ ëœë‹¤.

> ì°¸ê³ : ì´ íŒ¨í„´ì€ GoFì˜ 23ê°œ ë””ìì¸ íŒ¨í„´ì—ëŠ” í¬í•¨ë˜ì§€ ì•Šìœ¼ë©°, Microsoftì—ì„œ WPFì™€ Silverlightë¥¼ ìœ„í•´ ê°œë°œí•œ ì•„í‚¤í…ì²˜ íŒ¨í„´ì…ë‹ˆë‹¤.

### ì–¸ì œ ì‚¬ìš©í•˜ë©´ ì¢‹ì€ê°€?

**ê°œë°œ ê´€ë ¨ ì˜ˆì‹œë¡œ ì´í•´í•˜ê¸°:**
- **React/Vue.js ì• í”Œë¦¬ì¼€ì´ì…˜**: ìƒíƒœ ë³€í™”ê°€ ìë™ìœ¼ë¡œ ì»´í¬ë„ŒíŠ¸ì— ë°˜ì˜ë˜ëŠ” êµ¬ì¡°
- **Angular ì• í”Œë¦¬ì¼€ì´ì…˜**: ì–‘ë°©í–¥ ë°ì´í„° ë°”ì¸ë”©ìœ¼ë¡œ í¼ê³¼ ëª¨ë¸ì´ ìë™ ë™ê¸°í™”
- **WPF/UWP ë°ìŠ¤í¬í†± ì•±**: XAMLê³¼ C# ì½”ë“œë¹„í•˜ì¸ë“œ ê°„ì˜ ë°ì´í„° ë°”ì¸ë”©
- **ëª¨ë°”ì¼ ì•± ê°œë°œ**: Flutter, SwiftUIì—ì„œ ìƒíƒœ ê´€ë¦¬ì™€ UI ì—…ë°ì´íŠ¸ ìë™í™”

**ì´ëŸ° ìƒí™©ì—ì„œ MVVM Patternì„ ì‚¬ìš©í•˜ë©´ ì¢‹ìŠµë‹ˆë‹¤:**
- **ë³µì¡í•œ UI ìƒíƒœ ê´€ë¦¬**ê°€ í•„ìš”í•œ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ
- **ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸**ê°€ ë¹ˆë²ˆí•˜ê²Œ ì¼ì–´ë‚˜ëŠ” ê²½ìš°
- **ì–‘ë°©í–¥ ë°ì´í„° ë°”ì¸ë”©ì„ ì§€ì›**í•˜ëŠ” í”„ë ˆì„ì›Œí¬ë¥¼ ì‚¬ìš©í•  ë•Œ
- **UI ë¡œì§ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì™„ì „íˆ ë¶„ë¦¬**í•˜ê³  ì‹¶ì„ ë•Œ
- **í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ UI ë¡œì§**ì„ ë§Œë“¤ê³  ì‹¶ì„ ë•Œ

## 2. êµ¬ì¡°ë„

![MVVM Pattern](./images/MVVM%20Pattern.webp)
- ì¶œì²˜: Microsoft ì•„í‚¤í…ì²˜ íŒ¨í„´ ê°€ì´ë“œ

> * `Model`: ë°ì´í„°ì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ê³„ì¸µ
> * `View`: ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ë¥¼ ë‹´ë‹¹í•˜ë©°, ViewModelê³¼ ë°ì´í„° ë°”ì¸ë”©ìœ¼ë¡œ ì—°ê²°
> * `ViewModel`: Viewì˜ ìƒíƒœì™€ í–‰ë™ì„ ê´€ë¦¬í•˜ë©°, Modelê³¼ View ì‚¬ì´ì˜ ì–´ëŒ‘í„° ì—­í• 

## 3. ì˜ˆì‹œ

### ì˜ˆ: ì‹¤ì‹œê°„ ì£¼ì‹ ì°¨íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜

```typescript
// Model - ì£¼ì‹ ë°ì´í„° ê´€ë¦¬
interface StockData {
  symbol: string;
  price: number;
  change: number;
  changePercent: number;
  timestamp: Date;
}

class StockModel {
  private stockService: StockWebSocketService;
  
  constructor() {
    this.stockService = new StockWebSocketService();
  }
  
  subscribeToStock(symbol: string): Observable<StockData> {
    return this.stockService.subscribe(symbol);
  }
  
  getHistoricalData(symbol: string, days: number): Promise<StockData[]> {
    return this.stockService.getHistoricalData(symbol, days);
  }
  
  unsubscribe(symbol: string): void {
    this.stockService.unsubscribe(symbol);
  }
}

// ViewModel - Viewì™€ Model ì‚¬ì´ì˜ ì¤‘ì¬ì
class StockViewModel {
  // Observable ì†ì„±ë“¤ - Viewì™€ ìë™ ë™ê¸°í™”
  @observable currentPrice: number = 0;
  @observable priceChange: number = 0;
  @observable changePercent: number = 0;
  @observable stockSymbol: string = '';
  @observable isLoading: boolean = false;
  @observable errorMessage: string = '';
  @observable chartData: StockData[] = [];
  @observable isPositiveChange: boolean = false;
  
  private model: StockModel;
  private subscription?: Subscription;
  
  constructor() {
    this.model = new StockModel();
  }
  
  // Viewì—ì„œ í˜¸ì¶œí•˜ëŠ” ì•¡ì…˜ë“¤
  @action
  async loadStock(symbol: string): Promise<void> {
    try {
      this.isLoading = true;
      this.errorMessage = '';
      this.stockSymbol = symbol;
      
      // ì‹¤ì‹œê°„ ë°ì´í„° êµ¬ë…
      this.subscription = this.model.subscribeToStock(symbol)
        .subscribe(data => this.updateStockData(data));
      
      // ì°¨íŠ¸ìš© íˆìŠ¤í† ë¦¬ ë°ì´í„° ë¡œë“œ
      const historicalData = await this.model.getHistoricalData(symbol, 30);
      this.chartData = historicalData;
      
    } catch (error) {
      this.errorMessage = `ì£¼ì‹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error.message}`;
    } finally {
      this.isLoading = false;
    }
  }
  
  @action
  private updateStockData(data: StockData): void {
    this.currentPrice = data.price;
    this.priceChange = data.change;
    this.changePercent = data.changePercent;
    this.isPositiveChange = data.change >= 0;
    
    // ì°¨íŠ¸ ë°ì´í„°ì— ìƒˆ í¬ì¸íŠ¸ ì¶”ê°€
    this.chartData = [...this.chartData.slice(-29), data];
  }
  
  @action
  stopTracking(): void {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = undefined;
    }
    this.model.unsubscribe(this.stockSymbol);
  }
  
  // ì»´í“¨í‹°ë“œ ì†ì„± - ìë™ìœ¼ë¡œ ê³„ì‚°ë¨
  @computed
  get formattedPrice(): string {
    return `$${this.currentPrice.toFixed(2)}`;
  }
  
  @computed
  get formattedChange(): string {
    const sign = this.priceChange >= 0 ? '+' : '';
    return `${sign}${this.priceChange.toFixed(2)} (${this.changePercent.toFixed(2)}%)`;
  }
  
  @computed
  get priceColor(): string {
    return this.isPositiveChange ? 'green' : 'red';
  }
}

// View - React ì»´í¬ë„ŒíŠ¸ (ìë™ ë°ì´í„° ë°”ì¸ë”©)
const StockView: React.FC = observer(() => {
  const [viewModel] = useState(() => new StockViewModel());
  const [inputSymbol, setInputSymbol] = useState('');
  
  const handleLoadStock = () => {
    if (inputSymbol.trim()) {
      viewModel.loadStock(inputSymbol.toUpperCase());
    }
  };
  
  const handleStopTracking = () => {
    viewModel.stopTracking();
  };
  
  useEffect(() => {
    return () => viewModel.stopTracking(); // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ì‹œ ì •ë¦¬
  }, [viewModel]);
  
  return (
    <div className="stock-container">
      <h1>ì‹¤ì‹œê°„ ì£¼ì‹ ì°¨íŠ¸</h1>
      
      {/* ì£¼ì‹ ì‹¬ë³¼ ì…ë ¥ */}
      <div className="input-section">
        <input
          type="text"
          value={inputSymbol}
          onChange={(e) => setInputSymbol(e.target.value)}
          placeholder="ì£¼ì‹ ì‹¬ë³¼ ì…ë ¥ (ì˜ˆ: AAPL)"
          onKeyPress={(e) => e.key === 'Enter' && handleLoadStock()}
        />
        <button onClick={handleLoadStock} disabled={viewModel.isLoading}>
          {viewModel.isLoading ? 'ë¡œë”© ì¤‘...' : 'ì¶”ì  ì‹œì‘'}
        </button>
        <button onClick={handleStopTracking}>
          ì¶”ì  ì¤‘ì§€
        </button>
      </div>
      
      {/* ì—ëŸ¬ ë©”ì‹œì§€ */}
      {viewModel.errorMessage && (
        <div className="error-message">
          {viewModel.errorMessage}
        </div>
      )}
      
      {/* í˜„ì¬ ì£¼ì‹ ì •ë³´ - ViewModelê³¼ ìë™ ë™ê¸°í™” */}
      {viewModel.stockSymbol && (
        <div className="stock-info">
          <h2>{viewModel.stockSymbol}</h2>
          <div className="price-info">
            <span className="current-price">
              {viewModel.formattedPrice}
            </span>
            <span className={`price-change ${viewModel.priceColor}`}>
              {viewModel.formattedChange}
            </span>
          </div>
        </div>
      )}
      
      {/* ì°¨íŠ¸ */}
      {viewModel.chartData.length > 0 && (
        <div className="chart-container">
          <LineChart
            width={800}
            height={400}
            data={viewModel.chartData}
          >
            <XAxis dataKey="timestamp" />
            <YAxis domain={['dataMin', 'dataMax']} />
            <CartesianGrid strokeDasharray="3 3" />
            <Tooltip />
            <Line 
              type="monotone" 
              dataKey="price" 
              stroke={viewModel.priceColor}
              strokeWidth={2}
            />
          </LineChart>
        </div>
      )}
    </div>
  );
});
```

### ì˜ˆ: í•  ì¼ ê´€ë¦¬ ì•± (Vue.js)

```vue
<template>
  <div class="todo-app">
    <h1>í•  ì¼ ê´€ë¦¬</h1>
    
    <!-- ìƒˆ í•  ì¼ ì¶”ê°€ -->
    <div class="add-todo">
      <input
        v-model="newTodoTitle"
        @keyup.enter="addTodo"
        placeholder="ìƒˆ í•  ì¼ì„ ì…ë ¥í•˜ì„¸ìš”"
        :disabled="isLoading"
      />
      <button @click="addTodo" :disabled="!newTodoTitle.trim() || isLoading">
        ì¶”ê°€
      </button>
    </div>
    
    <!-- í•„í„° ë²„íŠ¼ë“¤ -->
    <div class="filters">
      <button 
        v-for="filter in filters" 
        :key="filter.key"
        @click="currentFilter = filter.key"
        :class="{ active: currentFilter === filter.key }"
      >
        {{ filter.label }}
      </button>
    </div>
    
    <!-- í†µê³„ ì •ë³´ -->
    <div class="stats">
      <p>ì „ì²´: {{ totalCount }}ê°œ</p>
      <p>ì™„ë£Œ: {{ completedCount }}ê°œ</p>
      <p>ë‚¨ì€ í•  ì¼: {{ remainingCount }}ê°œ</p>
      <div class="progress-bar">
        <div 
          class="progress-fill"
          :style="{ width: completionPercentage + '%' }"
        ></div>
      </div>
    </div>
    
    <!-- í•  ì¼ ëª©ë¡ -->
    <ul class="todo-list">
      <li
        v-for="todo in filteredTodos"
        :key="todo.id"
        :class="{ completed: todo.completed }"
      >
        <input
          type="checkbox"
          v-model="todo.completed"
          @change="updateTodo(todo)"
        />
        <input
          v-if="todo.isEditing"
          v-model="todo.title"
          @blur="saveEdit(todo)"
          @keyup.enter="saveEdit(todo)"
          @keyup.esc="cancelEdit(todo)"
          class="edit-input"
        />
        <span
          v-else
          @dblclick="startEdit(todo)"
          :class="{ completed: todo.completed }"
        >
          {{ todo.title }}
        </span>
        <button @click="deleteTodo(todo.id)" class="delete-btn">
          ì‚­ì œ
        </button>
      </li>
    </ul>
    
    <!-- ë¡œë”© ë° ì—ëŸ¬ ìƒíƒœ -->
    <div v-if="isLoading" class="loading">ì²˜ë¦¬ ì¤‘...</div>
    <div v-if="errorMessage" class="error">{{ errorMessage }}</div>
  </div>
</template>

<script>
// Model
class TodoModel {
  constructor() {
    this.todos = this.loadFromStorage();
    this.nextId = Math.max(...this.todos.map(t => t.id), 0) + 1;
  }
  
  addTodo(title) {
    const todo = {
      id: this.nextId++,
      title,
      completed: false,
      createdAt: new Date(),
      isEditing: false
    };
    this.todos.push(todo);
    this.saveToStorage();
    return todo;
  }
  
  updateTodo(updatedTodo) {
    const index = this.todos.findIndex(t => t.id === updatedTodo.id);
    if (index !== -1) {
      this.todos[index] = { ...updatedTodo };
      this.saveToStorage();
      return true;
    }
    return false;
  }
  
  deleteTodo(id) {
    const index = this.todos.findIndex(t => t.id === id);
    if (index !== -1) {
      this.todos.splice(index, 1);
      this.saveToStorage();
      return true;
    }
    return false;
  }
  
  getTodos() {
    return [...this.todos];
  }
  
  saveToStorage() {
    localStorage.setItem('todos', JSON.stringify(this.todos));
  }
  
  loadFromStorage() {
    const stored = localStorage.getItem('todos');
    return stored ? JSON.parse(stored) : [];
  }
}

export default {
  name: 'TodoApp',
  
  // ViewModel ë°ì´í„°
  data() {
    return {
      model: new TodoModel(),
      todos: [],
      newTodoTitle: '',
      currentFilter: 'all',
      isLoading: false,
      errorMessage: '',
      filters: [
        { key: 'all', label: 'ì „ì²´' },
        { key: 'active', label: 'ì§„í–‰ ì¤‘' },
        { key: 'completed', label: 'ì™„ë£Œ' }
      ]
    };
  },
  
  // ìë™ìœ¼ë¡œ ê³„ì‚°ë˜ëŠ” ì†ì„±ë“¤
  computed: {
    filteredTodos() {
      switch (this.currentFilter) {
        case 'active':
          return this.todos.filter(t => !t.completed);
        case 'completed':
          return this.todos.filter(t => t.completed);
        default:
          return this.todos;
      }
    },
    
    totalCount() {
      return this.todos.length;
    },
    
    completedCount() {
      return this.todos.filter(t => t.completed).length;
    },
    
    remainingCount() {
      return this.totalCount - this.completedCount;
    },
    
    completionPercentage() {
      return this.totalCount === 0 ? 0 : 
        Math.round((this.completedCount / this.totalCount) * 100);
    }
  },
  
  // ë¼ì´í”„ì‚¬ì´í´ - ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ì‹œ ë°ì´í„° ë¡œë“œ
  mounted() {
    this.loadTodos();
  },
  
  // Viewì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ë©”ì„œë“œë“¤
  methods: {
    async loadTodos() {
      try {
        this.isLoading = true;
        this.todos = this.model.getTodos();
      } catch (error) {
        this.errorMessage = 'í•  ì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      } finally {
        this.isLoading = false;
      }
    },
    
    async addTodo() {
      if (!this.newTodoTitle.trim()) return;
      
      try {
        this.isLoading = true;
        this.errorMessage = '';
        
        const newTodo = this.model.addTodo(this.newTodoTitle.trim());
        this.todos = this.model.getTodos();
        this.newTodoTitle = '';
        
      } catch (error) {
        this.errorMessage = 'í•  ì¼ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      } finally {
        this.isLoading = false;
      }
    },
    
    async updateTodo(todo) {
      try {
        const success = this.model.updateTodo(todo);
        if (success) {
          this.todos = this.model.getTodos();
        }
      } catch (error) {
        this.errorMessage = 'í•  ì¼ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      }
    },
    
    async deleteTodo(id) {
      try {
        const success = this.model.deleteTodo(id);
        if (success) {
          this.todos = this.model.getTodos();
        }
      } catch (error) {
        this.errorMessage = 'í•  ì¼ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      }
    },
    
    startEdit(todo) {
      todo.isEditing = true;
      todo.originalTitle = todo.title;
    },
    
    saveEdit(todo) {
      todo.isEditing = false;
      delete todo.originalTitle;
      this.updateTodo(todo);
    },
    
    cancelEdit(todo) {
      todo.title = todo.originalTitle;
      todo.isEditing = false;
      delete todo.originalTitle;
    }
  }
};
</script>

<style scoped>
.todo-app {
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
}

.add-todo {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.add-todo input {
  flex: 1;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.filters {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.filters button {
  padding: 8px 16px;
  border: 1px solid #ddd;
  background: white;
  border-radius: 4px;
  cursor: pointer;
}

.filters button.active {
  background: #007bff;
  color: white;
}

.stats {
  margin-bottom: 20px;
  padding: 15px;
  background: #f8f9fa;
  border-radius: 4px;
}

.progress-bar {
  width: 100%;
  height: 10px;
  background: #e9ecef;
  border-radius: 5px;
  overflow: hidden;
  margin-top: 10px;
}

.progress-fill {
  height: 100%;
  background: #28a745;
  transition: width 0.3s ease;
}

.todo-list {
  list-style: none;
  padding: 0;
}

.todo-list li {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  border: 1px solid #ddd;
  margin-bottom: 5px;
  border-radius: 4px;
}

.todo-list li.completed {
  opacity: 0.6;
}

.todo-list li span.completed {
  text-decoration: line-through;
}

.edit-input {
  flex: 1;
  padding: 5px;
  border: 1px solid #007bff;
  border-radius: 2px;
}

.delete-btn {
  background: #dc3545;
  color: white;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.loading, .error {
  text-align: center;
  padding: 10px;
  margin: 10px 0;
}

.error {
  color: #dc3545;
  background: #f8d7da;
  border-radius: 4px;
}
</style>
```

### ì˜ˆ: ì˜¨ë¼ì¸ ì‡¼í•‘ëª° ì œí’ˆ ëª©ë¡ (Angular)

```typescript
// Model - ì œí’ˆ ë°ì´í„° ê´€ë¦¬
export interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
  rating: number;
  imageUrl: string;
  inStock: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class ProductService {
  private apiUrl = 'https://api.example.com/products';
  
  constructor(private http: HttpClient) {}
  
  getProducts(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl);
  }
  
  getProductsByCategory(category: string): Observable<Product[]> {
    return this.http.get<Product[]>(`${this.apiUrl}?category=${category}`);
  }
  
  searchProducts(query: string): Observable<Product[]> {
    return this.http.get<Product[]>(`${this.apiUrl}?search=${query}`);
  }
}

// ViewModel - ì»´í¬ë„ŒíŠ¸ í´ë˜ìŠ¤
@Component({
  selector: 'app-product-list',
  template: `
    <div class="product-list-container">
      <h1>ì œí’ˆ ëª©ë¡</h1>
      
      <!-- ê²€ìƒ‰ ë° í•„í„° -->
      <div class="controls">
        <input 
          [(ngModel)]="searchQuery"
          (input)="onSearchChange()"
          placeholder="ì œí’ˆ ê²€ìƒ‰..."
          class="search-input"
        />
        
        <select [(ngModel)]="selectedCategory" (change)="onCategoryChange()">
          <option value="">ì „ì²´ ì¹´í…Œê³ ë¦¬</option>
          <option *ngFor="let category of categories" [value]="category">
            {{ category }}
          </option>
        </select>
        
        <select [(ngModel)]="sortBy" (change)="onSortChange()">
          <option value="name">ì´ë¦„ìˆœ</option>
          <option value="price">ê°€ê²©ìˆœ</option>
          <option value="rating">í‰ì ìˆœ</option>
        </select>
        
        <label>
          <input type="checkbox" [(ngModel)]="showOnlyInStock" (change)="filterProducts()">
          ì¬ê³  ìˆëŠ” ìƒí’ˆë§Œ
        </label>
      </div>
      
      <!-- ë¡œë”© ìƒíƒœ -->
      <div *ngIf="isLoading" class="loading">
        ì œí’ˆì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
      </div>
      
      <!-- ì—ëŸ¬ ìƒíƒœ -->
      <div *ngIf="errorMessage" class="error">
        {{ errorMessage }}
      </div>
      
      <!-- ì œí’ˆ í†µê³„ -->
      <div class="stats" *ngIf="!isLoading">
        <p>ì´ {{ filteredProducts.length }}ê°œ ì œí’ˆ (ì „ì²´ {{ allProducts.length }}ê°œ ì¤‘)</p>
        <p>í‰ê·  ê°€ê²©: {{ averagePrice | currency:'KRW':'symbol':'1.0-0' }}</p>
      </div>
      
      <!-- ì œí’ˆ ê·¸ë¦¬ë“œ -->
      <div class="product-grid" *ngIf="!isLoading">
        <div 
          *ngFor="let product of pagedProducts" 
          class="product-card"
          [class.out-of-stock]="!product.inStock"
        >
          <img [src]="product.imageUrl" [alt]="product.name" />
          <h3>{{ product.name }}</h3>
          <p class="category">{{ product.category }}</p>
          <div class="rating">
            <span *ngFor="let star of getStars(product.rating)">â­</span>
            <span>({{ product.rating }})</span>
          </div>
          <p class="price">{{ product.price | currency:'KRW':'symbol':'1.0-0' }}</p>
          <p *ngIf="!product.inStock" class="stock-status">í’ˆì ˆ</p>
          <button 
            [disabled]="!product.inStock" 
            (click)="addToCart(product)"
            class="add-to-cart-btn"
          >
            {{ product.inStock ? 'ì¥ë°”êµ¬ë‹ˆ ë‹´ê¸°' : 'í’ˆì ˆ' }}
          </button>
        </div>
      </div>
      
      <!-- í˜ì´ì§€ë„¤ì´ì…˜ -->
      <div class="pagination" *ngIf="totalPages > 1">
        <button 
          *ngFor="let page of getPages()" 
          [class.active]="page === currentPage"
          (click)="goToPage(page)"
        >
          {{ page }}
        </button>
      </div>
    </div>
  `,
  styleUrls: ['./product-list.component.css']
})
export class ProductListComponent implements OnInit {
  // ViewModel ì†ì„±ë“¤ - Viewì™€ ìë™ ë°”ì¸ë”©
  allProducts: Product[] = [];
  filteredProducts: Product[] = [];
  pagedProducts: Product[] = [];
  categories: string[] = [];
  
  searchQuery: string = '';
  selectedCategory: string = '';
  sortBy: string = 'name';
  showOnlyInStock: boolean = false;
  
  currentPage: number = 1;
  itemsPerPage: number = 12;
  
  isLoading: boolean = false;
  errorMessage: string = '';
  
  constructor(private productService: ProductService) {}
  
  ngOnInit(): void {
    this.loadProducts();
  }
  
  // ì»´í“¨í‹°ë“œ ì†ì„±ë“¤ (getterë¡œ êµ¬í˜„)
  get totalPages(): number {
    return Math.ceil(this.filteredProducts.length / this.itemsPerPage);
  }
  
  get averagePrice(): number {
    if (this.filteredProducts.length === 0) return 0;
    const total = this.filteredProducts.reduce((sum, p) => sum + p.price, 0);
    return total / this.filteredProducts.length;
  }
  
  // ì•¡ì…˜ ë©”ì„œë“œë“¤
  async loadProducts(): Promise<void> {
    try {
      this.isLoading = true;
      this.errorMessage = '';
      
      this.allProducts = await this.productService.getProducts().toPromise();
      this.categories = [...new Set(this.allProducts.map(p => p.category))];
      
      this.filterProducts();
      
    } catch (error) {
      this.errorMessage = 'ì œí’ˆì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.';
      console.error('Error loading products:', error);
    } finally {
      this.isLoading = false;
    }
  }
  
  onSearchChange(): void {
    // ë””ë°”ìš´ì‹±ì„ ìœ„í•œ íƒ€ì´ë¨¸
    clearTimeout(this.searchTimer);
    this.searchTimer = setTimeout(() => {
      this.filterProducts();
    }, 300);
  }
  
  onCategoryChange(): void {
    this.filterProducts();
  }
  
  onSortChange(): void {
    this.sortProducts();
    this.updatePagination();
  }
  
  filterProducts(): void {
    let filtered = [...this.allProducts];
    
    // ì¹´í…Œê³ ë¦¬ í•„í„°
    if (this.selectedCategory) {
      filtered = filtered.filter(p => p.category === this.selectedCategory);
    }
    
    // ê²€ìƒ‰ í•„í„°
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase();
      filtered = filtered.filter(p => 
        p.name.toLowerCase().includes(query) ||
        p.category.toLowerCase().includes(query)
      );
    }
    
    // ì¬ê³  í•„í„°
    if (this.showOnlyInStock) {
      filtered = filtered.filter(p => p.inStock);
    }
    
    this.filteredProducts = filtered;
    this.sortProducts();
    this.currentPage = 1; // í•„í„° ë³€ê²½ì‹œ ì²« í˜ì´ì§€ë¡œ
    this.updatePagination();
  }
  
  sortProducts(): void {
    this.filteredProducts.sort((a, b) => {
      switch (this.sortBy) {
        case 'price':
          return a.price - b.price;
        case 'rating':
          return b.rating - a.rating;
        case 'name':
        default:
          return a.name.localeCompare(b.name);
      }
    });
  }
  
  updatePagination(): void {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    this.pagedProducts = this.filteredProducts.slice(startIndex, endIndex);
  }
  
  goToPage(page: number): void {
    this.currentPage = page;
    this.updatePagination();
  }
  
  getPages(): number[] {
    return Array.from({ length: this.totalPages }, (_, i) => i + 1);
  }
  
  getStars(rating: number): string[] {
    return Array(Math.floor(rating)).fill('â­');
  }
  
  addToCart(product: Product): void {
    // ì¥ë°”êµ¬ë‹ˆ ì¶”ê°€ ë¡œì§
    console.log('ì¥ë°”êµ¬ë‹ˆì— ì¶”ê°€:', product.name);
  }
  
  private searchTimer: any;
}
```

## 4. ë‹¤ì–‘í•œ êµ¬í˜„ ë°©ì‹

### ë‹¨ë°©í–¥ ë°ì´í„° í”Œë¡œìš° (React + Redux)

```typescript
// ViewModel (Redux Store)
interface AppState {
  counter: {
    value: number;
    isLoading: boolean;
  };
}

// Actions
const increment = () => ({ type: 'INCREMENT' });
const decrement = () => ({ type: 'DECREMENT' });
const reset = () => ({ type: 'RESET' });

// Reducer
const counterReducer = (state = { value: 0, isLoading: false }, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, value: state.value + 1 };
    case 'DECREMENT':
      return { ...state, value: state.value - 1 };
    case 'RESET':
      return { ...state, value: 0 };
    default:
      return state;
  }
};

// View Component
const CounterView = () => {
  const { value, isLoading } = useSelector(state => state.counter);
  const dispatch = useDispatch();
  
  return (
    <div>
      <h1>ì¹´ìš´í„°: {value}</h1>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(reset())}>ë¦¬ì…‹</button>
    </div>
  );
};
```

### ì–‘ë°©í–¥ ë°ì´í„° ë°”ì¸ë”© (Angular)

```typescript
@Component({
  template: `
    <!-- ì–‘ë°©í–¥ ë°”ì¸ë”© -->
    <input [(ngModel)]="username" placeholder="ì‚¬ìš©ìëª…">
    <p>ì•ˆë…•í•˜ì„¸ìš”, {{ username }}ë‹˜!</p>
    
    <!-- ì´ë²¤íŠ¸ ë°”ì¸ë”© -->
    <button (click)="handleClick()">í´ë¦­</button>
    
    <!-- ì†ì„± ë°”ì¸ë”© -->
    <button [disabled]="isButtonDisabled">ì œì¶œ</button>
  `
})
export class MyComponent {
  username: string = '';
  isButtonDisabled: boolean = false;
  
  handleClick() {
    console.log('ë²„íŠ¼ í´ë¦­ë¨');
  }
}
```

### ë°˜ì‘í˜• ë°ì´í„° (Vue.js)

```javascript
// Vue 3 Composition API
export default {
  setup() {
    // ë°˜ì‘í˜• ë°ì´í„°
    const state = reactive({
      count: 0,
      message: 'Hello'
    });
    
    // ì»´í“¨í‹°ë“œ ì†ì„±
    const doubledCount = computed(() => state.count * 2);
    
    // ë©”ì„œë“œ
    const increment = () => {
      state.count++;
    };
    
    // ê°ì‹œì
    watch(() => state.count, (newVal, oldVal) => {
      console.log(`ì¹´ìš´íŠ¸ê°€ ${oldVal}ì—ì„œ ${newVal}ë¡œ ë³€ê²½ë¨`);
    });
    
    return {
      state,
      doubledCount,
      increment
    };
  }
};
```

## 5. ì¥ë‹¨ì 

| ì¥ì  | ì„¤ëª… |
|------|------|
| ìë™ UI ì—…ë°ì´íŠ¸ | ë°ì´í„° ë³€ê²½ ì‹œ Viewê°€ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë¨ |
| ê°œë°œ ìƒì‚°ì„± í–¥ìƒ | UI ì¡°ì‘ ì½”ë“œë¥¼ ì§ì ‘ ì‘ì„±í•  í•„ìš”ê°€ ì—†ìŒ |
| í…ŒìŠ¤íŠ¸ ìš©ì´ì„± | ViewModelì„ ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ |
| ê´€ì‹¬ì‚¬ ë¶„ë¦¬ | UI ë¡œì§ê³¼ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ëª…í™•íˆ ë¶„ë¦¬ë¨ |

| ë‹¨ì  | ì„¤ëª… |
|------|------|
| í”„ë ˆì„ì›Œí¬ ì˜ì¡´ì„± | ë°ì´í„° ë°”ì¸ë”©ì„ ì§€ì›í•˜ëŠ” í”„ë ˆì„ì›Œí¬ê°€ í•„ìš” |
| ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì¦ê°€ | ë°”ì¸ë”©ê³¼ ê°ì‹œ ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ì¸í•œ ì˜¤ë²„í—¤ë“œ |
| ë””ë²„ê¹… ë³µì¡ì„± | ìë™ ì—…ë°ì´íŠ¸ë¡œ ì¸í•´ ë°ì´í„° íë¦„ ì¶”ì ì´ ì–´ë ¤ìš¸ ìˆ˜ ìˆìŒ |
| ì„±ëŠ¥ ì´ìŠˆ | ëŒ€ëŸ‰ì˜ ë°ì´í„°ë‚˜ ë³µì¡í•œ ë°”ì¸ë”©ì—ì„œ ì„±ëŠ¥ ì €í•˜ ê°€ëŠ¥ |

## 6. í™œìš© ì˜ˆì‹œ

* React, Vue.js, Angular ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜
* WPF, UWP Windows ë°ìŠ¤í¬í†± ì• í”Œë¦¬ì¼€ì´ì…˜
* Xamarin ëª¨ë°”ì¼ ì• í”Œë¦¬ì¼€ì´ì…˜
* Flutter ì•± ê°œë°œ
* Svelte í”„ë ˆì„ì›Œí¬ ê¸°ë°˜ ì• í”Œë¦¬ì¼€ì´ì…˜

## MVVM Patternì„ ì‚¬ìš©í•˜ì§€ ë§ì•„ì•¼ í•  ê²½ìš°

* ì •ì ì¸ ì½˜í…ì¸ ë§Œ í‘œì‹œí•˜ëŠ” ë‹¨ìˆœí•œ í™”ë©´
* ë°ì´í„° ë°”ì¸ë”©ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë ˆê±°ì‹œ í™˜ê²½
* ì„±ëŠ¥ì´ ë§¤ìš° ì¤‘ìš”í•œ ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ (ê²Œì„ ì—”ì§„ ë‚´ë¶€ ë“±)
* ê°„ë‹¨í•œ ìŠ¤í¬ë¦½íŠ¸ë‚˜ ì¼íšŒì„± ë„êµ¬

> ì˜ˆ: ë‹¨ìˆœí•œ ëœë”© í˜ì´ì§€ë‚˜ ì •ì  ë¬¸ì„œ í˜ì´ì§€ì—ì„œëŠ” MVVMì˜ ë³µì¡ì„±ì´ ë¶ˆí•„ìš”í•  ìˆ˜ ìˆìŒ

## ìœ ì‚¬ íŒ¨í„´ê³¼ ë¹„êµ

### MVC Pattern (Model-View-Controller)
ì›¹ ì„œë²„ ì‚¬ì´ë“œì—ì„œ ì£¼ë¡œ ì‚¬ìš©ë˜ë©°, **Controllerê°€ ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³  Viewë¥¼ ì„ íƒ**í•˜ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.

**ì°¨ì´ì **: MVCëŠ” ì£¼ë¡œ ì„œë²„ ì‚¬ì´ë“œ, MVVMì€ í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œì—ì„œ ì‚¬ìš©ë˜ë©° ë°ì´í„° ë°”ì¸ë”©ì´ í•µì‹¬

### MVP Pattern (Model-View-Presenter)
**Presenterê°€ Viewì™€ Model ì‚¬ì´ì˜ ëª¨ë“  í†µì‹ ì„ ì¤‘ì¬**í•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

**ì°¨ì´ì **: MVPëŠ” ëª…ì‹œì  ë©”ì„œë“œ í˜¸ì¶œ, MVVMì€ ìë™ ë°ì´í„° ë°”ì¸ë”©ìœ¼ë¡œ ë™ì‘

### Flux/Redux Pattern
**ë‹¨ë°©í–¥ ë°ì´í„° í”Œë¡œìš°**ë¥¼ ê°•ì¡°í•˜ëŠ” ì•„í‚¤í…ì²˜ íŒ¨í„´ì…ë‹ˆë‹¤.

**ì°¨ì´ì **: FluxëŠ” Action â†’ Dispatcher â†’ Store â†’ Viewì˜ ë‹¨ë°©í–¥ íë¦„, MVVMì€ ì–‘ë°©í–¥ ë°”ì¸ë”© ê°€ëŠ¥

| í•­ëª© | MVVM Pattern | MVC Pattern | MVP Pattern | Flux Pattern |
|------|--------------|-------------|-------------|--------------|
| ë°ì´í„° íë¦„ | ì–‘ë°©í–¥ ë°”ì¸ë”© | Controller ì¤‘ì‹¬ | Presenter ì¤‘ì¬ | ë‹¨ë°©í–¥ í”Œë¡œìš° |
| View-Model ê´€ê³„ | ìë™ ë™ê¸°í™” | Controller ê²½ìœ  | ëª…ì‹œì  í˜¸ì¶œ | Action ê¸°ë°˜ |
| ì í•©í•œ í™˜ê²½ | SPA, ëª¨ë°”ì¼ ì•± | ì„œë²„ ì‚¬ì´ë“œ ì›¹ | ëª¨ë“  í”Œë«í¼ | React ìƒíƒœê³„ |
| í•™ìŠµ ê³¡ì„  | ì¤‘ê°„ | ë‚®ìŒ | ë†’ìŒ | ë†’ìŒ |

> í•µì‹¬ ì°¨ì´: MVVMì€ "ìë™ ë™ê¸°í™”"ë¥¼ ì¶”êµ¬, MVCëŠ” "ì—­í•  ë¶„ë‹´"ì„ ì¶”êµ¬, MVPëŠ” "ì™„ì „í•œ ë¶„ë¦¬"ë¥¼ ì¶”êµ¬, FluxëŠ” "ì˜ˆì¸¡ ê°€ëŠ¥í•œ ìƒíƒœ ê´€ë¦¬"ë¥¼ ì¶”êµ¬

## í•µì‹¬ ìš”ì•½

* MVVM íŒ¨í„´ì€ **ë°ì´í„° ë°”ì¸ë”©ì„ í†µí•œ ìë™ ë™ê¸°í™”**ê°€ í•µì‹¬ì¸ ì•„í‚¤í…ì²˜ íŒ¨í„´ì´ë‹¤.
* ViewModelì˜ ë°ì´í„°ê°€ ë³€ê²½ë˜ë©´ **Viewê°€ ìë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸**ëœë‹¤.
* **ì–‘ë°©í–¥ ë°ì´í„° ë°”ì¸ë”©**ìœ¼ë¡œ ì‚¬ìš©ì ì…ë ¥ë„ ìë™ìœ¼ë¡œ ViewModelì— ë°˜ì˜ëœë‹¤.
* ê°œë°œìëŠ” **UI ì¡°ì‘ë³´ë‹¤ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ì§‘ì¤‘**í•  ìˆ˜ ìˆë‹¤.

## ìš©ì–´ ì„¤ëª…

* **MVVM (Model-View-ViewModel)**: ë°ì´í„° ë°”ì¸ë”© ê¸°ë°˜ì˜ ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ ì•„í‚¤í…ì²˜ íŒ¨í„´
* **Model**: ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ë°ì´í„°ì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” ê³„ì¸µ
* **View**: ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ë¥¼ ë‹´ë‹¹í•˜ë©° ViewModelê³¼ ë°ì´í„° ë°”ì¸ë”©ìœ¼ë¡œ ì—°ê²°
* **ViewModel**: Viewì˜ ìƒíƒœì™€ í–‰ë™ì„ ê´€ë¦¬í•˜ë©° Modelê³¼ View ì‚¬ì´ì˜ ì–´ëŒ‘í„° ì—­í• 
* **ë°ì´í„° ë°”ì¸ë”© (Data Binding)**: Viewì™€ ViewModel ê°„ì˜ ë°ì´í„°ë¥¼ ìë™ìœ¼ë¡œ ë™ê¸°í™”í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜
* **ì–‘ë°©í–¥ ë°”ì¸ë”© (Two-Way Binding)**: ë°ì´í„° ë³€ê²½ì´ ì–‘ìª½ ëª¨ë‘ì— ìë™ìœ¼ë¡œ ë°˜ì˜ë˜ëŠ” ë°”ì¸ë”© ë°©ì‹
* **ë‹¨ë°©í–¥ ë°”ì¸ë”© (One-Way Binding)**: í•œ ë°©í–¥ìœ¼ë¡œë§Œ ë°ì´í„°ê°€ íë¥´ëŠ” ë°”ì¸ë”© ë°©ì‹
* **ë°˜ì‘í˜• í”„ë¡œê·¸ë˜ë° (Reactive Programming)**: ë°ì´í„°ì˜ ë³€í™”ì— ìë™ìœ¼ë¡œ ë°˜ì‘í•˜ëŠ” í”„ë¡œê·¸ë˜ë° íŒ¨ëŸ¬ë‹¤ì„
* **Observable**: ê´€ì°° ê°€ëŠ¥í•œ ë°ì´í„°ë¡œ, ê°’ì´ ë³€ê²½ë  ë•Œ ìë™ìœ¼ë¡œ êµ¬ë…ìë“¤ì—ê²Œ ì•Œë¦¼
* **Computed Property**: ë‹¤ë¥¸ ë°ì´í„°ì— ì˜ì¡´í•˜ì—¬ ìë™ìœ¼ë¡œ ê³„ì‚°ë˜ëŠ” ì†ì„±