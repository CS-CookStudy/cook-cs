# 7.7.1 Client-Server Model

## 1. 정의
클라이언트-서버 모델은 네트워크에서 서비스를 요청하는 **클라이언트(Client)** 와 요청을 처리하는 **서버(Server)** 로 역할을 분리한 아키텍처 구조이다.  
클라이언트는 리소스를 요청하고, 서버는 이를 제공하는 방식으로 동작한다.

### 역할 정의
- **클라이언트**: 서비스를 사용하는 주체 (서비스 소비자)
- **서버**: 서비스를 제공하는 주체 (서비스 제공자)

---

## 2. 구조와 동작 방식

### 기본 구조
```
[Client] → 요청(Request) → [Server]
[Client] ← 응답(Response) ← [Server]
```

### 상세 동작 과정
1. **연결 설정**: 클라이언트가 서버에 연결 요청
2. **인증/인가**: 서버가 클라이언트 신원 확인 (필요 시)
3. **요청 전송**: 클라이언트가 특정 서비스/데이터 요청
4. **요청 처리**: 서버가 요청을 분석하고 처리
5. **응답 전송**: 서버가 처리 결과를 클라이언트에 반환
6. **연결 종료**: 작업 완료 후 연결 해제 (또는 유지)

### 통신 특징
- **비대칭적 관계**: 클라이언트는 요청만, 서버는 응답만 담당
- **요청-응답 패턴**: 동기적 또는 비동기적 통신 가능
- **상태 관리**: Stateful(상태 유지) 또는 Stateless(무상태) 방식

---

## 3. 특징

### 핵심 특징
- **중앙 집중 관리**: 서버에서 데이터와 로직을 일괄적으로 관리
- **확장성**: 서버 자원을 확장(Scaling)하여 더 많은 클라이언트를 처리 가능
- **보안성**: 서버에서 접근 제어 및 인증/인가 수행 가능
- **표준화**: HTTP, TCP/IP 등 프로토콜 기반으로 상호작용

### 추가 특징
- **역할 분리**: 클라이언트는 UI/UX, 서버는 비즈니스 로직 담당
- **플랫폼 독립성**: 다양한 클라이언트가 동일한 서버에 접근 가능
- **데이터 일관성**: 중앙 서버에서 데이터 무결성 보장

---

## 4. 서버 확장 방식

### 1) 수직 확장 (Scale Up)
- **방법**: 서버 하드웨어 성능 향상 (CPU, RAM, Storage 업그레이드)
- **장점**: 구현 간단, 기존 아키텍처 유지
- **단점**: 비용 증가, 물리적 한계 존재

### 2) 수평 확장 (Scale Out)
- **방법**: 서버 개수 증가 (로드 밸런싱 활용)
- **장점**: 이론적 무제한 확장, 장애 분산
- **단점**: 구현 복잡, 데이터 동기화 이슈

```
Scale Up:     [Client] → [더 강한 Server]
Scale Out:    [Client] → [Load Balancer] → [Server1]
                                        → [Server2]
                                        → [Server3]
```

---

## 5. 장단점

| 구분 | 장점 | 단점 |
|------|------|------|
| **클라이언트-서버 모델** | - 중앙 집중 관리로 보안 및 유지보수 용이<br>- 다양한 클라이언트 지원 가능<br>- 서버 확장성 확보 가능<br>- 데이터 일관성 보장<br>- 백업 및 복구 용이 | - 서버 과부하 발생 시 성능 저하<br>- 서버 단일 장애점(SPOF) 위험<br>- 네트워크 의존성 높음<br>- 서버 비용 부담 |

---

## 6. 클라이언트-서버 vs 다른 모델

### vs P2P (Peer-to-Peer) 모델

| 구분 | Client-Server | P2P |
|------|---------------|-----|
| **구조** | 중앙 집중형 | 분산형 |
| **서버 역할** | 전용 서버 필요 | 각 노드가 서버 겸용 |
| **확장성** | 서버 성능에 의존 | 노드 증가에 따라 자연 확장 |
| **관리** | 중앙 관리 용이 | 분산 관리 어려움 |
| **보안** | 서버에서 통제 | 각 노드 개별 보안 |
| **예시** | 웹 서비스, 이메일 | BitTorrent, 블록체인 |

### vs Multi-tier Architecture

| 구분 | 2-tier (Client-Server) | 3-tier (Multi-tier) |
|------|------------------------|---------------------|
| **구조** | Client ↔ Server | Client ↔ App Server ↔ DB Server |
| **복잡도** | 단순 | 복잡 |
| **확장성** | 제한적 | 높음 |
| **유지보수** | 어려움 (클라이언트 배포) | 용이 (서버 측 변경) |

---

## 7. 실제 활용 예시

### 1) 웹 서비스
- **클라이언트**: 웹 브라우저 (Chrome, Firefox, Safari)
- **서버**: 웹 서버 (Apache, Nginx) + 애플리케이션 서버
- **프로토콜**: HTTP/HTTPS
- **특징**: Stateless, RESTful API

### 2) 모바일 앱
- **클라이언트**: 모바일 앱 (iOS, Android)
- **서버**: 백엔드 API 서버 (RESTful API, GraphQL)
- **통신**: JSON over HTTPS
- **특징**: 오프라인 지원, 푸시 알림

### 3) 이메일 서비스
- **클라이언트**: 메일 클라이언트 (Outlook, Gmail 앱)
- **서버**: 메일 서버 (SMTP, POP3, IMAP)
- **특징**: Store-and-Forward, 다양한 프로토콜

### 4) 데이터베이스 시스템
- **클라이언트**: 애플리케이션, DB 클라이언트 도구
- **서버**: DBMS (MySQL, PostgreSQL, Oracle)
- **특징**: ACID 보장, 트랜잭션 처리

### 5) 클라우드 서비스
- **클라이언트**: 웹 콘솔, CLI, SDK
- **서버**: 클라우드 인프라 (AWS, Azure, GCP)
- **특징**: API 기반, 자동 확장, 종량제

---

## 8. 현대적 변화

### 마이크로서비스 아키텍처
- **기존**: 하나의 큰 서버 (Monolithic)
- **현재**: 여러 작은 서비스들 (Microservices)
- **장점**: 독립 배포, 기술 스택 다양화, 장애 격리

### 서버리스 (Serverless)
- **개념**: 서버 관리 없이 코드만 배포
- **예시**: AWS Lambda, Azure Functions
- **특징**: 이벤트 기반, 자동 확장, 사용량 기반 과금

### 컨테이너화
- **기술**: Docker, Kubernetes
- **장점**: 일관된 배포 환경, 자원 효율성
- **특징**: 가벼운 가상화, 마이크로서비스 친화적

---

## 9. 핵심 요약

- **Client = 요청 / Server = 응답** 구조
- **중앙 집중 관리**로 효율적인 데이터 처리
- **장점**: 관리 용이, 보안 강화, 확장성
- **단점**: 서버 과부하, 단일 장애점 문제 존재
- **확장 방식**: Scale Up (수직) vs Scale Out (수평)
- **현대적 발전**: 마이크로서비스, 서버리스, 컨테이너화
- **다양한 활용**: 웹, 모바일, 이메일, DB, 클라우드 등
- **대안 모델**: P2P, Multi-tier와 비교하여 적절한 선택 필요