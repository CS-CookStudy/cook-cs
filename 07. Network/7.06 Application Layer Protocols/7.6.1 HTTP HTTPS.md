# 7.6.1 HTTP/HTTPS

## 1. HTTP 개요

---

### 정의
HTTP(HyperText Transfer Protocol)는 **웹에서 데이터를 주고받기 위한 응용 계층 프로토콜**이다.  
클라이언트(웹 브라우저)와 서버(웹 서버) 간의 요청-응답(Request-Response) 모델에 기반한다.

---

### 주요 특징

- **비연결성(Connectionless)**
  : 각 요청/응답은 독립적으로 처리되며, 연결은 요청 완료 후 종료된다.  
  (단, HTTP/1.1부터 Keep-Alive로 연결 유지 가능)
  - **무상태성(Stateless)**
  : 서버는 클라이언트 상태를 보존하지 않는다.  
  (세션, 쿠키, 토큰 등을 통해 상태 유지 가능)
  - **텍스트 기반 프로토콜**
  : 요청과 응답 메시지는 사람이 읽을 수 있는 ASCII 텍스트 형식
  - **기본 포트**: 80번

---

### 동작 방식

1. 클라이언트가 요청(Request) 전송
    - 메서드, URL, 헤더, 본문 포함
2. 서버가 응답(Response) 반환
    - 상태 코드, 헤더, 본문 포함

---

### 예시 (HTTP 요청/응답)
```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome/123.0
Accept: text/html

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1024

<html> ... </html>
```
---

## 2. HTTP 메서드

HTTP 메서드는 클라이언트가 서버에 요청하는 **행위(동작)**를 나타낸다.  
대표적으로 **CRUD(Create, Read, Update, Delete)** 작업에 대응된다.

### 주요 메서드

| 메서드 | 설명 | 특징/사용 예시 |
|--------|------|----------------|
| **GET** | 리소스 조회 | - 요청 데이터는 URL 쿼리스트링에 포함<br>- 멱등(Idempotent), 캐싱 가능 |
| **POST** | 리소스 생성/데이터 전송 | - 요청 본문에 데이터 포함<br>- 멱등 아님, 캐싱 불가 |
| **PUT** | 리소스 전체 수정 | - 지정 리소스를 요청 본문으로 대체<br>- 멱등 |
| **PATCH** | 리소스 부분 수정 | - 일부 필드만 수정<br>- 멱등 보장 안 될 수 있음 |
| **DELETE** | 리소스 삭제 | - 요청 시 리소스 제거<br>- 멱등 |
| **HEAD** | 헤더만 요청 | - 응답 본문 없이 헤더만 반환<br>- 리소스 유효성 검사 |
| **OPTIONS** | 지원 메서드 조회 | - 서버가 허용하는 메서드 확인 (CORS Preflight 요청에서 사용) |

---

### 멱등성(Idempotency)과 안전성(Safety)
- **멱등성**: 같은 요청을 여러 번 보내도 결과가 동일 (예: GET, PUT, DELETE)
- **안전성**: 리소스를 변경하지 않는 성질 (예: GET, HEAD, OPTIONS)

📌 예시:
- GET `/users/1` 여러 번 요청 → 결과 동일 → 멱등
- DELETE `/users/1` 여러 번 요청 → 첫 요청만 효과 있지만 이후 결과 동일 → 멱등
- POST `/users` 여러 번 요청 → 사용자 중복 생성 가능 → 멱등 아님

---

## 3. HTTP 상태 코드

HTTP 상태 코드는 서버가 클라이언트 요청에 대한 **처리 결과**를 알려주는 3자리 숫자다.  
1xx ~ 5xx 범위로 구분된다.

### 상태 코드 분류

| 범위 | 분류 | 설명 |
|------|------|------|
| **1xx** | Informational | 요청을 계속 진행 중임을 알림 |
| **2xx** | Success | 요청 성공 |
| **3xx** | Redirection | 리소스 위치 변경, 다른 경로로 접근 필요 |
| **4xx** | Client Error | 클라이언트 측 오류 |
| **5xx** | Server Error | 서버 측 오류 |

---

### 대표 상태 코드

#### 1xx (정보)
- **100 Continue**: 요청의 일부를 수신, 나머지 계속 전송하라
- **101 Switching Protocols**: 프로토콜 전환 (예: HTTP → WebSocket)

#### 2xx (성공)
- **200 OK**: 요청 성공
- **201 Created**: 새로운 리소스 생성
- **204 No Content**: 요청 성공했지만 반환할 본문 없음

#### 3xx (리다이렉션)
- **301 Moved Permanently**: 영구 이동 (리소스 위치 변경, SEO 중요)
- **302 Found**: 임시 이동
- **304 Not Modified**: 캐시된 리소스 사용 가능

#### 4xx (클라이언트 오류)
- **400 Bad Request**: 잘못된 요청 (문법 오류 등)
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 리소스 없음

#### 5xx (서버 오류)
- **500 Internal Server Error**: 서버 내부 오류
- **502 Bad Gateway**: 게이트웨이/프록시 서버의 잘못된 응답
- **503 Service Unavailable**: 서버 과부하 또는 점검 중
- **504 Gateway Timeout**: 게이트웨이/프록시 서버의 응답 시간 초과

---

### 핵심 요약
- 상태 코드는 **요청 결과**를 5개 범주(1xx~5xx)로 표현
- **2xx: 성공 / 4xx: 클라이언트 오류 / 5xx: 서버 오류**
- 실무에서 자주 마주치는 코드: **200, 201, 301, 302, 304, 400, 401, 403, 404, 500, 502, 503**

---

## 4. HTTP 헤더와 쿠키

### 1) HTTP 헤더

HTTP 메시지는 **요청(Request) 헤더**와 **응답(Response) 헤더**로 구성된다.  
헤더는 클라이언트와 서버 간의 부가 정보를 전달한다.

#### (1) 일반 헤더 (공통)
- `Date`: 메시지 생성 시각
- `Connection`: 연결 옵션 (Keep-Alive, close)
- `Cache-Control`: 캐시 정책 (no-cache, max-age)

#### (2) 요청(Request) 헤더
- `Host`: 요청 대상 호스트 (필수, HTTP/1.1부터)
- `User-Agent`: 클라이언트 정보 (브라우저, 앱 등)
- `Accept`: 클라이언트가 수신 가능한 데이터 타입
- `Authorization`: 인증 토큰/자격 증명
- `Cookie`: 클라이언트가 가진 쿠키 전송

#### (3) 응답(Response) 헤더
- `Server`: 서버 애플리케이션 정보
- `Set-Cookie`: 클라이언트에 쿠키 저장 지시
- `Content-Type`: 응답 본문의 데이터 타입
- `Content-Length`: 응답 본문의 길이
- `Location`: 리다이렉션 대상 URL (3xx 응답 시)

---

### 2) 쿠키(Cookie)

#### 정의
- 서버가 클라이언트(브라우저)에 저장하는 **작은 데이터 조각**
- 무상태성(Stateless) HTTP의 한계를 보완하여 상태를 유지하는 방식

#### 동작 원리
1. 클라이언트가 최초 요청 → 서버가 `Set-Cookie` 헤더 전송
2. 브라우저가 쿠키를 저장
3. 이후 동일 서버 요청 시 `Cookie` 헤더에 담아 자동 전송

#### 특징
- 쿠키에는 세션 ID, 사용자 인증 정보 등 저장 가능
- 보안 이슈: 클라이언트 저장이므로 탈취/위변조 위험
- 옵션: `HttpOnly`, `Secure`, `SameSite` 속성으로 보안 강화

---

### 3) 세션(Session)과의 관계
- **쿠키**: 클라이언트 로컬에 저장되는 데이터
- **세션**: 서버 메모리/DB에 저장, 클라이언트는 세션 ID 쿠키만 보관
- 일반적으로 **쿠키 = 세션 ID 전달용**, **실제 상태 = 서버 세션에 저장**

---

## 5. HTTPS와 SSL/TLS

### 1) HTTPS 정의
- HTTPS(HyperText Transfer Protocol Secure)는 **HTTP + 보안 계층(SSL/TLS)** 조합
- 기본 포트: **443**
- 암호화, 무결성, 인증을 제공하여 안전한 웹 통신 가능

---

### 2) SSL/TLS의 역할
1. **암호화 (Confidentiality)**
    - 데이터가 중간에서 도청되어도 내용을 알 수 없도록 암호화
    - 대칭키 암호화 방식 사용 (AES 등)

2. **무결성 (Integrity)**
    - 전송 중 데이터가 변조되지 않았음을 보장
    - 메시지 인증 코드(MAC), 해시(Hash) 활용

3. **인증 (Authentication)**
    - 서버(또는 클라이언트)의 신원을 디지털 인증서로 검증
    - CA(Certificate Authority)가 발급한 인증서 사용

---

### 3) SSL/TLS 동작 과정 (Handshake 간략 흐름)
1. **ClientHello**: 클라이언트가 지원 암호화 알고리즘, 난수 전송
2. **ServerHello**: 서버가 선택한 암호화 알고리즘, 인증서 전송
3. **인증서 검증**: 클라이언트가 CA 서명 확인, 서버 신원 검증
4. **세션키 교환**: Diffie-Hellman, RSA 등으로 대칭키 생성/교환
5. **Finished**: 세션키로 암호화된 통신 시작

---

### 4) HTTPS의 장점
- 기밀성, 무결성, 인증 보장
- 브라우저 보안 경고 방지 (HTTPS 의무화 추세)
- SEO(검색 엔진 최적화) 측면에서도 유리

### 5) 단점
- 암호화/복호화 과정으로 오버헤드 발생
- 인증서 발급/갱신 필요
- 초기 연결(Handshake)에서 지연(latency) 증가

---

### 핵심 요약
- **HTTP**는 평문, **HTTPS**는 SSL/TLS로 보안 강화
- SSL/TLS는 **암호화, 무결성, 인증** 제공
- HTTPS는 현대 웹 서비스에서 사실상 필수

---

## 6. HTTP/1.1 vs HTTP/2 vs HTTP/3

### 1) HTTP/1.1

- **지속 연결 (Persistent Connection, Keep-Alive)**
  : 여러 요청/응답을 하나의 TCP 연결에서 처리 가능
  - **파이프라이닝(Pipelining)** 지원
  : 여러 요청을 동시에 보낼 수 있으나, 응답 순서 문제(Head-of-line blocking)로 제한적
  - **헤더 중복 문제**: 같은 헤더가 반복 전송되어 비효율

---

### 2) HTTP/2

- **멀티플렉싱(Multiplexing)**
  : 하나의 TCP 연결에서 여러 요청/응답을 동시에 처리 → HOLB 완화
  - **이진 프레이밍(Binary Framing)**
  : 요청/응답을 프레임 단위로 분리 → 효율적 전송
  - **헤더 압축(HPACK)**
  : 중복 헤더 압축 → 대역폭 절약
  - **서버 푸시(Server Push)**
  : 클라이언트 요청 전에 리소스를 미리 전송 가능

---

### 3) HTTP/3

- **QUIC 프로토콜 기반**
  : TCP 대신 **UDP 위에서 동작**
  - **0-RTT 연결**
  : 재연결 시 핸드셰이크 생략 → 지연 최소화
  - **HOLB 완전 해소**
  : 스트림 단위 독립 전송, 한 스트림 손실이 다른 스트림에 영향 X
  - **보안 기본 내장**
  : QUIC에 TLS 1.3이 포함되어 별도 협상 불필요

---

### 비교 표

| 구분 | HTTP/1.1 | HTTP/2 | HTTP/3 |
|------|----------|--------|--------|
| 전송 기반 | TCP | TCP | UDP(QUIC) |
| 병렬 처리 | 파이프라이닝(제한적) | 멀티플렉싱 | 멀티플렉싱 (스트림 독립) |
| 헤더 처리 | 반복 전송 | HPACK 압축 | QPACK 압축 |
| HOLB 문제 | 존재 | TCP 수준에서는 여전 | 해결 |
| 보안 | 선택적(TLS) | TLS 권장 | TLS 1.3 내장 |
| 추가 기능 | 없음 | 서버 푸시 | 0-RTT 핸드셰이크 |

---

### 핵심 요약
- **HTTP/1.1**: Keep-Alive로 개선했지만 HOLB 문제 존재
- **HTTP/2**: 멀티플렉싱, 헤더 압축, 서버 푸시로 성능 개선
- **HTTP/3**: QUIC 기반으로 TCP 한계 극복, 지연 최소화 및 HOLB 해소
