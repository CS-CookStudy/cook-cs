# 7.8.2 RESTful API 설계

## 1. 기본 원칙
- **리소스(Resource) 중심**: 모든 것은 자원이며, 고유한 URI로 식별해야 함
- **명사 기반 URI**: 동사를 사용하지 않고, 리소스를 나타내는 명사 사용
- **HTTP 메서드 활용**: CRUD 기능은 메서드로 구분 (GET, POST, PUT, DELETE 등)
- **무상태성**: 각 요청은 필요한 모든 정보를 포함해야 하며, 서버는 상태를 저장하지 않음

---

## 2. URI 설계 규칙

### 기본 규칙
- **소문자 사용** (`/users`, `/products/123`)
- **복수형 권장** (`/users`, `/orders`)
- **하이픈(-) 사용, 언더스코어(_) 지양** (`/user-profiles`, `/order-items`)
- **계층적 구조 표현** (`/users/123/orders`)
- **확장자 사용 지양** (`.json`, `.xml` 대신 `Accept` 헤더 활용)

### 올바른 vs 잘못된 예시

| 구분 | 올바른 예시 | 잘못된 예시 |
|------|-------------|-------------|
| **리소스 중심** | `GET /users/123` | `GET /getUser/123` |
| **복수형** | `GET /users` | `GET /user` |
| **계층 구조** | `GET /users/123/orders` | `GET /getUserOrders/123` |
| **하이픈 사용** | `/user-profiles` | `/user_profiles` |

---

## 3. CRUD 매핑과 예시

### 기본 CRUD 작업
```text
GET    /users            → 사용자 목록 조회
POST   /users            → 사용자 생성
GET    /users/123        → 특정 사용자 조회
PUT    /users/123        → 특정 사용자 전체 수정
PATCH  /users/123        → 특정 사용자 부분 수정
DELETE /users/123        → 특정 사용자 삭제
```

### 관계 리소스 처리
```text
GET    /users/123/orders       → 특정 사용자의 주문 목록
POST   /users/123/orders       → 특정 사용자의 새 주문 생성
GET    /users/123/orders/456   → 특정 사용자의 특정 주문 조회
```

---

## 4. 쿼리 파라미터 활용

### 페이징
```text
GET /users?page=1&size=10          → 1페이지, 10개씩
GET /users?offset=20&limit=10      → 20번째부터 10개
```

### 정렬
```text
GET /users?sort=name               → 이름 오름차순
GET /users?sort=name,desc          → 이름 내림차순
GET /users?sort=name&sort=age,desc → 이름 오름차순, 나이 내림차순
```

### 필터링
```text
GET /users?status=active           → 활성 사용자만
GET /users?age_min=18&age_max=65   → 18세~65세
GET /users?search=john             → 이름에 'john' 포함
```

---

## 5. HTTP 상태 코드 활용

### 성공 응답
- **200 OK**: GET, PUT, PATCH 성공
- **201 Created**: POST로 리소스 생성 성공
- **204 No Content**: DELETE 성공, 응답 본문 없음

### 클라이언트 오류
- **400 Bad Request**: 잘못된 요청 형식
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 리소스 없음
- **409 Conflict**: 리소스 충돌 (중복 생성 시도 등)

### 서버 오류
- **500 Internal Server Error**: 서버 내부 오류

---

## 6. 에러 응답 표준화

### 일관된 에러 형식
```json
{
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "해당 사용자를 찾을 수 없습니다.",
    "details": {
      "user_id": 123
    }
  }
}
```

### 검증 오류 응답
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력값이 올바르지 않습니다.",
    "details": [
      {
        "field": "email",
        "message": "이메일 형식이 올바르지 않습니다."
      }
    ]
  }
}
```

---

## 7. HATEOAS (Hypermedia as the Engine of Application State)

### 개념
- REST의 확장 개념: 응답에 **다음 가능한 액션의 링크 정보** 포함
- 클라이언트가 서버 응답을 기반으로 동적 동작 가능

### 예시
```json
{
  "id": 123,
  "name": "Alice",
  "status": "active",
  "_links": {
    "self": { "href": "/users/123" },
    "orders": { "href": "/users/123/orders" },
    "edit": { "href": "/users/123", "method": "PUT" },
    "delete": { "href": "/users/123", "method": "DELETE" }
  }
}
```

### 실무 활용도
- **이론적으로는 완벽**하지만 **실제로는 구현 복잡도** 때문에 잘 사용되지 않음
- 대부분의 REST API는 HATEOAS 없이도 충분히 사용 가능

---

## 8. 설계 시 고려 사항

### 필수 고려사항
- **일관된 네이밍 규칙** 유지
- **버전 관리 전략** 수립
- **인증/인가** 방식 결정 (JWT, OAuth 2.0 등)
- **페이징/정렬** 표준 정의
- **에러 응답** 형식 통일

### 성능 최적화
- **적절한 HTTP 캐싱** 활용
- **불필요한 데이터 전송** 최소화
- **N+1 쿼리 문제** 방지

---

## 9. 핵심 요약
- **리소스 중심 설계**로 명사 기반 URI 사용
- **HTTP 메서드와 상태 코드**를 표준에 맞게 활용
- **일관된 네이밍 규칙**과 **에러 응답 형식** 유지
- **쿼리 파라미터**로 페이징, 정렬, 필터링 처리
- **HATEOAS**는 이론적으로 완벽하지만 실무에서는 선택적 적용