# 7.8.4 API 버전 관리

## 1. 정의와 필요성

### 정의
API 버전 관리는 API의 변경사항을 체계적으로 관리하여 **기존 클라이언트의 호환성을 보장**하는 방법이다.

### 필요성
API는 지속적으로 발전하면서 기능이 추가되거나 구조가 변경된다. 이때 기존에 API를 사용하던 앱이나 서비스가 갑자기 작동하지 않으면 큰 문제가 발생한다.

**예시 상황:**
```json
// 기존 v1 API 응답
{
  "name": "홍길동",
  "age": 25
}

// 새로운 v2 API 응답 (name을 firstName, lastName으로 분리)
{
  "firstName": "길동",
  "lastName": "홍", 
  "age": 25
}
```

만약 버전 관리 없이 v1을 v2로 바로 바꾸면, 기존의 모든 클라이언트에서 `name` 필드를 찾지 못해 오류가 발생한다.

---

## 2. 버전 업그레이드 기준

### Breaking Change (호환성을 깨는 변경)
다음과 같은 변경사항이 있을 때는 **반드시 새로운 버전**을 만들어야 한다:

- **기존 필드 제거**: `name` 필드 삭제
- **필드 이름 변경**: `name` → `userName`
- **데이터 타입 변경**: `"25"` (문자열) → `25` (숫자)
- **필수 파라미터 추가**: 기존에 없던 필수 입력값 추가
- **URL 구조 변경**: `/users` → `/members`
- **HTTP 메서드 변경**: `GET /users` → `POST /users/search`

### Non-breaking Change (호환성을 유지하는 변경)
다음 변경사항은 **동일 버전 내에서 처리** 가능하다:

- **새 필드 추가**: 기존 필드는 그대로 두고 `email` 필드 추가
- **선택적 파라미터 추가**: 기본값이 있는 옵션 파라미터
- **새로운 엔드포인트 추가**: 기존 API에 영향 없는 새 기능
- **응답 성능 개선**: 기능은 같지만 속도 향상

---

## 3. 버전 관리 방식

### 1) URI 버전 관리
버전 정보를 URL 경로에 포함하는 방식이다.

```text
GET /api/v1/users
GET /api/v2/users
GET /api/v3/users
```

**장점:**
- 직관적이고 이해하기 쉬움
- 브라우저에서 바로 테스트 가능
- 캐싱 정책 적용이 간단

**단점:**
- URL이 길어짐
- 여러 버전을 동시에 관리해야 하는 부담

### 2) 헤더 기반 버전 관리
HTTP 헤더에 버전 정보를 포함하는 방식이다.

```text
GET /users
Accept: application/vnd.example.v2+json
```

또는

```text
GET /users
API-Version: 2
```

**장점:**
- URL이 깔끔하고 RESTful 원칙에 부합
- 콘텐츠 협상(Content Negotiation) 활용 가능

**단점:**
- 클라이언트 구현이 복잡
- 브라우저에서 직접 테스트하기 어려움

### 3) 쿼리 파라미터 방식
요청 파라미터에 버전 정보를 포함하는 방식이다.

```text
GET /users?version=2
GET /users?v=2
```

**장점:**
- 구현이 가장 간단
- 기존 시스템에 쉽게 추가 가능

**단점:**
- REST 원칙에 어긋남 (리소스 식별자에 버전 정보가 섞임)
- URL 파라미터가 복잡해질 수 있음

### 방식별 비교

| 방식 | 직관성 | 구현 난이도 | REST 원칙 | 실제 사용도 |
|------|--------|-------------|-----------|------------|
| URI | 높음 | 보통 | 보통 | 높음 |
| 헤더 | 낮음 | 높음 | 높음 | 보통 |
| 쿼리 파라미터 | 보통 | 낮음 | 낮음 | 낮음 |

### Semantic Versioning (시맨틱 버저닝)
실제 개발에서는 더 세밀한 버전 관리를 위해 시맨틱 버저닝을 사용하기도 한다.

```text
Major.Minor.Patch (예: v2.1.3)
```

- **Major (2)**: Breaking Changes (호환성 깨짐)
- **Minor (1)**: 새 기능 추가 (호환성 유지)
- **Patch (3)**: 버그 수정

대부분의 공개 API에서는 Major 버전만 URL에 포함하고, Minor/Patch는 내부적으로 관리한다.

---

## 4. 구버전 폐기 정책

### 단계적 폐기 프로세스
구버전을 갑자기 없애면 클라이언트에서 문제가 발생하므로, 충분한 기간을 두고 단계별로 진행해야 한다.

#### 1) 공지 단계
- 구버전 사용 중단 예정 공지
- 새 버전으로 마이그레이션 가이드 제공
- 개발자 문서 및 공식 블로그에 안내

#### 2) 경고 단계
- API 응답 헤더에 deprecation 정보 포함
```text
Deprecation: true
Sunset: "2024-12-31T23:59:59Z"
```
- API 응답에 경고 메시지 추가
```json
{
  "data": { ... },
  "warnings": [
    "API v1 will be deprecated on 2024-12-31. Please migrate to v2."
  ]
}
```

#### 3) 제한 단계
- 구버전 API의 요청 속도 제한 강화
- 새로운 클라이언트 등록 차단
- 기존 클라이언트에게 개별 연락

#### 4) 완전 폐기
- 구버전 API 서비스 완전 중단
- 404 Not Found 또는 410 Gone 응답

### 클라이언트 지원
- **명확한 마이그레이션 문서** 제공
- **버전별 차이점** 상세 설명
- **코드 예시**와 **변경 사항** 안내
- **기술 지원 채널** 운영

### API Gateway 활용
현대의 많은 서비스에서는 API Gateway를 통해 버전 관리를 자동화한다.

- **AWS API Gateway**: 라우팅 규칙으로 버전별 트래픽 분산
- **Kong**: 플러그인 기반 버전 관리 및 라우팅
- **NGINX**: 설정 파일로 버전별 upstream 서버 연결

API Gateway를 사용하면 애플리케이션 코드 변경 없이도 버전 관리가 가능하다.

---

## 5. 핵심 요약

- API 버전 관리는 **기존 클라이언트 보호**를 위해 필수
- **호환성을 깨는 변경**이 있을 때만 새 버전 생성
- **URI 버전 관리**가 가장 직관적이고 널리 사용됨
- 구버전 폐기는 **6개월 이상 여유**를 두고 단계적으로 진행
- 클라이언트가 **안전하게 마이그레이션**할 수 있도록 충분한 지원 제공