# 7.8.5 GraphQL vs REST

## 1. GraphQL이란?

### 정의
GraphQL은 Facebook에서 개발한 **쿼리 언어 기반 API**다. 클라이언트가 "어떤 데이터를 원하는지" 정확히 명시해서 요청하면, 서버가 그 요청에 맞춰 응답을 만들어준다.

### REST와의 핵심 차이
**REST**: 서버가 정해놓은 데이터를 받아야 함  
**GraphQL**: 클라이언트가 원하는 데이터만 요청해서 받을 수 있음

### 실제 예시로 보는 차이

**상황**: 사용자 이름과 최근 주문 3개를 가져오고 싶다

#### REST 방식
```text
1. GET /users/123        → { id: 123, name: "홍길동", email: "...", age: 25, ... }
2. GET /users/123/orders → [ 주문1, 주문2, 주문3, 주문4, 주문5, ... ]
```
- **2번의 요청** 필요
- **불필요한 데이터**(email, age, 주문4~5)도 함께 받음

#### GraphQL 방식
```graphql
query {
  user(id: 123) {
    name
    orders(limit: 3) {
      id
      date
      amount
    }
  }
}
```
- **1번의 요청**으로 완료
- **필요한 데이터만** 정확히 받음

---

## 2. 핵심 차이점

### Over-fetching & Under-fetching 문제

#### Over-fetching (불필요한 데이터 받기)
**REST 예시:**
```json
// 사용자 이름만 필요한데 모든 정보를 받아야 함
GET /users/123
{
  "id": 123,
  "name": "홍길동",        // ← 이것만 필요
  "email": "hong@...",     // ← 불필요
  "phone": "010-...",      // ← 불필요
  "address": "서울...",     // ← 불필요
  "birthDate": "1990-..." // ← 불필요
}
```

**GraphQL 해결:**
```graphql
query {
  user(id: 123) {
    name  # 이것만 받음
  }
}
```

#### Under-fetching (데이터 부족)
**REST 예시:**
```text
사용자 정보 + 주문 정보 + 리뷰 정보가 필요한 경우
1. GET /users/123
2. GET /users/123/orders  
3. GET /users/123/reviews
```
총 3번의 요청이 필요함

**GraphQL 해결:**
```graphql
query {
  user(id: 123) {
    name
    orders { id, date }
    reviews { rating, content }
  }
}
```
1번의 요청으로 모든 데이터 획득

### 엔드포인트 관리

**REST**: 기능별로 여러 엔드포인트
```text
GET /users
GET /users/123
GET /users/123/orders
GET /users/123/reviews
POST /users
PUT /users/123
DELETE /users/123
```

**GraphQL**: 단일 엔드포인트
```text
POST /graphql  (모든 요청)
```

---

## 3. 장단점 비교

### REST 장단점

**장점:**
- **학습이 쉬움**: HTTP 표준을 그대로 사용
- **캐싱이 간단**: HTTP 캐싱 메커니즘 활용 가능
- **도구 지원**: 개발 도구, 모니터링 도구가 풍부
- **단순한 구조**: 엔드포인트별로 명확한 역할

**단점:**
- **Over-fetching**: 불필요한 데이터 전송
- **Under-fetching**: 여러 번 요청 필요
- **엔드포인트 증가**: 복잡한 요구사항 시 API 개수 폭증
- **버전 관리**: 변경 시 새 버전 필요

### GraphQL 장단점

**장점:**
- **정확한 데이터**: 필요한 것만 요청/응답
- **유연한 쿼리**: 다양한 클라이언트 요구사항 대응
- **단일 엔드포인트**: API 관리 복잡도 감소
- **버전 관리 불필요**: 스키마 확장으로 호환성 유지

**단점:**
- **학습 곡선**: 쿼리 언어와 스키마 설계 학습 필요
- **캐싱 복잡**: HTTP 캐싱 적용하기 어려움
- **서버 부하**: 복잡한 쿼리 시 성능 이슈 가능
- **도구 부족**: REST 대비 개발 도구가 제한적

---

## 4. 언제 뭘 쓸까?

### REST를 선택하는 경우

**단순한 CRUD 서비스**
```text
- 블로그 시스템 (글 목록, 글 보기, 글 쓰기)
- 회원 관리 시스템 (가입, 수정, 탈퇴)
- 파일 업로드/다운로드 서비스
```

**표준 HTTP 활용이 중요한 경우**
- 캐싱이 중요한 서비스
- 기존 HTTP 인프라 활용
- 단순한 API 구조

**팀 학습 비용을 줄이고 싶은 경우**
- HTTP/REST에 익숙한 팀
- 빠른 개발이 필요한 프로젝트

### GraphQL을 선택하는 경우

**다양한 클라이언트 환경**
```text
- 모바일: 이름, 프로필 사진만 필요
- 웹: 상세한 사용자 정보 + 주문 내역
- 관리자: 모든 정보 + 통계 데이터
```

**복잡한 데이터 관계**
```text
사용자 → 주문 → 상품 → 카테고리 → 리뷰
이런 연관된 데이터를 한 번에 가져와야 하는 경우
```

**네트워크 효율성이 중요한 경우**
- 모바일 앱 (데이터 사용량 최소화)
- 해외 서비스 (네트워크 지연 최소화)

### 실제 기업 사례

**REST 주로 사용:**
- **단순한 서비스**: 대부분의 스타트업, 중소 서비스
- **공개 API**: Twitter API, GitHub API

**GraphQL 주로 사용:**
- **Facebook**: 다양한 클라이언트 환경
- **GitHub API v4**: 복잡한 데이터 관계
- **Shopify**: 이커머스 플랫폼의 유연한 데이터 요청

**혼합 사용:**
- **Netflix**: 내부는 GraphQL, 외부 파트너는 REST
- **Airbnb**: 모바일은 GraphQL, 웹은 REST

---

## 5. 핵심 요약

- **REST**: 단순하고 직관적, HTTP 표준 활용, 캐싱 용이
- **GraphQL**: 유연하고 효율적, 필요한 데이터만 전송, 복잡한 관계 처리
- **선택 기준**: 서비스 복잡도, 클라이언트 다양성, 팀 역량을 고려
- **실무에서는** 상황에 따라 두 방식을 혼합해서 사용하는 경우가 많음
- 둘 다 **장단점이 명확**하므로 무조건 좋고 나쁨은 없음