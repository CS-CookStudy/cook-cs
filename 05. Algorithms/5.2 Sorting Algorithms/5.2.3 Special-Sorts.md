# 특수 정렬 알고리즘 (Special Sorting Algorithms)

## 1. 계수 정렬 (Counting Sort)

### 알고리즘 원리
데이터의 값 범위가 제한적일 때 사용하는 비교 기반이 아닌(non-comparative) 정렬 알고리즘이다. 각 원소의 개수를 세어 카운트 배열에 저장한 후, 이를 바탕으로 정렬된 배열을 생성한다.

**동작 과정:**
1. 입력 배열에서 최댓값을 찾아 카운트 배열 크기 결정
2. 각 값의 출현 횟수를 카운트 배열에 저장
3. 카운트 배열의 누적합을 계산 (각 값의 최종 위치 정보)
4. 뒤에서부터 입력 배열을 순회하며 출력 배열에 배치

### 시간/공간 복잡도
- **시간 복잡도**:
    - 모든 경우: O(n + k) - **n은 원소 개수, k는 값의 범위**
      > 이유: 카운트 배열 생성 O(k) + 입력 배열 순회 O(n) + 출력 생성 O(n)
        - **k가 n보다 훨씬 작을 때 O(n)에 가까운 성능**
        - **k가 n²보다 클 때는 비효율적**
- **공간 복잡도**: O(n + k) - **카운트 배열 + 출력 배열**
  > 이유: 크기 k인 카운트 배열과 크기 n인 출력 배열 필요

### 구현

#### Python
```python
def counting_sort(arr):
    if not arr:
        return arr
    
    # 최댓값과 최솟값 찾기 (음수 처리를 위해)
    max_val = max(arr)
    min_val = min(arr)
    range_size = max_val - min_val + 1
    
    # 카운트 배열 초기화
    count = [0] * range_size
    output = [0] * len(arr)
    
    # 각 원소의 개수 세기
    for num in arr:
        count[num - min_val] += 1
    
    # 누적합 계산 (각 값의 최종 위치 정보)
    for i in range(1, range_size):
        count[i] += count[i - 1]
    
    # 뒤에서부터 순회하며 안정 정렬 구현
    for i in range(len(arr) - 1, -1, -1):
        output[count[arr[i] - min_val] - 1] = arr[i]
        count[arr[i] - min_val] -= 1
    
    return output

# 간단 버전 (안정성 보장 안됨)
def counting_sort_simple(arr):
    if not arr:
        return arr
    
    max_val = max(arr)
    count = [0] * (max_val + 1)
    
    # 개수 세기
    for num in arr:
        count[num] += 1
    
    # 결과 생성
    result = []
    for i in range(len(count)):
        result.extend([i] * count[i])
    
    return result

# 사용 예시
numbers = [4, 2, 2, 8, 3, 3, 1]
print("정렬 전:", numbers)
sorted_numbers = counting_sort(numbers)
print("정렬 후:", sorted_numbers)
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void countingSort(std::vector<int>& arr) {
    if (arr.empty()) return;
    
    // 최댓값과 최솟값 찾기
    int max_val = *std::max_element(arr.begin(), arr.end());
    int min_val = *std::min_element(arr.begin(), arr.end());
    int range = max_val - min_val + 1;
    
    // 카운트 배열 초기화
    std::vector<int> count(range, 0);
    std::vector<int> output(arr.size());
    
    // 각 원소의 개수 세기
    for (int num : arr) {
        count[num - min_val]++;
    }
    
    // 누적합 계산
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }
    
    // 뒤에서부터 순회하며 안정 정렬 구현
    for (int i = arr.size() - 1; i >= 0; i--) {
        output[count[arr[i] - min_val] - 1] = arr[i];
        count[arr[i] - min_val]--;
    }
    
    // 결과 복사
    for (int i = 0; i < arr.size(); i++) {
        arr[i] = output[i];
    }
}

// 사용 예시
int main() {
    std::vector<int> numbers = {4, 2, 2, 8, 3, 3, 1};
    
    std::cout << "정렬 전: ";
    for (int num : numbers) std::cout << num << " ";
    
    countingSort(numbers);
    
    std::cout << "\n정렬 후: ";
    for (int num : numbers) std::cout << num << " ";
    
    return 0;
}
```

#### Java
```java
import java.util.Arrays;

public class CountingSort {
    public static void countingSort(int[] arr) {
        if (arr.length == 0) return;
        
        // 최댓값과 최솟값 찾기
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int range = max - min + 1;
        
        // 카운트 배열 초기화
        int[] count = new int[range];
        int[] output = new int[arr.length];
        
        // 각 원소의 개수 세기
        for (int num : arr) {
            count[num - min]++;
        }
        
        // 누적합 계산
        for (int i = 1; i < range; i++) {
            count[i] += count[i - 1];
        }
        
        // 뒤에서부터 순회하며 안정 정렬 구현
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - min] - 1] = arr[i];
            count[arr[i] - min]--;
        }
        
        // 결과 복사
        System.arraycopy(output, 0, arr, 0, arr.length);
    }
    
    // 사용 예시
    public static void main(String[] args) {
        int[] numbers = {4, 2, 2, 8, 3, 3, 1};
        
        System.out.println("정렬 전: " + Arrays.toString(numbers));
        countingSort(numbers);
        System.out.println("정렬 후: " + Arrays.toString(numbers));
    }
}
```

### 특징 및 쓰면 좋은 경우

**장점:**
- 선형 시간 O(n + k)으로 매우 빠름
- 안정 정렬 (같은 값의 상대적 순서 유지)
- 구현이 비교적 간단함
- 예측 가능한 성능

**단점:**
- 값의 범위(k)가 클 때 메모리 사용량이 매우 큼
- 정수 또는 정수로 매핑 가능한 데이터에만 적용 가능
- 범위를 알아야 하므로 사전 분석 필요

**쓰면 좋은 경우:**
- **값의 범위가 작고 제한적일 때** (예: 0~100점 성적, 나이)
- **정수 데이터를 매우 빠르게 정렬해야 할 때**
- **안정성이 중요한 상황에서** (같은 점수의 학생들 순서 유지)
- **기수 정렬의 보조 알고리즘으로 사용할 때**
- **실시간으로 작은 범위 데이터를 처리할 때**

---

## 2. 기수 정렬 (Radix Sort)

### 알고리즘 원리
숫자의 자릿수를 이용하여 정렬하는 비교 기반이 아닌 알고리즘이다. 가장 낮은 자릿수(또는 가장 높은 자릿수)부터 시작하여 각 자릿수별로 안정 정렬을 수행한다.

**동작 과정 (LSD - Least Significant Digit):**
1. 1의 자리부터 시작하여 각 자릿수별로 분류
2. 각 자릿수에서 계수 정렬 등을 이용한 안정 정렬 수행
3. 가장 높은 자릿수까지 반복
4. 모든 자릿수 처리 완료 시 정렬 완성

### 시간/공간 복잡도
- **시간 복잡도**:
    - 모든 경우: O(d × (n + k)) - **d는 자릿수, n은 원소 개수, k는 진법**
      > 이유: d번의 패스 × 각 패스마다 O(n + k) 계수 정렬 수행
        - **10진법에서 k=10, 대부분 경우 O(d × n)**
        - **고정된 비트 수의 정수라면 O(n)**
- **공간 복잡도**: O(n + k) - **계수 정렬용 임시 공간**
  > 이유: 각 자릿수 처리 시 계수 정렬에 필요한 공간

### 구현

#### Python
```python
def radix_sort(arr):
    if not arr:
        return arr
    
    # 최댓값을 찾아 자릿수 결정
    max_num = max(arr)
    digit = 1
    
    # 각 자릿수별로 계수 정렬 수행
    while max_num // digit > 0:
        counting_sort_for_radix(arr, digit)
        digit *= 10
    
    return arr

def counting_sort_for_radix(arr, digit):
    """기수 정렬용 계수 정렬 (특정 자릿수 기준)"""
    n = len(arr)
    output = [0] * n
    count = [0] * 10  # 0~9 숫자
    
    # 해당 자릿수의 각 숫자 개수 세기
    for num in arr:
        index = (num // digit) % 10
        count[index] += 1
    
    # 누적합 계산
    for i in range(1, 10):
        count[i] += count[i - 1]
    
    # 뒤에서부터 순회하며 안정 정렬
    for i in range(n - 1, -1, -1):
        index = (arr[i] // digit) % 10
        output[count[index] - 1] = arr[i]
        count[index] -= 1
    
    # 결과 복사
    for i in range(n):
        arr[i] = output[i]

# 음수 처리 버전
def radix_sort_with_negative(arr):
    if not arr:
        return arr
    
    # 양수와 음수 분리
    positive = [x for x in arr if x >= 0]
    negative = [-x for x in arr if x < 0]  # 음수는 양수로 변환
    
    # 각각 정렬
    if positive:
        radix_sort(positive)
    if negative:
        radix_sort(negative)
        negative = [-x for x in reversed(negative)]  # 다시 음수로, 역순
    
    return negative + positive

# 사용 예시
numbers = [170, 45, 75, 90, 2, 802, 24, 66]
print("정렬 전:", numbers)
radix_sort(numbers)
print("정렬 후:", numbers)
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void countingSortForRadix(std::vector<int>& arr, int exp) {
    int n = arr.size();
    std::vector<int> output(n);
    std::vector<int> count(10, 0);
    
    // 해당 자릿수의 각 숫자 개수 세기
    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++;
    }
    
    // 누적합 계산
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }
    
    // 뒤에서부터 순회하며 안정 정렬
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }
    
    // 결과 복사
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

void radixSort(std::vector<int>& arr) {
    if (arr.empty()) return;
    
    // 최댓값을 찾아 자릿수 결정
    int max_num = *std::max_element(arr.begin(), arr.end());
    
    // 각 자릿수별로 계수 정렬 수행
    for (int exp = 1; max_num / exp > 0; exp *= 10) {
        countingSortForRadix(arr, exp);
    }
}

// 사용 예시
int main() {
    std::vector<int> numbers = {170, 45, 75, 90, 2, 802, 24, 66};
    
    std::cout << "정렬 전: ";
    for (int num : numbers) std::cout << num << " ";
    
    radixSort(numbers);
    
    std::cout << "\n정렬 후: ";
    for (int num : numbers) std::cout << num << " ";
    
    return 0;
}
```

#### Java
```java
import java.util.Arrays;

public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr.length == 0) return;
        
        // 최댓값을 찾아 자릿수 결정
        int max = Arrays.stream(arr).max().getAsInt();
        
        // 각 자릿수별로 계수 정렬 수행
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortForRadix(arr, exp);
        }
    }
    
    private static void countingSortForRadix(int[] arr, int exp) {
        int n = arr.length;
        int[] output = new int[n];
        int[] count = new int[10];
        
        // 해당 자릿수의 각 숫자 개수 세기
        for (int num : arr) {
            count[(num / exp) % 10]++;
        }
        
        // 누적합 계산
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // 뒤에서부터 순회하며 안정 정렬
        for (int i = n - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }
        
        // 결과 복사
        System.arraycopy(output, 0, arr, 0, n);
    }
    
    // 사용 예시
    public static void main(String[] args) {
        int[] numbers = {170, 45, 75, 90, 2, 802, 24, 66};
        
        System.out.println("정렬 전: " + Arrays.toString(numbers));
        radixSort(numbers);
        System.out.println("정렬 후: " + Arrays.toString(numbers));
    }
}
```

### 특징 및 쓰면 좋은 경우

**장점:**
- 선형 시간 복잡도 O(d × n) (자릿수가 고정적일 때)
- 안정 정렬 (같은 값의 상대적 순서 유지)
- 큰 수도 효율적으로 정렬 가능
- 병렬화하기 쉬움

**단점:**
- 정수나 고정 길이 문자열에만 적용 가능
- 자릿수가 많을 때 비효율적
- 음수 처리를 위한 추가 로직 필요
- 메모리 사용량이 상당함

**쓰면 좋은 경우:**
- **큰 정수들을 정렬할 때** (자릿수가 비교 횟수보다 적을 때)
- **고정 길이 문자열 정렬** (예: 우편번호, 전화번호)
- **비교 연산이 비싼 데이터 타입**
- **병렬 처리가 가능한 환경에서**
- **계수 정렬을 적용하기 어려운 큰 범위의 정수**

---

## 3. 버킷 정렬 (Bucket Sort)

### 알고리즘 원리
입력을 균등하게 분포된 여러 개의 버킷으로 나눈 후, 각 버킷을 개별적으로 정렬하고 합치는 알고리즘이다. 데이터가 균등 분포할 때 매우 효율적이다.

**동작 과정:**
1. 입력 범위를 여러 개의 버킷으로 나누기 (보통 n개)
2. 각 원소를 해당하는 버킷에 분배
3. 각 버킷을 개별적으로 정렬 (삽입 정렬 등 사용)
4. 모든 버킷을 순서대로 연결하여 최종 결과 생성

### 시간/공간 복잡도
- **시간 복잡도**:
    - 평균의 경우: O(n + k) - **균등 분포일 때, k는 버킷 수**
      > 이유: 버킷 분배 O(n) + 각 버킷 정렬 평균 O(1) × k개
    - 최악의 경우: O(n²) - **모든 원소가 한 버킷에 집중될 때**
      > 이유: 한 버킷에 n개 원소 → 삽입 정렬 O(n²)
    - 최선의 경우: O(n) - **완벽한 균등 분포**
- **공간 복잡도**: O(n + k) - **버킷 저장 공간**
  > 이유: n개 원소를 저장할 버킷들 + k개 버킷 구조

### 구현

#### Python
```python
def bucket_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # 버킷 수 결정 (일반적으로 √n 또는 n 사용)
    bucket_count = len(arr)
    max_val = max(arr)
    min_val = min(arr)
    
    # 범위가 0이면 모든 값이 같음
    if max_val == min_val:
        return arr
    
    # 버킷 초기화
    buckets = [[] for _ in range(bucket_count)]
    
    # 각 원소를 적절한 버킷에 분배
    for num in arr:
        # 정규화된 인덱스 계산 (0 ~ bucket_count-1)
        bucket_index = int((num - min_val) * (bucket_count - 1) / (max_val - min_val))
        buckets[bucket_index].append(num)
    
    # 각 버킷을 개별적으로 정렬 (삽입 정렬 사용)
    for bucket in buckets:
        insertion_sort(bucket)
    
    # 모든 버킷을 연결하여 결과 생성
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result

def insertion_sort(arr):
    """버킷 내부 정렬용 삽입 정렬"""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key

# 실수 전용 버전 (0.0 ~ 1.0 범위)
def bucket_sort_float(arr):
    """0.0 ~ 1.0 범위의 실수 정렬"""
    if len(arr) <= 1:
        return arr
    
    bucket_count = len(arr)
    buckets = [[] for _ in range(bucket_count)]
    
    # 각 원소를 버킷에 분배
    for num in arr:
        bucket_index = int(num * bucket_count)
        # 1.0인 경우 마지막 버킷에 할당
        if bucket_index == bucket_count:
            bucket_index = bucket_count - 1
        buckets[bucket_index].append(num)
    
    # 각 버킷 정렬
    for bucket in buckets:
        insertion_sort(bucket)
    
    # 결과 연결
    result = []
    for bucket in buckets:
        result.extend(bucket)
    
    return result

# 사용 예시
numbers = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
print("정렬 전:", numbers)
sorted_numbers = bucket_sort_float(numbers)
print("정렬 후:", sorted_numbers)

# 정수 버전
integers = [29, 25, 3, 49, 9, 37, 21, 43]
print("\n정수 정렬 전:", integers)
sorted_integers = bucket_sort(integers)
print("정수 정렬 후:", sorted_integers)
```

#### C++
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void insertionSort(std::vector<float>& bucket) {
    for (int i = 1; i < bucket.size(); i++) {
        float key = bucket[i];
        int j = i - 1;
        
        while (j >= 0 && bucket[j] > key) {
            bucket[j + 1] = bucket[j];
            j--;
        }
        
        bucket[j + 1] = key;
    }
}

void bucketSort(std::vector<float>& arr) {
    int n = arr.size();
    if (n <= 1) return;
    
    // 버킷 초기화
    std::vector<std::vector<float>> buckets(n);
    
    // 각 원소를 적절한 버킷에 분배
    for (int i = 0; i < n; i++) {
        int bucket_index = n * arr[i];  // 0.0~1.0 범위 가정
        if (bucket_index == n) bucket_index = n - 1;  // 1.0 처리
        buckets[bucket_index].push_back(arr[i]);
    }
    
    // 각 버킷을 개별적으로 정렬
    for (int i = 0; i < n; i++) {
        insertionSort(buckets[i]);
    }
    
    // 모든 버킷을 연결
    int index = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < buckets[i].size(); j++) {
            arr[index++] = buckets[i][j];
        }
    }
}

// 사용 예시
int main() {
    std::vector<float> arr = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};
    
    std::cout << "정렬 전: ";
    for (float num : arr) std::cout << num << " ";
    
    bucketSort(arr);
    
    std::cout << "\n정렬 후: ";
    for (float num : arr) std::cout << num << " ";
    
    return 0;
}
```

#### Java
```java
import java.util.*;

public class BucketSort {
    public static void bucketSort(float[] arr) {
        int n = arr.length;
        if (n <= 1) return;
        
        // 버킷 초기화
        @SuppressWarnings("unchecked")
        List<Float>[] buckets = new List[n];
        for (int i = 0; i < n; i++) {
            buckets[i] = new ArrayList<>();
        }
        
        // 각 원소를 적절한 버킷에 분배
        for (int i = 0; i < n; i++) {
            int bucketIndex = (int) (n * arr[i]);
            if (bucketIndex == n) bucketIndex = n - 1;  // 1.0 처리
            buckets[bucketIndex].add(arr[i]);
        }
        
        // 각 버킷을 개별적으로 정렬
        for (int i = 0; i < n; i++) {
            Collections.sort(buckets[i]);
        }
        
        // 모든 버킷을 연결
        int index = 0;
        for (int i = 0; i < n; i++) {
            for (float value : buckets[i]) {
                arr[index++] = value;
            }
        }
    }
    
    // 정수 버전
    public static void bucketSortInt(int[] arr) {
        if (arr.length <= 1) return;
        
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int bucketCount = arr.length;
        
        @SuppressWarnings("unchecked")
        List<Integer>[] buckets = new List[bucketCount];
        for (int i = 0; i < bucketCount; i++) {
            buckets[i] = new ArrayList<>();
        }
        
        // 원소 분배
        for (int num : arr) {
            int bucketIndex = (int) ((long)(num - min) * (bucketCount - 1) / (max - min));
            buckets[bucketIndex].add(num);
        }
        
        // 각 버킷 정렬
        for (List<Integer> bucket : buckets) {
            Collections.sort(bucket);
        }
        
        // 결과 연결
        int index = 0;
        for (List<Integer> bucket : buckets) {
            for (int value : bucket) {
                arr[index++] = value;
            }
        }
    }
    
    // 사용 예시
    public static void main(String[] args) {
        float[] floatArr = {0.897f, 0.565f, 0.656f, 0.1234f, 0.665f, 0.3434f};
        System.out.println("실수 정렬 전: " + Arrays.toString(floatArr));
        bucketSort(floatArr);
        System.out.println("실수 정렬 후: " + Arrays.toString(floatArr));
        
        int[] intArr = {29, 25, 3, 49, 9, 37, 21, 43};
        System.out.println("\n정수 정렬 전: " + Arrays.toString(intArr));
        bucketSortInt(intArr);
        System.out.println("정수 정렬 후: " + Arrays.toString(intArr));
    }
}
```

### 특징 및 쓰면 좋은 경우

**장점:**
- 데이터가 균등 분포할 때 선형 시간 O(n) 가능
- 각 버킷을 병렬로 처리할 수 있어 병렬화에 유리
- 외부 정렬에 활용 가능 (각 버킷을 별도 파일로 처리)
- 안정 정렬 구현 가능 (버킷 내부 정렬을 안정 정렬로 사용)

**단점:**
- 데이터 분포에 따라 성능이 크게 달라짐
- 균등 분포가 아니면 비효율적 (최악의 경우 O(n²))
- 추가 메모리 공간이 많이 필요
- 데이터 분포를 사전에 알아야 효과적

**쓰면 좋은 경우:**
- **데이터가 균등하게 분포된다고 확신할 수 있을 때**
- **실수 데이터 정렬** (특히 0.0~1.0 범위)
- **외부 정렬이 필요한 대용량 데이터**
- **병렬 처리가 가능한 환경에서**
- **각 버킷 크기가 비슷할 것으로 예상되는 경우**

---

## 4. 특수 정렬 비교표

| 알고리즘 | 시간복잡도 (평균) | 시간복잡도 (최악) | 시간복잡도 (최선) | 공간복잡도 | 안정성 | 제한사항 |
|---------|-----------------|-----------------|-----------------|------------|--------|----------|
| 계수 정렬 | O(n + k) | O(n + k) | O(n + k) | O(n + k) | 안정 | 값의 범위가 제한적 |
| 기수 정렬 | O(d × n) | O(d × n) | O(d × n) | O(n + k) | 안정 | 정수, 고정길이 문자열 |
| 버킷 정렬 | O(n + k) | O(n²) | O(n) | O(n × k) | 안정* | 균등 분포 가정 |

*버킷 내부 정렬을 안정 정렬로 구현할 경우

---

## 5. 핵심 정리

**특수 정렬의 공통 특징:**
- 비교 기반이 아닌(non-comparative) 정렬 알고리즘
- 특정 조건에서 선형 시간 O(n) 달성 가능
- 데이터의 특성을 활용하여 효율성 극대화
- 일반적인 비교 정렬의 O(n log n) 하한선을 돌파

**알고리즘 선택 기준:**

**계수 정렬을 선택할 때:**
- 값의 범위가 작고 명확할 때 (k ≤ n)
- 정수 데이터이고 빈도 계산이 의미있을 때
- 안정성이 중요하고 선형 성능이 필요할 때

**기수 정렬을 선택할 때:**
- 큰 정수나 고정 길이 문자열 정렬
- 자릿수가 적당히 제한적일 때 (d가 작을 때)
- 계수 정렬을 직접 적용하기 어려운 큰 범위 데이터

**버킷 정렬을 선택할 때:**
- 데이터가 균등 분포할 것으로 예상될 때
- 실수 데이터, 특히 [0,1) 범위
- 병렬 처리나 외부 정렬이 필요할 때

**특수 정렬 vs 일반 정렬:**

| 상황 | 권장 알고리즘 | 이유 |
|------|-------------|------|
| 작은 범위 정수 | 계수 정렬 | O(n) 성능, 단순함 |
| 큰 정수, 제한된 자릿수 | 기수 정렬 | 자릿수별 처리로 효율성 |
| 균등분포 실수 | 버킷 정렬 | 평균 O(n) 성능 |
| 일반적인 데이터 | 퀵/병합 정렬 | 범용성, 안정적 성능 |
| 범위를 모르는 데이터 | 힙/병합 정렬 | 최악 케이스 보장 |

**실무에서의 활용:**
- **데이터베이스 인덱싱**: 계수 정렬 (카테고리별 분류)
- **문자열 정렬**: 기수 정렬 (사전순 정렬)
- **이미지 처리**: 버킷 정렬 (픽셀값 히스토그램)
- **실시간 시스템**: 계수 정렬 (예측 가능한 성능)

**성능 최적화 팁:**
- **하이브리드 접근**: 데이터 크기에 따라 알고리즘 전환
- **전처리 활용**: 데이터 분포 분석 후 적절한 알고리즘 선택
- **병렬화**: 기수 정렬과 버킷 정렬의 병렬 처리 활용
- **메모리 관리**: 큰 범위에서는 일반 정렬 고려

특수 정렬은 특정 조건에서 뛰어난 성능을 보이지만, 데이터 특성을 정확히 파악하고 적용해야 효과적이다. 범용적인 해결책보다는 도메인 특화된 최적화 도구로 활용하는 것이 바람직하다.