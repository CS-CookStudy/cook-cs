# 단순 정렬 알고리즘 (Simple Sorting Algorithms)

## 1. 버블 정렬 (Bubble Sort)

### 알고리즘 원리
인접한 두 원소를 비교하여 크기 순서대로 교환하는 과정을 반복한다. 마치 거품이 물 위로 올라오듯이 큰 값들이 배열의 뒤쪽으로 이동하는 모습에서 버블 정렬이라는 이름이 붙었다.

### 단계별 정렬 과정 시각화
```
초기 배열: [64, 34, 25, 12, 22]

1번째 패스:
[64, 34, 25, 12, 22] → 64 > 34, 교환
[34, 64, 25, 12, 22] → 64 > 25, 교환  
[34, 25, 64, 12, 22] → 64 > 12, 교환
[34, 25, 12, 64, 22] → 64 > 22, 교환
[34, 25, 12, 22, 64] ← 가장 큰 값이 맨 뒤로!

2번째 패스:
[34, 25, 12, 22, 64] → 34 > 25, 교환
[25, 34, 12, 22, 64] → 34 > 12, 교환
[25, 12, 34, 22, 64] → 34 > 22, 교환
[25, 12, 22, 34, 64] ← 두 번째로 큰 값 정렬!

3번째 패스:
[25, 12, 22, 34, 64] → 25 > 12, 교환
[12, 25, 22, 34, 64] → 25 > 22, 교환
[12, 22, 25, 34, 64] ← 완료!
```

**동작 과정:**
1. 배열의 첫 번째 원소부터 인접한 원소와 비교
2. 앞의 원소가 뒤의 원소보다 크면 교환
3. 배열 끝까지 이 과정을 반복 (한 번의 패스로 가장 큰 값이 맨 뒤로 이동)
4. 정렬될 때까지 패스를 반복

### 시간/공간 복잡도
- **시간 복잡도**:
    - 최악의 경우: O(n²) - **역순으로 정렬된 경우 [5,4,3,2,1]**
      > 이유: n번의 패스 × 평균 n/2번의 비교 = n²/2 ≈ O(n²)
    - 평균의 경우: O(n²)
    - 최선의 경우: O(n) - **이미 정렬된 경우 [1,2,3,4,5]** (개선된 버전)
      > 이유: 첫 패스에서 교환이 없으면 즉시 종료
- **공간 복잡도**: O(1) - **제자리 정렬**
  > 이유: 임시 변수 몇 개만 사용, 입력 크기와 무관하게 일정한 메모리 사용

### 구현

#### Python
```python
def bubble_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # 마지막 i개 원소는 이미 정렬됨
        swapped = False
        
        for j in range(0, n - i - 1):
            # 인접한 원소 비교
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # 교환이 일어나지 않으면 정렬 완료
        if not swapped:
            break
    
    return arr

# 사용 예시
numbers = [64, 34, 25, 12, 22, 11, 90]
print("정렬 전:", numbers)
bubble_sort(numbers)
print("정렬 후:", numbers)
```

### 활용

**사용 예시:**
- **임베디드 시스템**: 메모리가 극도로 제한된 마이크로컨트롤러에서 센서 데이터 5-10개 정렬
- **교육용 소프트웨어**: 정렬 과정을 시각적으로 보여주는 알고리즘 학습 도구
- **디버깅/테스트**: 작은 테스트 케이스에서 정렬 로직 검증
- **하이브리드 정렬**: Timsort에서 매우 작은 구간(< 7개)을 정렬할 때

**주의사항:**
- 실무에서는 보통 배열 크기가 10개 이하일 때만 고려
- Python의 `sorted()`나 Java의 `Arrays.sort()`가 더 효율적

### 특징

**장점:**
- 구현이 매우 간단하고 이해하기 쉬움
- 안정 정렬 (같은 값의 원소들의 상대적 순서가 유지됨)
- 제자리 정렬 (추가 메모리 공간이 거의 필요 없음)
- 정렬 과정을 시각적으로 이해하기 좋음

**단점:**
- 시간 복잡도가 O(n²)로 비효율적
- 원소 교환 횟수가 많아 실제 성능이 느림

---

## 2. 선택 정렬 (Selection Sort)

### 알고리즘 원리
전체 배열에서 가장 작은(또는 큰) 원소를 찾아 첫 번째 위치에 놓고, 나머지 배열에서 다시 가장 작은 원소를 찾아 두 번째 위치에 놓는 과정을 반복한다.

### 단계별 정렬 과정 시각화
```
초기 배열: [64, 25, 12, 22, 11]

1단계: 전체에서 최솟값 11을 찾아 첫 번째와 교환
[64, 25, 12, 22, 11] → 최솟값: 11 (인덱스 4)
[11, 25, 12, 22, 64] ← 11이 제자리에!

2단계: 나머지 [25, 12, 22, 64]에서 최솟값 12를 찾아 두 번째와 교환  
[11, 25, 12, 22, 64] → 최솟값: 12 (인덱스 2)
[11, 12, 25, 22, 64] ← 12가 제자리에!

3단계: 나머지 [25, 22, 64]에서 최솟값 22를 찾아 세 번째와 교환
[11, 12, 25, 22, 64] → 최솟값: 22 (인덱스 3)  
[11, 12, 22, 25, 64] ← 22가 제자리에!

4단계: 나머지 [25, 64]는 이미 정렬됨
[11, 12, 22, 25, 64] ← 완료!
```

**동작 과정:**
1. 배열에서 최솟값을 찾아 첫 번째 원소와 교환
2. 두 번째 원소부터 끝까지에서 최솟값을 찾아 두 번째 원소와 교환
3. 이 과정을 배열이 정렬될 때까지 반복

### 시간/공간 복잡도
- **시간 복잡도**:
    - 모든 경우: O(n²) - **최선/평균/최악 모두 동일**
      > 이유: 항상 전체 배열을 탐색하여 최솟값을 찾아야 함 (n + (n-1) + ... + 1 = n(n+1)/2)
        - 최악의 경우: **역순으로 정렬된 경우 [5,4,3,2,1]**
        - 최선의 경우: **이미 정렬된 경우 [1,2,3,4,5]** (성능 차이 없음)
- **공간 복잡도**: O(1) - **제자리 정렬**
  > 이유: 최솟값 인덱스를 저장할 변수 하나만 추가로 사용

### 구현

#### Python
```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n):
        # i번째부터 끝까지에서 최솟값의 인덱스 찾기
        min_idx = i
        
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # 최솟값을 현재 위치로 교환
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr

# 사용 예시
numbers = [64, 34, 25, 12, 22, 11, 90]
print("정렬 전:", numbers)
selection_sort(numbers)
print("정렬 후:", numbers)
```

#### C++
```cpp
#include <iostream>
#include <vector>

void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 0; i < n; i++) {
        int min_idx = i;
        
        // 최솟값 찾기
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        
        // 최솟값을 현재 위치로 교환
        if (min_idx != i) {
            std::swap(arr[i], arr[min_idx]);
        }
    }
}

// 사용 예시
int main() {
    std::vector<int> numbers = {64, 34, 25, 12, 22, 11, 90};
    
    std::cout << "정렬 전: ";
    for (int num : numbers) std::cout << num << " ";
    
    selectionSort(numbers);
    
    std::cout << "\n정렬 후: ";
    for (int num : numbers) std::cout << num << " ";
    
    return 0;
}
```

#### Java
```java
import java.util.Arrays;

public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n; i++) {
            int min_idx = i;
            
            // 최솟값 찾기
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[min_idx]) {
                    min_idx = j;
                }
            }
            
            // 최솟값을 현재 위치로 교환
            if (min_idx != i) {
                int temp = arr[i];
                arr[i] = arr[min_idx];
                arr[min_idx] = temp;
            }
        }
    }
    
    // 사용 예시
    public static void main(String[] args) {
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        
        System.out.println("정렬 전: " + Arrays.toString(numbers));
        selectionSort(numbers);
        System.out.println("정렬 후: " + Arrays.toString(numbers));
    }
}
```

### 활용

**실제 사용 예시:**
- **메모리 제약 환경**: 임베디드 시스템에서 RAM이 매우 적을 때 (< 1KB)
- **교환 비용이 큰 상황**: 데이터베이스에서 대용량 레코드를 정렬할 때 (물리적 이동 최소화)
- **네트워크 통신**: 작은 패킷 순서 정렬 (최소한의 데이터 이동)
- **실시간 시스템**: 예측 가능한 일정한 성능이 필요할 때

**성능 특징:**
- 교환 횟수: 정확히 n-1번 (예측 가능)
- 비교 횟수: 항상 n(n-1)/2번 (일정함)
- 캐시 성능: 순차 접근으로 캐시 친화적

### 특징

**장점:**
- 구현이 간단하고 직관적
- 교환 횟수가 적음 (최대 n-1번)
- 제자리 정렬로 메모리 효율적
- 선택 과정이 명확해 이해하기 쉬움

**단점:**
- 시간 복잡도가 항상 O(n²)
- 불안정 정렬 (같은 값의 상대적 순서가 바뀔 수 있음)
- 이미 정렬된 배열에도 동일한 시간이 소요됨

---

## 3. 삽입 정렬 (Insertion Sort)

### 알고리즘 원리
배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 하나씩 정렬된 부분의 적절한 위치에 삽입한다. 카드를 정렬하는 방식과 유사하다.

### 단계별 정렬 과정 시각화
```
초기 배열: [12, 11, 13, 5, 6]
           [정렬됨] [정렬되지 않음]

1단계: key = 11을 정렬된 부분 [12]에 삽입
[12 | 11, 13, 5, 6] → 12 > 11이므로 12를 오른쪽으로
[12,    13, 5, 6] → 11을 첫 번째 위치에 삽입
[11, 12 | 13, 5, 6] ← 정렬된 부분 확장!

2단계: key = 13을 정렬된 부분 [11, 12]에 삽입  
[11, 12 | 13, 5, 6] → 13 > 12이므로 제자리 OK
[11, 12, 13 | 5, 6] ← 정렬된 부분 확장!

3단계: key = 5를 정렬된 부분 [11, 12, 13]에 삽입
[11, 12, 13 | 5, 6] → 13 > 5, 12 > 5, 11 > 5
[   11, 12, 13, 6] → 모두 오른쪽으로 이동
[5, 11, 12, 13 | 6] ← 5가 맨 앞에!

4단계: key = 6을 정렬된 부분 [5, 11, 12, 13]에 삽입
[5, 11, 12, 13 | 6] → 13 > 6, 12 > 6, 11 > 6이지만 5 < 6
[5,    11, 12, 13] → 6보다 큰 것들만 이동  
[5, 6, 11, 12, 13] ← 완료!
```

**동작 과정:**
1. 두 번째 원소부터 시작 (첫 번째 원소는 이미 정렬된 것으로 간주)
2. 현재 원소를 정렬된 부분과 비교하여 적절한 위치를 찾음
3. 해당 위치에 현재 원소를 삽입 (필요시 다른 원소들을 이동)
4. 모든 원소에 대해 반복

### 시간/공간 복잡도
- **시간 복잡도**:
    - 최악의 경우: O(n²) - **역순으로 정렬된 경우 [5,4,3,2,1]**
      > 이유: 각 원소를 삽입할 때마다 이전 모든 원소와 비교 (1+2+...+(n-1) = n(n-1)/2)
    - 평균의 경우: O(n²)
    - 최선의 경우: O(n) - **이미 정렬된 경우 [1,2,3,4,5]**
      > 이유: 각 원소당 1번의 비교만 필요 (바로 다음 원소가 제자리)
- **공간 복잡도**: O(1) - **제자리 정렬**
  > 이유: 삽입할 원소를 저장할 key 변수와 인덱스 변수만 사용

### 구현

#### Python
```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]  # 삽입할 원소
        j = i - 1     # 정렬된 부분의 마지막 인덱스
        
        # key보다 큰 원소들을 한 칸씩 뒤로 이동
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        # key를 적절한 위치에 삽입
        arr[j + 1] = key
    
    return arr

# 사용 예시
numbers = [64, 34, 25, 12, 22, 11, 90]
print("정렬 전:", numbers)
insertion_sort(numbers)
print("정렬 후:", numbers)
```

#### C++
```cpp
#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // key보다 큰 원소들을 한 칸씩 뒤로 이동
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // key를 적절한 위치에 삽입
        arr[j + 1] = key;
    }
}

// 사용 예시
int main() {
    std::vector<int> numbers = {64, 34, 25, 12, 22, 11, 90};
    
    std::cout << "정렬 전: ";
    for (int num : numbers) std::cout << num << " ";
    
    insertionSort(numbers);
    
    std::cout << "\n정렬 후: ";
    for (int num : numbers) std::cout << num << " ";
    
    return 0;
}
```

#### Java
```java
import java.util.Arrays;

public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // key보다 큰 원소들을 한 칸씩 뒤로 이동
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            // key를 적절한 위치에 삽입
            arr[j + 1] = key;
        }
    }
    
    // 사용 예시
    public static void main(String[] args) {
        int[] numbers = {64, 34, 25, 12, 22, 11, 90};
        
        System.out.println("정렬 전: " + Arrays.toString(numbers));
        insertionSort(numbers);
        System.out.println("정렬 후: " + Arrays.toString(numbers));
    }
}
```

### 활용

**사용 예시:**
- **하이브리드 정렬**: Timsort, Introsort에서 작은 구간(< 16개) 처리
- **실시간 데이터 처리**: 스트리밍 데이터를 받으면서 즉시 정렬
- **온라인 게임**: 리더보드에 새로운 점수가 들어올 때마다 실시간 정렬
- **파일 시스템**: 거의 정렬된 디렉토리 목록 정리
- **데이터베이스**: 인덱스 페이지에서 새로운 키 삽입

**성능 특징:**
- 적응적(Adaptive): 부분적으로 정렬된 데이터에서 빠름
- 온라인(Online): 새 데이터가 오면 즉시 처리 가능
- 캐시 효율적: 지역성이 좋음

### 특징

**장점:**
- 구현이 간단하고 직관적
- 안정 정렬 (같은 값의 상대적 순서 유지)
- 제자리 정렬로 메모리 효율적
- 이미 정렬된 데이터에 대해서는 O(n)의 성능
- 온라인 알고리즘 (데이터가 들어오는 대로 정렬 가능)

**단점:**
- 평균적으로 O(n²)의 시간 복잡도
- 큰 데이터셋에서는 비효율적

---

## 4. 언제 어떤 알고리즘을 선택할까?

### 상황별 선택 

| 상황 | 추천 알고리즘 | 이유 |
|------|-------------|------|
| **메모리 < 1KB + 데이터 < 20개** | 삽입 정렬 | 메모리 효율 + 좋은 성능 |
| **교환 비용이 매우 클 때** | 선택 정렬 | 최소 교환 횟수 (n-1번) |
| **거의 정렬된 데이터** | 삽입 정렬 | O(n)에 가까운 성능 |
| **실시간 스트리밍 데이터** | 삽입 정렬 | 온라인 처리 가능 |
| **교육/시각화 목적** | 버블 정렬 | 가장 직관적 |
| **예측 가능한 성능 필요** | 선택 정렬 | 항상 일정한 시간 |

### 성능 비교

**데이터 크기별 성능 (마이크로초 단위)**
```
크기 10개:   버블(15) vs 선택(12) vs 삽입(8)
크기 50개:   버블(180) vs 선택(120) vs 삽입(85)  
크기 100개:  버블(720) vs 선택(400) vs 삽입(300)
크기 1000개: 사용 금지 - O(n log n) 알고리즘 필요
```

**메모리 사용량 비교**
```
버블 정렬: 8바이트 (임시변수 2개)
선택 정렬: 4바이트 (인덱스 1개)  
삽입 정렬: 8바이트 (key + 인덱스)
```

### 의사결정 플로우차트

```
데이터 크기는?
├─ < 10개
│  ├─ 거의 정렬됨? → 삽입 정렬
│  ├─ 교환 비용 큼? → 선택 정렬  
│  └─ 교육 목적? → 버블 정렬
├─ 10-50개
│  ├─ 실시간 처리? → 삽입 정렬
│  └─ 메모리 극한? → 선택 정렬
└─ > 50개 → 고급 정렬 알고리즘 사용 권장
```

---

## 5. 비교

| 알고리즘 | 시간복잡도 (평균) | 시간복잡도 (최악) | 시간복잡도 (최선) | 공간복잡도 | 안정성 | 교환횟수 | 활용도 |
|---------|-----------------|-----------------|-----------------|------------|--------|----------|------------|
| 버블 정렬 | O(n²) | O(n²) | O(n) | O(1) | 안정 | O(n²) | ★ (교육용) |
| 선택 정렬 | O(n²) | O(n²) | O(n²) | O(1) | 불안정 | O(n) | ★★ (메모리 제약) |
| 삽입 정렬 | O(n²) | O(n²) | O(n) | O(1) | 안정 | O(n²) | ★★★ (하이브리드) |

---

## 6. 핵심 정리

### 단순 정렬의 공통 특징
- 모두 O(n²)의 시간 복잡도를 가짐 (삽입 정렬은 최선의 경우 O(n))
- 제자리 정렬로 추가 메모리가 거의 필요 없음
- 구현이 간단하고 이해하기 쉬움
- 작은 데이터셋에서는 충분히 실용적

### 선택 기준
- **교육/학습 목적**: 버블 정렬 (가장 직관적)
- **교환 비용이 클 때**: 선택 정렬 (교환 횟수 최소)
- **부분 정렬된 데이터**: 삽입 정렬 (적응적 성능)
- **실시간 정렬**: 삽입 정렬 (온라인 알고리즘)