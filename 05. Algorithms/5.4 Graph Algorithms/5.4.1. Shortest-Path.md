# 최단 경로 알고리즘

## 최단 경로 문제란?

그래프에서 한 정점에서 다른 정점까지 가는 경로 중에서 **가중치의 합이 최소인 경로**를 찾는 문제이다. 실생활에서 GPS 네비게이션, 네트워크 라우팅, 게임 AI의 경로 탐색 등에 광범위하게 활용된다.

### 왜 필요한가?
- **경로 최적화**: 최소 비용이나 최단 시간으로 목적지 도달
- **자원 관리**: 네트워크 대역폭, 연료, 시간 등의 효율적 사용
- **의사 결정**: 여러 선택지 중 최적의 경로 선택
- **비용 분석**: 프로젝트나 투자의 최소 비용 경로 계산

---

## 주요 최단 경로 알고리즘 3가지

### 1. 다익스트라 알고리즘 (Dijkstra)
**"가장 가까운 정점부터 차례대로 확정해나가기"**

- **핵심 아이디어**: 우선순위 큐로 최단 거리 정점을 먼저 처리
- **자료구조**: 우선순위 큐 (최소 힙)
- **특징**: 빠른 속도, 음이 아닌 가중치만 처리 가능

### 2. 벨만-포드 알고리즘 (Bellman-Ford)
**"모든 간선을 반복적으로 완화하여 최단 거리 갱신"**

- **핵심 아이디어**: V-1번 반복하며 모든 간선에서 거리 갱신
- **자료구조**: 거리 배열
- **특징**: 음의 가중치 처리 가능, 음의 사이클 탐지

### 3. 플로이드-워샬 알고리즘 (Floyd-Warshall)
**"중간 정점을 하나씩 추가하며 모든 경로 개선"**

- **핵심 아이디어**: 동적 프로그래밍으로 모든 정점 쌍 최단 거리 계산
- **자료구조**: 2차원 거리 행렬
- **특징**: 모든 쌍 최단 거리, 구현 간단

---

## 동작 방식 비교

**예제 그래프:**
```
    A ----2---- B
    |         / |
    4       1   3
    |     /     |
    C --5------ D
```

### 탐색 방식 비교
| 알고리즘 | 처리 방식 | 결과 |
|---------|-----------|------|
| **다익스트라** | A(0) → B(2) → C(3) → D(5) | 단일 출발점에서 모든 정점까지 |
| **벨만-포드** | 모든 간선을 V-1번 반복 완화 | 단일 출발점, 음의 가중치 처리 |
| **플로이드-워샬** | 중간 정점 A,B,C,D 순서로 경유 | 모든 정점 쌍의 최단 거리 |

---

## 핵심 특성 비교

| 특성 | 다익스트라 | 벨만-포드 | 플로이드-워샬 |
|-----|----------|----------|-------------|
| **시간복잡도** | O((V+E)log V) | O(VE) | O(V³) |
| **공간복잡도** | O(V) | O(V) | O(V²) |
| **음의 가중치** | ❌ | ✅ | ✅ |
| **음의 사이클** | ❌ | 탐지 가능 | 탐지 가능 |
| **적용 범위** | 단일 출발점 | 단일 출발점 | 모든 쌍 |
| **구현 난이도** | 보통 | 쉬움 | 매우 쉬움 |

> V = 정점 수, E = 간선 수

---

## 언제 어떤 알고리즘을 사용할까?

### 🎯 목적별 선택
```
가중치가 모두 양수이고 빠른게 필요하다면     → 다익스트라
음의 가중치가 있거나 음의 사이클 탐지가 필요  → 벨만-포드
모든 정점 쌍의 거리가 필요하다면            → 플로이드-워샬
단일 목적지까지만 필요하다면               → 다익스트라 (조기종료)
```

### 💡 상황별 선택
```
그래프가 희소하고(간선이 적음) 빠른 결과 필요  → 다익스트라
분산 환경이나 네트워크에서 구현              → 벨만-포드
작은 그래프에서 모든 경로가 필요             → 플로이드-워샬
통화 거래나 차익 거래 분석                  → 벨만-포드
```

---

## 대표 문제 유형

### 다익스트라 활용 문제
- **최단 경로**: 출발점에서 목적지까지 최단 거리
- **네트워크 라우팅**: 최소 비용으로 데이터 전송
- **게임 AI**: NPC의 최적 이동경로
- **물류 최적화**: 배송 센터에서 각 지점까지 최소 비용

### 벨만-포드 활용 문제
- **음의 가중치 처리**: 할인이나 보상이 있는 경로
- **시간 여행**: 과거로 돌아가는 경로가 있는 문제
- **차익 거래**: 환율 차이를 이용한 무위험 수익 탐지
- **제약 시스템**: 부등식 제약 조건 해결

### 플로이드-워샬 활용 문제
- **거리 행렬**: 모든 도시 쌍 사이의 최단 거리
- **중심성 분석**: 네트워크에서 가장 중요한 노드 찾기
- **경유지 최적화**: 여러 목적지를 거치는 최적 경로
- **연결성 분석**: 그래프의 연결 패턴 분석

---

## 구현 패턴

### 다익스트라
```python
import heapq

def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]
    
    while pq:
        current_dist, node = heapq.heappop(pq)
        if current_dist > dist[node]:
            continue
            
        for neighbor, weight in graph[node]:
            distance = current_dist + weight
            if distance < dist[neighbor]:
                dist[neighbor] = distance
                heapq.heappush(pq, (distance, neighbor))
    
    return dist
```

### 벨만-포드
```python
def bellman_ford(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    
    # V-1번 반복
    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node]:
                if dist[node] + weight < dist[neighbor]:
                    dist[neighbor] = dist[node] + weight
    
    # 음의 사이클 검사
    for node in graph:
        for neighbor, weight in graph[node]:
            if dist[node] + weight < dist[neighbor]:
                return None  # 음의 사이클 존재
    
    return dist
```

### 플로이드-워샬
```python
def floyd_warshall(dist):
    n = len(dist)
    
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist
```

---

## 핵심 정리

### 면접 필수 포인트
1. **각 알고리즘의 차이점**: 음의 가중치 처리, 시간복잡도, 적용 범위
2. **언제 뭘 쓸까**: 상황에 따른 최적 알고리즘 선택 능력
3. **구현 핵심**: 우선순위 큐, 간선 완화, 동적 프로그래밍
4. **음의 사이클**: 의미와 탐지 방법

### 기억해야 할 것들
- **다익스트라**: 우선순위 큐 + 음이 아닌 가중치 + 가장 빠름
- **벨만-포드**: 간선 완화 + 음의 가중치 처리 + 사이클 탐지
- **플로이드-워샬**: 3중 반복문 + 모든 쌍 + 구현 간단
