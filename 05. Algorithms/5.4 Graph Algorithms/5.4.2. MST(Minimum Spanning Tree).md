# 최소 신장 트리 알고리즘

## 최소 신장 트리 (MST)란?

주어진 연결된 무방향 그래프에서 **모든 정점을 연결하는 부분 그래프 중 간선들의 가중치 합이 최소인 트리**를 말한다. 네트워크 설계, 클러스터링, 도로 건설 등에서 최소 비용으로 모든 지점을 연결해야 할 때 사용된다.

### 왜 필요한가?
- **네트워크 설계**: 최소 비용으로 모든 노드를 연결하는 통신망 구축
- **도로/전력망 건설**: 모든 지역을 연결하는 최소 비용 인프라 구축
- **클러스터링**: 데이터 포인트들을 효율적으로 그룹화
- **회로 설계**: 최소 전선으로 모든 부품을 연결

---

## 신장 트리의 특성

### 1. 신장 트리 (Spanning Tree)
**"그래프의 모든 정점을 포함하면서 사이클이 없는 연결된 부분 그래프"**

- **정점 수**: 원본 그래프와 동일 (V개)
- **간선 수**: 정확히 V-1개 (트리의 특성)
- **연결성**: 모든 정점이 연결됨
- **사이클**: 존재하지 않음

### 2. 최소 신장 트리 (Minimum Spanning Tree)
**"가능한 모든 신장 트리 중 간선 가중치의 합이 최소인 트리"**

- **유일성**: 간선 가중치가 모두 다르면 MST는 유일함
- **최적성**: 전체 연결 비용이 최소
- **부분 최적성**: MST의 부분도 최적 구조를 가짐

---

## 주요 MST 알고리즘 2가지

### 1. 크루스칼 알고리즘 (Kruskal)
**"간선을 가중치 순으로 정렬한 후, 사이클을 만들지 않는 간선들을 차례로 선택"**

- **핵심 아이디어**: 간선 중심의 탐욕 알고리즘
- **자료구조**: Union-Find (분리 집합)
- **특징**: 간선이 적은 희소 그래프에 효율적

### 2. 프림 알고리즘 (Prim)
**"하나의 정점에서 시작하여 트리를 점진적으로 확장해나가기"**

- **핵심 아이디어**: 정점 중심의 탐욕 알고리즘
- **자료구조**: 우선순위 큐 (최소 힙)
- **특징**: 간선이 많은 조밀 그래프에 효율적

---

## 동작 방식 비교

**예제 그래프:**
```
    A ----1---- B
    |         / |
    4       2   3
    |     /     |
    C --5------ D

간선 가중치: AB(1), BD(3), BC(2), AD(4), CD(5)
```

### 알고리즘 선택 과정
| 단계 | 크루스칼 | 프림 |
|------|---------|------|
| **1단계** | AB(1) 선택 | A 시작 → AB(1) |
| **2단계** | BC(2) 선택 | AB → BC(2) |
| **3단계** | BD(3) 선택 | ABC → BD(3) |
| **결과** | MST: AB(1) + BC(2) + BD(3) = 6 | MST: AB(1) + BC(2) + BD(3) = 6 |

---

## 핵심 특성 비교

| 특성 | 크루스칼 | 프림 |
|-----|---------|------|
| **시간복잡도** | O(E log E) | O((V+E) log V) |
| **공간복잡도** | O(V) | O(V) |
| **자료구조** | Union-Find | 우선순위 큐 |
| **접근 방식** | 간선 중심 | 정점 중심 |
| **희소 그래프** | ✅ 효율적 | 보통 |
| **조밀 그래프** | 보통 | ✅ 효율적 |
| **구현 복잡도** | 보통 (Union-Find) | 쉬움 |

> V = 정점 수, E = 간선 수

---

## 언제 어떤 알고리즘을 사용할까?

### 🎯 그래프 특성별 선택
```
간선이 적은 희소 그래프 (E << V²)           → 크루스칼
간선이 많은 조밀 그래프 (E ≈ V²)           → 프림
정점 수가 적고 간선이 많음                 → 프림
정점 수가 많고 간선이 적음                 → 크루스칼
```

### 💡 구현 관점별 선택
```
Union-Find 자료구조에 익숙함               → 크루스칼
우선순위 큐 구현이 편함                    → 프림
간선 정보가 리스트로 주어짐                → 크루스칼
인접 리스트로 그래프가 주어짐              → 프림
```

---

## 대표 문제 유형

### 크루스칼 활용 문제
- **네트워크 연결**: 최소 비용으로 모든 컴퓨터 연결
- **도로 건설**: 모든 도시를 연결하는 최소 비용 도로망
- **전력망 구축**: 최소 전선으로 모든 지역에 전력 공급
- **클러스터링**: 데이터 포인트들의 최소 연결 비용

### 프림 활용 문제
- **시작점이 정해진 네트워크**: 특정 중심에서 확장하는 네트워크
- **실시간 확장**: 단계별로 네트워크를 확장해야 하는 경우
- **지역 최적화**: 현재 연결된 부분에서 가장 효율적인 확장
- **메모리 제약**: Union-Find보다 단순한 자료구조 선호

### 공통 활용 문제
- **최소 연결 비용**: 모든 지점을 연결하는 최소 비용
- **네트워크 설계**: 통신망, 교통망, 유통망 최적 설계
- **군집 분석**: 최소 비용으로 데이터 클러스터링
- **회로 최적화**: 최소 배선으로 모든 부품 연결

---

## 구현 패턴

### 크루스칼 기본 템플릿
```python
def kruskal(vertices, edges):
    # Union-Find 자료구조
    parent = {v: v for v in vertices}
    
    def find(x):
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        px, py = find(x), find(y)
        if px != py:
            parent[px] = py
            return True
        return False
    
    # 간선을 가중치순으로 정렬
    edges.sort(key=lambda x: x[2])
    
    mst = []
    for u, v, weight in edges:
        if union(u, v):
            mst.append((u, v, weight))
            if len(mst) == len(vertices) - 1:
                break
    
    return mst
```

### 프림 기본 템플릿
```python
import heapq

def prim(graph, start):
    mst = []
    visited = {start}
    
    # 시작 정점의 간선들을 힙에 추가
    edges = [(weight, start, neighbor) 
             for neighbor, weight in graph[start]]
    heapq.heapify(edges)
    
    while edges and len(visited) < len(graph):
        weight, u, v = heapq.heappop(edges)
        
        if v not in visited:
            visited.add(v)
            mst.append((u, v, weight))
            
            # 새로운 정점의 간선들 추가
            for neighbor, w in graph[v]:
                if neighbor not in visited:
                    heapq.heappush(edges, (w, v, neighbor))
    
    return mst
```
