
## 5.4.1.3 í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜ (Floyd-Warshall Algorithm)

### ê°œë…ê³¼ ì›ë¦¬

**í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜ì´ë€?**
ëª¨ë“  ì •ì  ìŒ ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤. **ë™ì  í”„ë¡œê·¸ë˜ë°**ì„ ì‚¬ìš©í•˜ì—¬ ì¤‘ê°„ ì •ì ì„ ê±°ì³ê°€ëŠ” ê²½ë¡œë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ê³ ë ¤í•œë‹¤.

**í•µì‹¬ ì•„ì´ë””ì–´:**
- **"ì¤‘ê°„ ì •ì ì„ í•˜ë‚˜ì”© ì¶”ê°€í•˜ë©° ê²½ë¡œ ê°œì„ "**
- **ë™ì  í”„ë¡œê·¸ë˜ë°**: dist[i][j][k] = iì—ì„œ jë¡œ ê°€ëŠ”ë° 1~k ì •ì ë§Œ ê±°ì³ê°€ëŠ” ìµœë‹¨ ê±°ë¦¬
- **ì ì§„ì  ê°œì„ **: ê° ë‹¨ê³„ì—ì„œ ìƒˆë¡œìš´ ì¤‘ê°„ ì •ì ì„ ê³ ë ¤í•˜ì—¬ ê²½ë¡œ ê°œì„ 

**íŠ¹ì§•:**

ì¥ì :
- ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ í•œ ë²ˆì— ê³„ì‚°
- ìŒì˜ ê°€ì¤‘ì¹˜ ì²˜ë¦¬ ê°€ëŠ¥ (ìŒì˜ ì‚¬ì´í´ íƒì§€ë„ ê°€ëŠ¥)
- êµ¬í˜„ì´ ë§¤ìš° ê°„ë‹¨ (3ì¤‘ ë°˜ë³µë¬¸)
- ê·¸ë˜í”„ê°€ ì¡°ë°€í•œ ê²½ìš° íš¨ìœ¨ì 

ë‹¨ì :
- ì‹œê°„ ë³µì¡ë„ê°€ ë†’ìŒ O(VÂ³)
- ê³µê°„ ë³µì¡ë„ë„ ë†’ìŒ O(VÂ²)
- ë‹¨ì¼ ìŒ ìµœë‹¨ ê²½ë¡œì—ëŠ” ë¹„íš¨ìœ¨ì 
- ê·¸ë˜í”„ê°€ í¬ì†Œí•œ ê²½ìš° ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ì—¬ëŸ¬ ë²ˆ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ ë” íš¨ìœ¨ì 

### ë™ì‘ ê³¼ì •

**ì˜ˆì‹œ ê·¸ë˜í”„:**
```
    A ----2---- B
    |         / |
    4       1   3
    |     /     |
    C --5------ D

ê°€ì¤‘ì¹˜: A-B(2), A-C(4), B-C(1), B-D(3), C-D(5)
```

**ë‹¨ê³„ë³„ íƒìƒ‰ ê³¼ì •:**
```
ì´ˆê¸° ê±°ë¦¬ í–‰ë ¬ (ì§ì ‘ ì—°ê²°ë§Œ):
     A  B  C  D
A  [ 0  2  4  âˆ]
B  [ âˆ  0  1  3]
C  [ âˆ  âˆ  0  5]
D  [ âˆ  âˆ  âˆ  0]

k=A ë‹¨ê³„ (Aë¥¼ ì¤‘ê°„ ì •ì ìœ¼ë¡œ ê³ ë ¤):
   ëª¨ë“  (i,j) ìŒì— ëŒ€í•´ dist[i][j] vs dist[i][A] + dist[A][j] ë¹„êµ
   Bâ†’C: min(1, âˆ+4) = 1 (ë³€í™” ì—†ìŒ)
   Câ†’B: min(âˆ, âˆ+2) = âˆ (ë³€í™” ì—†ìŒ)
   ê²°ê³¼: ë³€í™” ì—†ìŒ

k=B ë‹¨ê³„ (Bë¥¼ ì¤‘ê°„ ì •ì ìœ¼ë¡œ ê³ ë ¤):
   Aâ†’C: min(4, 2+1) = min(4, 3) = 3
   Aâ†’D: min(âˆ, 2+3) = 5
   Câ†’A: min(âˆ, âˆ+âˆ) = âˆ
   Câ†’D: min(5, 1+3) = min(5, 4) = 4
     A  B  C  D
A  [ 0  2  3  5]
B  [ âˆ  0  1  3]
C  [ âˆ  âˆ  0  4]
D  [ âˆ  âˆ  âˆ  0]

k=C ë‹¨ê³„ (Cë¥¼ ì¤‘ê°„ ì •ì ìœ¼ë¡œ ê³ ë ¤):
   Aâ†’D: min(5, 3+4) = min(5, 7) = 5 (ë³€í™” ì—†ìŒ)
   Bâ†’D: min(3, 1+4) = min(3, 5) = 3 (ë³€í™” ì—†ìŒ)
   ê²°ê³¼: ë³€í™” ì—†ìŒ

k=D ë‹¨ê³„ (Dë¥¼ ì¤‘ê°„ ì •ì ìœ¼ë¡œ ê³ ë ¤):
   Dì—ì„œ ë‚˜ê°€ëŠ” ê°„ì„ ì´ ì—†ìœ¼ë¯€ë¡œ ë³€í™” ì—†ìŒ

ìµœì¢… ê²°ê³¼:
     A  B  C  D
A  [ 0  2  3  5]
B  [ âˆ  0  1  3]
C  [ âˆ  âˆ  0  4]
D  [ âˆ  âˆ  âˆ  0]
```

**ì•Œê³ ë¦¬ì¦˜ ê³¼ì •:**
1. ê±°ë¦¬ í–‰ë ¬ì„ ì§ì ‘ ì—°ê²°ëœ ê°„ì„  ê°€ì¤‘ì¹˜ë¡œ ì´ˆê¸°í™”
2. ê° ì •ì  kë¥¼ ì¤‘ê°„ ì •ì ìœ¼ë¡œ í•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ê³ ë ¤
3. ëª¨ë“  ì •ì  ìŒ (i,j)ì— ëŒ€í•´ i â†’ k â†’ j ê²½ë¡œê°€ ë” ì§§ì€ì§€ í™•ì¸
4. ë” ì§§ìœ¼ë©´ ê±°ë¦¬ í–‰ë ¬ ê°±ì‹ 
5. ëª¨ë“  ì •ì ì„ ì¤‘ê°„ ì •ì ìœ¼ë¡œ ê³ ë ¤í•  ë•Œê¹Œì§€ ë°˜ë³µ

### êµ¬í˜„

<details>
<summary><strong>ì½”ë“œ êµ¬í˜„ ë³´ê¸°</strong></summary>

<details>
<summary><strong>Python</strong></summary>

```python
def floyd_warshall(graph):
    """
    í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ëª¨ë“  ìŒ ìµœë‹¨ ê²½ë¡œ ê³„ì‚°
    
    Args:
        graph: ì¸ì ‘ í–‰ë ¬ í˜•íƒœì˜ ê·¸ë˜í”„ (ë”•ì…”ë„ˆë¦¬)
               {(i, j): weight} í˜•íƒœë¡œ ì§ì ‘ ì—°ê²°ëœ ê°„ì„ ë§Œ í¬í•¨
    
    Returns:
        dist: ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê±°ë¦¬ í–‰ë ¬
    """
    # ëª¨ë“  ì •ì  ì¶”ì¶œ
    vertices = set()
    for (i, j), weight in graph.items():
        vertices.add(i)
        vertices.add(j)
    vertices = sorted(list(vertices))
    
    # ê±°ë¦¬ í–‰ë ¬ ì´ˆê¸°í™”
    dist = {}
    for i in vertices:
        for j in vertices:
            if i == j:
                dist[(i, j)] = 0
            elif (i, j) in graph:
                dist[(i, j)] = graph[(i, j)]
            else:
                dist[(i, j)] = float('infinity')
    
    # í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
    for k in vertices:
        for i in vertices:
            for j in vertices:
                if dist[(i, k)] + dist[(k, j)] < dist[(i, j)]:
                    dist[(i, j)] = dist[(i, k)] + dist[(k, j)]
    
    return dist, vertices

def floyd_warshall_with_path(graph):
    """
    ìµœë‹¨ ê±°ë¦¬ì™€ í•¨ê»˜ ì‹¤ì œ ê²½ë¡œë„ ë°˜í™˜í•˜ëŠ” í”Œë¡œì´ë“œ-ì›Œìƒ¬
    """
    vertices = set()
    for (i, j), weight in graph.items():
        vertices.add(i)
        vertices.add(j)
    vertices = sorted(list(vertices))
    
    # ê±°ë¦¬ í–‰ë ¬ê³¼ ë‹¤ìŒ ì •ì  í–‰ë ¬ ì´ˆê¸°í™”
    dist = {}
    next_vertex = {}
    
    for i in vertices:
        for j in vertices:
            if i == j:
                dist[(i, j)] = 0
                next_vertex[(i, j)] = None
            elif (i, j) in graph:
                dist[(i, j)] = graph[(i, j)]
                next_vertex[(i, j)] = j
            else:
                dist[(i, j)] = float('infinity')
                next_vertex[(i, j)] = None
    
    # í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
    for k in vertices:
        for i in vertices:
            for j in vertices:
                if dist[(i, k)] + dist[(k, j)] < dist[(i, j)]:
                    dist[(i, j)] = dist[(i, k)] + dist[(k, j)]
                    next_vertex[(i, j)] = next_vertex[(i, k)]
    
    return dist, next_vertex, vertices

def reconstruct_floyd_path(next_vertex, start, end):
    """í”Œë¡œì´ë“œ-ì›Œìƒ¬ ê²°ê³¼ë¡œë¶€í„° ê²½ë¡œ ì¬êµ¬ì„±"""
    if next_vertex[(start, end)] is None:
        return []
    
    path = [start]
    current = start
    
    while current != end:
        current = next_vertex[(current, end)]
        path.append(current)
    
    return path

def detect_negative_cycle_floyd(dist, vertices):
    """í”Œë¡œì´ë“œ-ì›Œìƒ¬ ê²°ê³¼ì—ì„œ ìŒì˜ ì‚¬ì´í´ íƒì§€"""
    for vertex in vertices:
        if dist[(vertex, vertex)] < 0:
            return True
    return False

def floyd_warshall_matrix_form(adj_matrix):
    """
    2ì°¨ì› ë¦¬ìŠ¤íŠ¸ í˜•íƒœì˜ ì¸ì ‘ í–‰ë ¬ì„ ë°›ëŠ” í”Œë¡œì´ë“œ-ì›Œìƒ¬
    """
    n = len(adj_matrix)
    
    # ê±°ë¦¬ í–‰ë ¬ ë³µì‚¬ (ì›ë³¸ ìˆ˜ì • ë°©ì§€)
    dist = [row[:] for row in adj_matrix]
    
    # í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    
    return dist

# === ì‹¤í–‰ ì˜ˆì‹œ ===

# ì˜ˆì œ ê·¸ë˜í”„
graph_dict = {
    ('A', 'B'): 2,
    ('A', 'C'): 4,
    ('B', 'C'): 1,
    ('B', 'D'): 3,
    ('C', 'D'): 5
}

# 1. ê¸°ë³¸ í”Œë¡œì´ë“œ-ì›Œìƒ¬
print("1. ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê±°ë¦¬:")
distances, vertices = floyd_warshall(graph_dict)

print("   ê±°ë¦¬ í–‰ë ¬:")
print("     ", end="")
for v in vertices:
    print(f"{v:>3}", end="")
print()

for i in vertices:
    print(f"  {i}", end="")
    for j in vertices:
        dist_val = distances[(i, j)]
        if dist_val == float('infinity'):
            print(f"{'âˆ':>3}", end="")
        else:
            print(f"{dist_val:>3}", end="")
    print()

# 2. ê²½ë¡œ í¬í•¨ í”Œë¡œì´ë“œ-ì›Œìƒ¬
print("\n2. ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê²½ë¡œ:")
distances, next_v, vertices = floyd_warshall_with_path(graph_dict)

for i in vertices:
    for j in vertices:
        if i != j and distances[(i, j)] != float('infinity'):
            path = reconstruct_floyd_path(next_v, i, j)
            print(f"   {i} â†’ {j}: {' â†’ '.join(path)} (ê±°ë¦¬: {distances[(i, j)]})")

# 3. ì¸ì ‘ í–‰ë ¬ í˜•íƒœ ì˜ˆì‹œ
print("\n3. ì¸ì ‘ í–‰ë ¬ í˜•íƒœë¡œ ê³„ì‚°:")
INF = float('infinity')
adj_matrix = [
    [0, 2, 4, INF],  # A
    [INF, 0, 1, 3],  # B  
    [INF, INF, 0, 5], # C
    [INF, INF, INF, 0] # D
]

result_matrix = floyd_warshall_matrix_form(adj_matrix)
vertex_names = ['A', 'B', 'C', 'D']

print("   ê²°ê³¼ í–‰ë ¬:")
for i in range(len(result_matrix)):
    print(f"  {vertex_names[i]}", end="")
    for j in range(len(result_matrix[i])):
        if result_matrix[i][j] == INF:
            print(f"{'âˆ':>3}", end="")
        else:
            print(f"{result_matrix[i][j]:>3}", end="")
    print()
```
</details>

<details>
<summary><strong>Java</strong></summary>

```java
import java.util.*;

public class FloydWarshallAlgorithm {
    
    static class FloydWarshallResult {
        Map<String, Map<String, Integer>> distances;
        List<String> vertices;
        
        FloydWarshallResult(Map<String, Map<String, Integer>> distances, List<String> vertices) {
            this.distances = distances;
            this.vertices = vertices;
        }
    }
    
    public static FloydWarshallResult floydWarshall(Map<String, Map<String, Integer>> graph) {
        // ëª¨ë“  ì •ì  ì¶”ì¶œ
        Set<String> vertexSet = new HashSet<>();
        for (String vertex : graph.keySet()) {
            vertexSet.add(vertex);
            vertexSet.addAll(graph.get(vertex).keySet());
        }
        List<String> vertices = new ArrayList<>(vertexSet);
        Collections.sort(vertices);
        
        // ê±°ë¦¬ í–‰ë ¬ ì´ˆê¸°í™”
        Map<String, Map<String, Integer>> dist = new HashMap<>();
        for (String i : vertices) {
            dist.put(i, new HashMap<>());
            for (String j : vertices) {
                if (i.equals(j)) {
                    dist.get(i).put(j, 0);
                } else if (graph.containsKey(i) && graph.get(i).containsKey(j)) {
                    dist.get(i).put(j, graph.get(i).get(j));
                } else {
                    dist.get(i).put(j, Integer.MAX_VALUE);
                }
            }
        }
        
        // í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
        for (String k : vertices) {
            for (String i : vertices) {
                for (String j : vertices) {
                    if (dist.get(i).get(k) != Integer.MAX_VALUE && 
                        dist.get(k).get(j) != Integer.MAX_VALUE &&
                        dist.get(i).get(k) + dist.get(k).get(j) < dist.get(i).get(j)) {
                        dist.get(i).put(j, dist.get(i).get(k) + dist.get(k).get(j));
                    }
                }
            }
        }
        
        return new FloydWarshallResult(dist, vertices);
    }
    
    static class FloydWarshallPathResult {
        Map<String, Map<String, Integer>> distances;
        Map<String, Map<String, String>> next;
        List<String> vertices;
        
        FloydWarshallPathResult(Map<String, Map<String, Integer>> distances,
                               Map<String, Map<String, String>> next,
                               List<String> vertices) {
            this.distances = distances;
            this.next = next;
            this.vertices = vertices;
        }
    }
    
    public static FloydWarshallPathResult floydWarshallWithPath(Map<String, Map<String, Integer>> graph) {
        Set<String> vertexSet = new HashSet<>();
        for (String vertex : graph.keySet()) {
            vertexSet.add(vertex);
            vertexSet.addAll(graph.get(vertex).keySet());
        }
        List<String> vertices = new ArrayList<>(vertexSet);
        Collections.sort(vertices);
        
        Map<String, Map<String, Integer>> dist = new HashMap<>();
        Map<String, Map<String, String>> next = new HashMap<>();
        
        // ì´ˆê¸°í™”
        for (String i : vertices) {
            dist.put(i, new HashMap<>());
            next.put(i, new HashMap<>());
            for (String j : vertices) {
                if (i.equals(j)) {
                    dist.get(i).put(j, 0);
                    next.get(i).put(j, null);
                } else if (graph.containsKey(i) && graph.get(i).containsKey(j)) {
                    dist.get(i).put(j, graph.get(i).get(j));
                    next.get(i).put(j, j);
                } else {
                    dist.get(i).put(j, Integer.MAX_VALUE);
                    next.get(i).put(j, null);
                }
            }
        }
        
        // í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
        for (String k : vertices) {
            for (String i : vertices) {
                for (String j : vertices) {
                    if (dist.get(i).get(k) != Integer.MAX_VALUE && 
                        dist.get(k).get(j) != Integer.MAX_VALUE &&
                        dist.get(i).get(k) + dist.get(k).get(j) < dist.get(i).get(j)) {
                        dist.get(i).put(j, dist.get(i).get(k) + dist.get(k).get(j));
                        next.get(i).put(j, next.get(i).get(k));
                    }
                }
            }
        }
        
        return new FloydWarshallPathResult(dist, next, vertices);
    }
    
    public static List<String> reconstructPath(Map<String, Map<String, String>> next, String start, String end) {
        if (next.get(start).get(end) == null) {
            return new ArrayList<>();
        }
        
        List<String> path = new ArrayList<>();
        path.add(start);
        String current = start;
        
        while (!current.equals(end)) {
            current = next.get(current).get(end);
            path.add(current);
        }
        
        return path;
    }
    
    public static int[][] floydWarshallMatrix(int[][] adjMatrix) {
        int n = adjMatrix.length;
        int[][] dist = new int[n][n];
        
        // ê±°ë¦¬ í–‰ë ¬ ë³µì‚¬
        for (int i = 0; i < n; i++) {
            System.arraycopy(adjMatrix[i], 0, dist[i], 0, n);
        }
        
        // í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != Integer.MAX_VALUE && 
                        dist[k][j] != Integer.MAX_VALUE &&
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
        
        return dist;
    }
    
    public static void main(String[] args) {
        // ì˜ˆì œ ê·¸ë˜í”„
        Map<String, Map<String, Integer>> graph = new HashMap<>();
        
        graph.put("A", new HashMap<>());
        graph.get("A").put("B", 2);
        graph.get("A").put("C", 4);
        
        graph.put("B", new HashMap<>());
        graph.get("B").put("C", 1);
        graph.get("B").put("D", 3);
        
        graph.put("C", new HashMap<>());
        graph.get("C").put("D", 5);
        
        graph.put("D", new HashMap<>());
        
        // 1. ê¸°ë³¸ í”Œë¡œì´ë“œ-ì›Œìƒ¬
        System.out.println("1. ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê±°ë¦¬:");
        FloydWarshallResult result = floydWarshall(graph);
        
        System.out.println("   ê±°ë¦¬ í–‰ë ¬:");
        System.out.print("     ");
        for (String v : result.vertices) {
            System.out.printf("%3s", v);
        }
        System.out.println();
        
        for (String i : result.vertices) {
            System.out.printf("  %s", i);
            for (String j : result.vertices) {
                int dist = result.distances.get(i).get(j);
                if (dist == Integer.MAX_VALUE) {
                    System.out.printf("%3s", "âˆ");
                } else {
                    System.out.printf("%3d", dist);
                }
            }
            System.out.println();
        }
        
        // 2. ê²½ë¡œ í¬í•¨ í”Œë¡œì´ë“œ-ì›Œìƒ¬
        System.out.println("\n2. ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê²½ë¡œ:");
        FloydWarshallPathResult pathResult = floydWarshallWithPath(graph);
        
        for (String i : pathResult.vertices) {
            for (String j : pathResult.vertices) {
                if (!i.equals(j) && pathResult.distances.get(i).get(j) != Integer.MAX_VALUE) {
                    List<String> path = reconstructPath(pathResult.next, i, j);
                    System.out.println("   " + i + " â†’ " + j + ": " + String.join(" â†’ ", path) + 
                                     " (ê±°ë¦¬: " + pathResult.distances.get(i).get(j) + ")");
                }
            }
        }
    }
}
```
</details>

<details>
<summary><strong>C++</strong></summary>

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
#include <algorithm>
#include <limits>

using namespace std;

struct FloydWarshallResult {
    unordered_map<string, unordered_map<string, int>> distances;
    vector<string> vertices;
    
    FloydWarshallResult(unordered_map<string, unordered_map<string, int>> d, vector<string> v)
        : distances(d), vertices(v) {}
};

class FloydWarshallAlgorithm {
public:
    static FloydWarshallResult floydWarshall(const unordered_map<string, unordered_map<string, int>>& graph) {
        // ëª¨ë“  ì •ì  ì¶”ì¶œ
        unordered_set<string> vertexSet;
        for (const auto& pair : graph) {
            vertexSet.insert(pair.first);
            for (const auto& inner : pair.second) {
                vertexSet.insert(inner.first);
            }
        }
        
        vector<string> vertices(vertexSet.begin(), vertexSet.end());
        sort(vertices.begin(), vertices.end());
        
        // ê±°ë¦¬ í–‰ë ¬ ì´ˆê¸°í™”
        unordered_map<string, unordered_map<string, int>> dist;
        for (const string& i : vertices) {
            for (const string& j : vertices) {
                if (i == j) {
                    dist[i][j] = 0;
                } else if (graph.count(i) && graph.at(i).count(j)) {
                    dist[i][j] = graph.at(i).at(j);
                } else {
                    dist[i][j] = numeric_limits<int>::max();
                }
            }
        }
        
        // í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
        for (const string& k : vertices) {
            for (const string& i : vertices) {
                for (const string& j : vertices) {
                    if (dist[i][k] != numeric_limits<int>::max() && 
                        dist[k][j] != numeric_limits<int>::max() &&
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
        
        return FloydWarshallResult(dist, vertices);
    }
    
    struct FloydWarshallPathResult {
        unordered_map<string, unordered_map<string, int>> distances;
        unordered_map<string, unordered_map<string, string>> next;
        vector<string> vertices;
        
        FloydWarshallPathResult(unordered_map<string, unordered_map<string, int>> d,
                               unordered_map<string, unordered_map<string, string>> n,
                               vector<string> v)
            : distances(d), next(n), vertices(v) {}
    };
    
    static FloydWarshallPathResult floydWarshallWithPath(const unordered_map<string, unordered_map<string, int>>& graph) {
        unordered_set<string> vertexSet;
        for (const auto& pair : graph) {
            vertexSet.insert(pair.first);
            for (const auto& inner : pair.second) {
                vertexSet.insert(inner.first);
            }
        }
        
        vector<string> vertices(vertexSet.begin(), vertexSet.end());
        sort(vertices.begin(), vertices.end());
        
        unordered_map<string, unordered_map<string, int>> dist;
        unordered_map<string, unordered_map<string, string>> next;
        
        // ì´ˆê¸°í™”
        for (const string& i : vertices) {
            for (const string& j : vertices) {
                if (i == j) {
                    dist[i][j] = 0;
                    next[i][j] = "";
                } else if (graph.count(i) && graph.at(i).count(j)) {
                    dist[i][j] = graph.at(i).at(j);
                    next[i][j] = j;
                } else {
                    dist[i][j] = numeric_limits<int>::max();
                    next[i][j] = "";
                }
            }
        }
        
        // í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
        for (const string& k : vertices) {
            for (const string& i : vertices) {
                for (const string& j : vertices) {
                    if (dist[i][k] != numeric_limits<int>::max() && 
                        dist[k][j] != numeric_limits<int>::max() &&
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                        next[i][j] = next[i][k];
                    }
                }
            }
        }
        
        return FloydWarshallPathResult(dist, next, vertices);
    }
    
    static vector<string> reconstructPath(const unordered_map<string, unordered_map<string, string>>& next, 
                                        const string& start, const string& end) {
        if (next.at(start).at(end).empty()) {
            return vector<string>();
        }
        
        vector<string> path;
        path.push_back(start);
        string current = start;
        
        while (current != end) {
            current = next.at(current).at(end);
            path.push_back(current);
        }
        
        return path;
    }
    
    static vector<vector<int>> floydWarshallMatrix(const vector<vector<int>>& adjMatrix) {
        int n = adjMatrix.size();
        vector<vector<int>> dist = adjMatrix;
        
        // í”Œë¡œì´ë“œ-ì›Œìƒ¬ ì•Œê³ ë¦¬ì¦˜
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != numeric_limits<int>::max() && 
                        dist[k][j] != numeric_limits<int>::max() &&
                        dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
        
        return dist;
    }
};

// === ì‹¤í–‰ ì˜ˆì‹œ ===
int main() {
    // ì˜ˆì œ ê·¸ë˜í”„
    unordered_map<string, unordered_map<string, int>> graph;
    graph["A"]["B"] = 2;
    graph["A"]["C"] = 4;
    graph["B"]["C"] = 1;
    graph["B"]["D"] = 3;
    graph["C"]["D"] = 5;
    
    // 1. ê¸°ë³¸ í”Œë¡œì´ë“œ-ì›Œìƒ¬
    cout << "1. ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê±°ë¦¬:" << endl;
    auto result = FloydWarshallAlgorithm::floydWarshall(graph);
    
    cout << "   ê±°ë¦¬ í–‰ë ¬:" << endl;
    cout << "     ";
    for (const string& v : result.vertices) {
        cout << v << "  ";
    }
    cout << endl;
    
    for (const string& i : result.vertices) {
        cout << "  " << i << " ";
        for (const string& j : result.vertices) {
            int dist = result.distances[i][j];
            if (dist == numeric_limits<int>::max()) {
                cout << "âˆ  ";
            } else {
                cout << dist << "  ";
            }
        }
        cout << endl;
    }
    
    // 2. ê²½ë¡œ í¬í•¨ í”Œë¡œì´ë“œ-ì›Œìƒ¬
    cout << "\n2. ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê²½ë¡œ:" << endl;
    auto pathResult = FloydWarshallAlgorithm::floydWarshallWithPath(graph);
    
    for (const string& i : pathResult.vertices) {
        for (const string& j : pathResult.vertices) {
            if (i != j && pathResult.distances[i][j] != numeric_limits<int>::max()) {
                auto path = FloydWarshallAlgorithm::reconstructPath(pathResult.next, i, j);
                cout << "   " << i << " â†’ " << j << ": ";
                for (size_t k = 0; k < path.size(); k++) {
                    cout << path[k];
                    if (k < path.size() - 1) cout << " â†’ ";
                }
                cout << " (ê±°ë¦¬: " << pathResult.distances[i][j] << ")" << endl;
            }
        }
    }
    
    return 0;
}
```
</details>

</details>

### í™œìš©

**ì‚¬ìš© ì˜ˆì‹œ:**
- **ë„ì‹œ ê°„ ìµœë‹¨ ê±°ë¦¬**: ëª¨ë“  ë„ì‹œ ìŒ ì‚¬ì´ì˜ ìµœë‹¨ ì´ë™ ê±°ë¦¬ ê³„ì‚°
- **ë„¤íŠ¸ì›Œí¬ ë¶„ì„**: ëª¨ë“  ë…¸ë“œ ìŒ ì‚¬ì´ì˜ ìµœë‹¨ í†µì‹  ê²½ë¡œ
- **ê²Œì„ AI**: ë§µì˜ ëª¨ë“  ì§€ì  ì‚¬ì´ ìµœë‹¨ ê±°ë¦¬ ë¯¸ë¦¬ ê³„ì‚°
- **ì‚¬íšŒ ì—°ê²°ë§**: ëª¨ë“  ì‚¬ìš©ì ìŒ ì‚¬ì´ì˜ ìµœë‹¨ ì—°ê²° ê´€ê³„

**ëŒ€í‘œ ë¬¸ì œë“¤:**
- **ëª¨ë“  ìŒ ìµœë‹¨ ê²½ë¡œ**: ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì  ìŒ ì‚¬ì´ ìµœë‹¨ ê±°ë¦¬
- **ì¤‘ì‹¬ì„± ë¶„ì„**: ë„¤íŠ¸ì›Œí¬ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ë…¸ë“œ ì°¾ê¸°
- **ê²½ìœ ì§€ ìµœì í™”**: ì—¬ëŸ¬ ëª©ì ì§€ë¥¼ ê±°ì³ê°€ëŠ” ìµœì  ê²½ë¡œ

### ì„±ëŠ¥ ë¶„ì„

**ì‹œê°„/ê³µê°„ ë³µì¡ë„:**
- **ì‹œê°„ ë³µì¡ë„**: O(VÂ³) - **VëŠ” ì •ì  ìˆ˜**
  > 3ì¤‘ ë°˜ë³µë¬¸ìœ¼ë¡œ ëª¨ë“  ì •ì  ìŒê³¼ ì¤‘ê°„ ì •ì  ì¡°í•© í™•ì¸
- **ê³µê°„ ë³µì¡ë„**: O(VÂ²) - **ê±°ë¦¬ í–‰ë ¬**

---

## ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ ë° ì„ íƒ ê°€ì´ë“œ

### ì„±ëŠ¥ ë¹„êµ

| ì•Œê³ ë¦¬ì¦˜ | ì‹œê°„ë³µì¡ë„ | ê³µê°„ë³µì¡ë„ | ìŒì˜ ê°€ì¤‘ì¹˜ | ìš©ë„ |
|---------|-----------|-----------|------------|------|
| **ë‹¤ìµìŠ¤íŠ¸ë¼** | O((V+E)logV) | O(V) | âŒ | ë‹¨ì¼ ì¶œë°œì , ìŒì´ ì•„ë‹Œ ê°€ì¤‘ì¹˜ |
| **ë²¨ë§Œ-í¬ë“œ** | O(VE) | O(V) | âœ… | ë‹¨ì¼ ì¶œë°œì , ìŒì˜ ê°€ì¤‘ì¹˜ |
| **í”Œë¡œì´ë“œ-ì›Œìƒ¬** | O(VÂ³) | O(VÂ²) | âœ… | ëª¨ë“  ìŒ, ì‘ì€ ê·¸ë˜í”„ |

### ìƒí™©ë³„ ìµœì  ì„ íƒ

```
ğŸ¯ ëª©ì ë³„ ì„ íƒ
ë‹¨ì¼ ì¶œë°œì  + ìŒì´ ì•„ë‹Œ ê°€ì¤‘ì¹˜     â†’ ë‹¤ìµìŠ¤íŠ¸ë¼
ë‹¨ì¼ ì¶œë°œì  + ìŒì˜ ê°€ì¤‘ì¹˜ ê°€ëŠ¥     â†’ ë²¨ë§Œ-í¬ë“œ  
ëª¨ë“  ì •ì  ìŒì˜ ìµœë‹¨ ê±°ë¦¬          â†’ í”Œë¡œì´ë“œ-ì›Œìƒ¬
ìŒì˜ ì‚¬ì´í´ íƒì§€ê°€ í•„ìš”          â†’ ë²¨ë§Œ-í¬ë“œ

ğŸ’¡ ê·¸ë˜í”„ íŠ¹ì„±ë³„ ì„ íƒ
í¬ì†Œ ê·¸ë˜í”„ (E << VÂ²)           â†’ ë‹¤ìµìŠ¤íŠ¸ë¼ or ë²¨ë§Œ-í¬ë“œ
ì¡°ë°€ ê·¸ë˜í”„ (E â‰ˆ VÂ²)           â†’ í”Œë¡œì´ë“œ-ì›Œìƒ¬
ì •ì  ìˆ˜ê°€ ì‘ìŒ (V < 100)        â†’ í”Œë¡œì´ë“œ-ì›Œìƒ¬
ì •ì  ìˆ˜ê°€ í¼ (V > 1000)        â†’ ë‹¤ìµìŠ¤íŠ¸ë¼ or ë²¨ë§Œ-í¬ë“œ
```

### ì‹¤ì „ ë¬¸ì œ ì˜ˆì‹œ

**ë‹¤ìµìŠ¤íŠ¸ë¼ í™œìš©:**
- ë°±ì¤€ 1753: ìµœë‹¨ê²½ë¡œ
- ë°±ì¤€ 1916: ìµœì†Œë¹„ìš© êµ¬í•˜ê¸°
- í”„ë¡œê·¸ë˜ë¨¸ìŠ¤: ë°°ë‹¬

**ë²¨ë§Œ-í¬ë“œ í™œìš©:**
- ë°±ì¤€ 11657: íƒ€ì„ë¨¸ì‹ 
- ë°±ì¤€ 1865: ì›œí™€

**í”Œë¡œì´ë“œ-ì›Œìƒ¬ í™œìš©:**
- ë°±ì¤€ 11404: í”Œë¡œì´ë“œ
- ë°±ì¤€ 1389: ì¼€ë¹ˆ ë² ì´ì»¨ì˜ 6ë‹¨ê³„ ë²•ì¹™

---