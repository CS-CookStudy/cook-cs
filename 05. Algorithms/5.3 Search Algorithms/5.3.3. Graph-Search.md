# 그래프 탐색 알고리즘 비교 가이드

## 그래프 탐색이란?

그래프의 모든 정점(vertex)을 체계적으로 방문하는 과정이다. 시작 정점에서 출발하여 연결된 모든 정점을 빠뜨리지 않고 한 번씩 방문하는 것이 목표이며, **어떤 순서로 방문하느냐**에 따라 다양한 알고리즘이 존재한다.

### 왜 필요한가?
- **경로 탐색**: 두 지점 사이의 경로 존재 여부 확인
- **연결성 확인**: 그래프의 연결 요소 찾기
- **최적화 문제**: 최단 경로, 최적해 탐색
- **조건 만족**: 제약 조건을 만족하는 해 찾기

---

## 주요 탐색 알고리즘 3가지

### 1. 깊이 우선 탐색 (DFS)
**"한 방향으로 끝까지 가본 다음, 막히면 되돌아가서 다른 길 시도"**

- **핵심 아이디어**: 현재 정점에서 갈 수 있는 곳까지 최대한 깊이 들어감
- **자료구조**: 스택 (또는 재귀)
- **특징**: 메모리 효율적, 모든 경로 탐색 가능

### 2. 너비 우선 탐색 (BFS)
**"현재 레벨의 모든 이웃을 먼저 방문한 후, 다음 레벨로 이동"**

- **핵심 아이디어**: 시작점에서 가까운 정점부터 차례대로 방문
- **자료구조**: 큐
- **특징**: 최단 경로 보장, 레벨별 탐색

### 3. 백트래킹 (Backtracking)
**"조건에 맞지 않으면 즉시 포기하고 이전 단계로 되돌아가기"**

- **핵심 아이디어**: DFS + 가지치기 (pruning)
- **자료구조**: 스택 (재귀)
- **특징**: 불필요한 탐색 제거, 제약 조건 활용

---

## 동작 방식 비교

**예제 그래프:**
```
    A
   / \
  B   C
 /   / \
D   E   F
```

### 탐색 순서 비교
| 알고리즘 | 방문 순서 | 설명 |
|---------|-----------|------|
| **DFS** | A → B → D → C → E → F | 한 방향 끝까지 → 백트래킹 |
| **BFS** | A → B → C → D → E → F | 레벨별 순차 방문 |
| **백트래킹** | 조건에 따라 중간 포기 | 조건 위반 시 즉시 되돌아감 |

---

## 핵심 특성 비교

| 특성 | DFS | BFS | 백트래킹 |
|-----|-----|-----|---------|
| **자료구조** | 스택/재귀 | 큐 | 스택/재귀 |
| **시간복잡도** | O(V + E) | O(V + E) | O(k^n) |
| **공간복잡도** | O(h) | O(w) | O(h) |
| **최단경로** | ❌ | ✅ | ❌ |
| **메모리 효율** | ✅ | ❌ | ✅ |
| **가지치기** | ❌ | ❌ | ✅ |
| **완전탐색** | ✅ | ✅ | ✅ |

> h = 트리 높이, w = 트리 너비, k = 선택지 수, n = 결정 단계

---

## 언제 어떤 알고리즘을 사용할까?

### 🎯 목적별 선택
```
최단 경로가 필요하다면        → BFS
경로 존재 여부만 확인한다면    → DFS  
조건을 만족하는 해를 찾는다면  → 백트래킹
모든 노드를 방문해야 한다면    → DFS 또는 BFS
```

### 💡 상황별 선택
```
메모리가 제한적이다          → DFS
해가 시작점 근처에 있을 것 같다 → BFS  
제약 조건이 복잡하다         → 백트래킹
그래프가 매우 깊다          → BFS
그래프가 매우 넓다          → DFS
```

---

## 대표 문제 유형

### DFS 활용 문제
- **연결 요소 개수**: 그래프의 독립적인 컴포넌트 찾기
- **사이클 탐지**: 그래프에 순환이 있는지 확인
- **경로 탐색**: 두 정점 사이의 경로 존재 확인
- **위상 정렬**: 의존성이 있는 작업의 순서 결정

### BFS 활용 문제
- **최단 거리**: 가중치가 없는 그래프에서 최단 경로
- **레벨 순회**: 트리의 각 레벨별 노드 처리
- **이분 그래프**: 그래프를 두 그룹으로 나눌 수 있는지 확인
- **미로 탈출**: 출구까지의 최소 이동 횟수

### 백트래킹 활용 문제
- **N-Queen**: 체스판에 퀸을 배치하는 문제
- **순열/조합**: 조건을 만족하는 순열이나 조합 생성
- **스도쿠**: 제약 조건을 만족하는 숫자 배치
- **부분집합 합**: 특정 합을 만드는 부분집합 찾기

---

## 구현 패턴

### DFS 기본 템플릿
```python
def dfs(graph, start, visited):
    visited.add(start)
    
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
```

### BFS 기본 템플릿
```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)
    
    while queue:
        node = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)
```

### 백트래킹 기본 템플릿
```python
def backtrack(partial_solution):
    if is_complete(partial_solution):
        return partial_solution
    
    for choice in get_choices(partial_solution):
        if is_valid(partial_solution, choice):
            result = backtrack(partial_solution + [choice])
            if result is not None:
                return result
    
    return None
```

---

## 핵심 정리

### 면접 필수 포인트
1. **DFS vs BFS 차이점**: 탐색 순서와 자료구조의 차이
2. **언제 뭘 쓸까**: 최단 경로는 BFS, 메모리 효율은 DFS
3. **백트래킹의 핵심**: 조건 위반 시 즉시 포기하는 가지치기
4. **복잡도 차이**: 시간은 비슷하지만 공간 복잡도가 다름

### ⚡ 기억해야 할 것들
- **DFS**: 깊이 + 스택 + 메모리 효율
- **BFS**: 너비 + 큐 + 최단 경로
- **백트래킹**: 조건부 DFS + 가지치기