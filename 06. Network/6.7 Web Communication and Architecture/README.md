# 1. 클라이언트-서버 모델

## 1-0. 기본개념

- **클라이언트** : 서비스를 **요청**하는 쪽 (브라우저, 모바일 앱 등)
- **서버** : 서비스를 **제공**하는 쪽 (웹 서버, 데이터베이스 서버 등)
- **요청-응답 패턴** : 클라이언트가 요청하면 서버가 응답

## 1-1. 클라이언트-서버 통신 과정

### 기본 웹 통신 흐름

```
사용자                클라이언트(브라우저)           서버
 |                          |                    |
 |--URL 입력 또는 클릭------->|                    |
 |                          |                    |
 |                          |---HTTP 요청-------->|
 |                          |                    |
 |                          |<---HTTP 응답--------|
 |                          |                    |
 |<--웹 페이지 표시-----------|                    |
```

### 상세 통신 단계

```
1. DNS 조회 : www.example.com → 93.184.216.34
2. TCP 연결 : 3-way handshake (포트 80/443)
3. HTTP 요청 전송 :
   GET / HTTP/1.1
   HOST: www.example.com

4. 서버 처리 : 요청 분석 → 비즈니스 로직 → 응답 생성
5. HTTP 응답 전송:
   HTTP/1.1 200 OK
   Content-Type: text/html

6. 브라우저 렌더링 : HTML 파싱 → CSS 적용 → JS 실행
```

## 1-2. 클라이언트-서버 아키텍처 패턴

### 2-Tier 아키텍처 (클라이언트-서버)

```
클라이언트 ←→ 서버(DB 포함)

장점:
✅ 구조가 간단
✅ 개발 및 배포 용이

단점:
❌ 서버 부하 집중
❌ 확장성 제한
❌ 유지보수 어려움
```

### 3-Tier 아키텍처

```
클라이언트 ←→ 애플리케이션 서버 ←→ 데이터베이스 서버

계층 구분:
- Presentation Tier: 사용자 인터페이스
- Application Tier: 비즈니스 로직
- Data Tier: 데이터 저장 및 관리

장점:
✅ 역할 분리로 유지보수 향상
✅ 확장성 개선
✅ 보안 강화
```

### N-Tier 아키텍처

```
클라이언트 ←→ 웹 서버 ←→ WAS ←→ DB 서버
              ↓
         로드 밸런서, CDN 등 추가

특징:
✅ 고도로 세분화된 계층
✅ 마이크로서비스 아키텍처의 기반
✅ 높은 확장성과 가용성
```

# 2. 웹 서버와 WAS (Web Application Server)

## 2-1. 웹서버 (Web Server)

- **역할** : 정적 콘텐츠 제공, HTTP 요청 처리
- **대표적인 예** : Apache, Nginx
- **처리 콘텐츠** : HTML, CSS, JS, 이미지, 비디오 등

### 웹 서버 특징

```
정적 콘텐츠 처리:
1. HTML 파일
2. CSS 스타일시트
3. JavaScript 파일
4. 이미지 (JPG, PNG, GIF)
5. 비디오 파일

기본 기능:
✅ HTTP 요청/응답 처리
✅ 정적 파일 서빙
✅ 가상 호스팅
✅ 리버스 프록시
✅ SSL/TLS 지원
```

## 2-2. WAS (Web Application Server)

- **역할** : 동적 콘텐츠 생성, 비즈니스 로직 처리
- **대표적인 예** : Tomcat, Node.js
- **처리 방식** : 프로그래밍 언어로 동적 생성

### WAS 특징

```
동적 콘텐츠 처리:
1. 서버사이드 스크립트 (PHP, JSP, ASP)
2. 데이터베이스 연동
3. 사용자 인증/권한
4. 비즈니스 로직 (주문, 결제 등)

고급 기능:
✅ 애플리케이션 로직 실행
✅ 데이터베이스 커넥션 풀
✅ 트랜잭션 관리
✅ 보안 관리
✅ 클러스터링
```

## 2-3. 웹 서버 vs WAS 비교

| 특성            | 웹 서버                   | WAS                    |
| --------------- | ------------------------- | ---------------------- |
| **주요 역할**   | 정적 콘텐츠 제공          | 동적 콘텐츠 생성       |
| **처리 방식**   | 파일 시스템에서 직접 서빙 | 프로그램 실행으로 생성 |
| **성능**        | 빠름                      | 상대적으로 느림        |
| **자원 사용량** | 적음                      | 많음                   |
| **확장성**      | 수평 확장 쉬움            | 복잡함                 |
| **예시**        | Apache, Nginx             | Tomcat, Node.js        |

## 2-4. 웹 서버 + WAS 연동 아키텍처

### 연동 웹 시스템 구조

```
클라이언트 → 웹 서버 →  WAS  → 데이터베이스
           (Nginx) (Tomcat)  (MySQL)

요청 흐름:
1. 정적 파일 요청 → 웹 서버에서 직접 처리
2. 동적 요청 → 웹 서버가 WAS로 전달
3. WAS가 비즈니스 로직 처리 후 응답
4. 웹 서버가 클라이언트에게 최종 응답
```

-> **역할이 분담** 되어 **성능은 향상**되고 웹 서버가 방화벽 역할을 하며 WAS를 내부 네트워크에 배치하게 되어 **보안이 강화**된다.

# 3. 로드 밸런싱

## 3-0. 로드 밸런싱이란?

- **목적** : 여러 서버에 트래픽을 분산하여 성능과 가용성 향상
- **위치** : 클라이언트와 서버 사이에 배치
- **효과** : 단일 장애점 제거, 확장성 확보

## 3-1. L4 vs L7 로드 밸런서

### L4 로드 밸런서 (네트워크 계층)

```
특징:
1. IP 주소와 포트 번호 기반 분산
2. 빠른 처리 속도
3. 상대적으로 저렴
4. 패킷 내용을 보지 않음

동작 방식:
클라이언트 → L4 LB → 서버1 (192.168.1.10:80)
                  → 서버2 (192.168.1.11:80)
                  → 서버3 (192.168.1.12:80)

장점: 높은 처리량, 낮은 지연시간
단점: 세밀한 제어 불가, 애플리케이션 인식 불가
```

### L7 로드 밸런서 (애플리케이션 계층)

```
특징:
1. HTTP 헤더, URL, 쿠키 기반 분산
2. 애플리케이션 레벨 인식
3. 정교한 트래픽 제어 가능
4. L4보다 느림

동작 방식:
/api/user/* → 사용자 서버들
/api/order/* → 주문 서버들
/static/* → 정적 파일 서버들

장점: 정교한 제어, 애플리케이션 최적화
단점: 높은 자원 사용량, 복잡한 설정
```

## 3-2. 로드 밸런싱 알고리즘

### 라운드 로빈 (Round Robin)

```
요청을 순서대로 분배:
요청1 → 서버A
요청2 → 서버B
요청3 → 서버C
요청4 → 서버A (다시 처음부터)

장점: 구현 간단, 균등 분배
단점: 서버 성능 차이 고려 안함
```

### 가중치 라운드 로빈 (Weighted Round Robin)

```
서버 성능에 따라 가중치 부여:
서버A (가중치 3): 3번 처리
서버B (가중치 2): 2번 처리
서버C (가중치 1): 1번 처리

장점: 서버 성능 차이 반영
단점: 실시간 부하 상태 미반영
```

### 최소 연결 (Least Connections)

```
현재 연결 수가 가장 적은 서버로 분배:
서버A: 연결 5개
서버B: 연결 3개 ← 다음 요청 처리
서버C: 연결 7개

장점: 실시간 부하 반영
단점: 연결 추적 오버헤드
```

### IP 해시 (IP Hash)

```
클라이언트 IP를 해시하여 고정 서버 할당:
hash(클라이언트IP) % 서버수 = 서버 선택

예: 192.168.1.100 → 항상 서버B

장점: 세션 유지 (sticky session)
단점: 부하 불균등 가능
```

# 4. 프록시 서버와 리버스 프록시

## 4-1. 프록시 서버 (Forward Proxy)

- **위치** : 클라이언트와 인터넷 사이
- **목적** : 클라이언트를 대신하여 요청 전달
- **주 사용자** : 기업, 학교 등 조직

### 포워드 프록시 동작

```
클라이언트 → 프록시 서버 → 인터넷 → 목적지 서버
                ↑
         클라이언트를 대신함

주요 기능:
1. 웹 필터링 (특정 사이트 차단)
2. 접속 로그 기록
3. 캐싱으로 속도 향상
4. NAT 기능 (IP 공유)
5. 익명성 제공
```

## 4-2 리버스 프록시 (Reverse Proxy)

- **위치** : 서버와 인터넷 사이
- **목적** : 서버를 대신하여 응답 제공
- **주 사용자** : 웹 서비스 제공업체

### 리버스 프록시 동작

```
클라이언트 → 인터넷 → 리버스 프록시 → 백엔드 서버들
                         ↑
                    서버를 대신함

주요 기능:
1. 로드 밸런싱
2. 보안 강화 (서버 숨김)
3. SSL 종료 (SSL Termination)
4. 정적 콘텐츠 캐싱
5. 압축 및 최적화
```

## 4-3 프록시 vs 리버스 프록시 비교

| 특성       | 포워드 프록시     | 리버스 프록시     |
| ---------- | ----------------- | ----------------- |
| **위치**   | 클라이언트 앞     | 서버 앞           |
| **대상**   | 클라이언트 대신   | 서버 대신         |
| **목적**   | 접근 제어, 캐싱   | 부하 분산, 보안   |
| **사용자** | 기업, 개인        | 웹 서비스 업체    |
| **투명성** | 클라이언트가 인식 | 클라이언트가 모름 |

# 5. CDN (Content Delivery Network)

## 5-0. CDN이란 ?

- **목적** : 전 세계에 분산된 서버를 통해 콘텐츠를 빠르게 제공
- **원리** : 사용자와 가장 가까운 서버에서 콘텐츠 제공
- **대상** : 주로 정적 콘텐츠 (이미지, 비디오, CSS, JS 등)

## 5-1. CDN 동작 원리

### CDN 없이 콘텐츠 제공

```
한국 사용자 → 미국 서버 (RTT: 200ms)
일본 사용자 → 미국 서버 (RTT: 150ms)
유럽 사용자 → 미국 서버 (RTT: 300ms)

문제점:
❌ 긴 응답 시간
❌ 높은 대역폭 비용
❌ 서버 부하 집중
```

### CDN 사용 시 콘텐츠 제공

```
한국 사용자 → 서울 CDN 노드 (RTT: 10ms)
일본 사용자 → 도쿄 CDN 노드 (RTT: 15ms)
유럽 사용자 → 런던 CDN 노드 (RTT: 20ms)

개선 효과:
✅ 빠른 응답 시간
✅ 대역폭 비용 절감
✅ 원본 서버 부하 감소
```

### 주요 CDN 서비스 비교

| 서비스                  | 특징                 | 강점                 |
| ----------------------- | -------------------- | -------------------- |
| **Cloudflare**          | 전 세계 200+ 노드    | 보안, DDoS 방어      |
| **Amazon CloudFront**   | AWS 생태계 통합      | 확장성, 다양한 기능  |
| **Google Cloud CDN**    | Google 네트워크 활용 | 성능, YouTube 최적화 |
| **Microsoft Azure CDN** | Azure 통합           | 기업용, 하이브리드   |
