# 1. 클라우드 컴퓨팅

## 1-0. 클라우드 컴퓨팅이란?

- **정의** : 인터넷을 통해 IT 리소스를 온디맨드로 제공하는 서비스
- **핵심** : 물리적 서버 없이 필요할 때 필요한 만큼 사용
- **과금** : 사용한 만큼만 비용 지물 (Pay-as-you-go)

## 1-1. 클라우드 서비스 모델 (IaaS, PaaS, SaaS)

### IaaS (Infrastructure as a Service)

```
제공 범위: 하드웨어 인프라
사용자 관리: OS, 런타임, 애플리케이션
특징: 가상 컴퓨터만 빌려주는 서비스

┌─────────────────┐
│   애플리케이션    │ ← 사용자 관리
├─────────────────┤
│     런타임       │ ← 사용자 관리
├─────────────────┤
│       OS        │ ← 사용자 관리
├─────────────────┤
│   가상화/하드웨어 │ ← 클라우드 제공
└─────────────────┘

대표 서비스:
🔹 AWS EC2: 가상 서버 인스턴스
🔹 Google Compute Engine: 가상 머신
🔹 Azure Virtual Machines: 가상 컴퓨터
🔹 네이버 클라우드 서버

사용 사례:
✅ 기존 애플리케이션 그대로 이전
✅ 개발/테스트 환경 구축
✅ 완전한 제어권이 필요한 경우
✅ 커스텀 OS 설정 필요
```

### PaaS (Platform as a Service)

```
제공 범위: 하드웨어 + OS + 런타임
사용자 관리: 애플리케이션만
특징: 개발 환경까지 세팅해주는 서비스

┌─────────────────┐
│   애플리케이션    │ ← 사용자 관리
├─────────────────┤
│     런타임       │ ← 클라우드 제공
├─────────────────┤
│       OS        │ ← 클라우드 제공
├─────────────────┤
│   가상화/하드웨어 │ ← 클라우드 제공
└─────────────────┘

대표 서비스:
🔹 Heroku: 웹 애플리케이션 플랫폼
🔹 AWS Elastic Beanstalk: 애플리케이션 배포
🔹 Google App Engine: 앱 실행 환경
🔹 Azure App Service: 웹앱 호스팅

사용 사례:
✅ 빠른 애플리케이션 개발/배포
✅ 인프라 관리 부담 제거
✅ 자동 스케일링 필요
✅ 개발에만 집중하고 싶을 때
```

### SaaS (Software as a Service)

```
제공 범위: 완성된 소프트웨어 애플리케이션
사용자 관리: 데이터와 설정만
특징: 완성된 소프트웨어를 바로 쓰는 서비스

┌─────────────────┐
│   애플리케이션    │ ← 클라우드 제공
├─────────────────┤
│     런타임       │ ← 클라우드 제공
├─────────────────┤
│       OS        │ ← 클라우드 제공
├─────────────────┤
│   가상화/하드웨어 │ ← 클라우드 제공
└─────────────────┘

대표 서비스:
🔹 Gmail: 이메일 서비스
🔹 Office 365: 오피스 소프트웨어
🔹 Salesforce: CRM 솔루션
🔹 Slack: 협업 도구
🔹 Zoom: 화상 회의
🔹 Netflix: 스트리밍 서비스

사용 사례:
✅ 즉시 사용 가능한 완성된 서비스
✅ 별도 설치/관리 불필요
✅ 어디서나 접근 가능
✅ 협업과 공유 중심
```

## 1-2. IaaS, PaaS, SaaS 비교

| 특성         | IaaS            | PaaS   | SaaS        |
| ------------ | --------------- | ------ | ----------- |
| 제어 수준    | 높음            | 중간   | 낮음        |
| 관리 복잡도  | 높음            | 중간   | 낮음        |
| 개발 속도    | 느림            | 빠름   | 즉시 사용   |
| 커스터마이징 | 높음            | 중간   | 낮음        |
| 비용         | 가변적          | 중간   | 구독제      |
| 대상 사용자  | 인프라 엔지니어 | 개발자 | 최종 사용자 |

## 1-3. 클라우드 도입 전략

### 클라우드 마이그레이션 전략 (6R) - 알아만 두자

```
1. Rehost (Lift & Shift):
   기존 시스템을 그대로 클라우드로 이전
   장점: 빠른 이전, 위험 낮음
   단점: 클라우드 이점 활용 제한

2. Replatform (Lift & Reshape):
   최소한의 수정으로 클라우드 최적화
   예: DB를 RDS로 변경

3. Refactor (Re-architect):
   클라우드 네이티브로 완전 재설계
   장점: 최대 이점 활용
   단점: 높은 비용과 위험

4. Repurchase:
   기존 라이선스를 SaaS로 교체
   예: 온프레미스 CRM → Salesforce

5. Retire:
   불필요한 애플리케이션 폐기

6. Retain:
   온프레미스에 유지
```

# 2. 컨테이너화 (Docker, Kubernetes)

## 2-0. 컨테이너화란?

- 정의 : 애플리케이션과 실행 환경을 하나의 패키지로 묶는 기술
- 목적 : "내 컴퓨터에서는 잘 되는데" 문제 해결
- 원리 : OS 수준 가상화로 격리된 실행 환경 제공

## 2-1. Docker

### Docker의 핵심 개념

```
기존 개발 환경 문제:
😰 "내 컴퓨터에서는 잘 되는데..."
😰 개발/스테이징/프로덕션 환경 차이
😰 라이브러리 버전 충돌
😰 복잡한 배포 과정

Docker 해결책:
✅ 애플리케이션 + 실행 환경을 하나로 패키징
✅ 어디서든 동일하게 실행
✅ 빠른 시작과 종료
✅ 가벼운 리소스 사용
```

### 가상머신 vs Docker 컨테이너

```
가상머신 (Virtual Machine):
┌──────────────────────────────┐
│         애플리케이션           │
├──────────────────────────────┤
│          게스트 OS            │  ← 각각 독립적인 OS
├──────────────────────────────┤
│         하이퍼바이저           │
├──────────────────────────────┤
│          호스트 OS            │
├──────────────────────────────┤
│         물리 하드웨어          │
└──────────────────────────────┘

Docker 컨테이너:
┌──────────────────────────────┐
│         애플리케이션           │
├──────────────────────────────┤
│      Docker 컨테이너          │  ← OS 공유, 빠르고 가벼움
├──────────────────────────────┤
│         Docker 엔진           │
├──────────────────────────────┤
│          호스트 OS            │
├──────────────────────────────┤
│         물리 하드웨어          │
└──────────────────────────────┘
```

### Docker 주요 구성요소

```
🖼️ Image (이미지):
- 실행 가능한 패키지 (애플리케이션 + 환경)
- 읽기 전용, 불변
- 예: nginx:latest, node:16, python:3.9

📦 Container (컨테이너):
- 이미지를 실행한 인스턴스
- 실제로 동작하는 애플리케이션
- 여러 컨테이너가 같은 이미지 사용 가능

📝 Dockerfile:
- 이미지를 만들기 위한 명령어 스크립트
- 코드로 인프라 정의 (Infrastructure as Code : IaC)

🏪 Registry (레지스트리):
- 이미지를 저장하고 공유하는 저장소
- Docker Hub (공개), ECR, Harbor 등
```

### Dockerfile 예시

```dockerfile
# Node.js 애플리케이션 Dockerfile
FROM node:16-alpine           # 베이스 이미지

WORKDIR /app                  # 작업 디렉터리 설정

COPY package*.json ./         # 의존성 파일 복사
RUN npm install               # 패키지 설치

COPY . .                      # 소스 코드 복사

EXPOSE 3000                   # 포트 노출

CMD ["npm", "start"]          # 실행 명령
```

## 2-2. Kubernetes

### Kubernetes란?

- 정의 : 컨테이너 오케스트레이션 플랫폼
- 목적 : 수많은 컨테이너를 자동으로 관리
- Google 개발 : 15년간의 컨테이너 운영 경험을 오픈소스화

### 왜 Kubernetes가 필요한가?

```
Docker만으로는 해결할 수 없는 문제들:

🤔 컨테이너가 죽으면 누가 다시 시작시킬까?
🤔 트래픽이 증가하면 컨테이너를 자동으로 늘릴 수 있을까?
🤔 여러 서버에 컨테이너를 어떻게 배포할까?
🤔 컨테이너끼리 어떻게 네트워킹할까?
🤔 설정과 비밀번호를 어떻게 관리할까?

Kubernetes 해결책:
✅ 자동 복구 (Self-healing)
✅ 자동 스케일링 (Auto-scaling)
✅ 서비스 디스커버리 (Service Discovery)
✅ 로드 밸런싱 (Load Balancing)
✅ 롤링 업데이트 (Rolling Update)
✅ 설정 관리 (ConfigMap, Secret)
```

### Kubernetes 클러스터 구조

```
Master Node (Control Plane):
┌─────────────────────────────┐
│ API Server: 모든 요청 처리    │
│ etcd: 클러스터 상태 저장       │
│ Scheduler: Pod 배치 결정     │
│ Controller: 상태 관리        │
└─────────────────────────────┘
               │
         ┌─────┴─────┐
 Worker Node 1     Worker Node 2
┌─────────────┐   ┌─────────────┐
│ kubelet     │   │ kubelet     │  ← 노드 에이전트
│ kube-proxy  │   │ kube-proxy  │  ← 네트워크 관리
│ Container   │   │ Container   │  ← Docker 등
│ Runtime     │   │ Runtime     │
│             │   │             │
│ Pod │ Pod   │   │ Pod │ Pod   │  ← 실제 애플리케이션
└─────────────┘   └─────────────┘
```

### Kubernetes 주요 오브젝트

### 1. POD

```
Pod: 가장 작은 배포 단위
- 1개 이상의 컨테이너 묶음
- 같은 Pod 내 컨테이너는 IP와 볼륨 공유
- 일반적으로 1 Pod = 1 Container
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
    - name: nginx
      image: nginx:1.20
      ports:
        - containerPort: 80
```

### 2. Deployment

```
Deployment: Pod의 배포와 관리
- 원하는 상태 선언 (Desired State)
- 자동 복구, 롤링 업데이트
- ReplicaSet을 통한 Pod 복제 관리
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3 # 3개 Pod 유지
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.20
          ports:
            - containerPort: 80
```

### 3. Service

```
Service: Pod에 접근하는 방법 정의
- Pod는 언제든 죽고 다시 생성될 수 있음
- Service는 변하지 않는 접근점 제공
- 로드 밸런싱 기능 포함

종류:
🔹 ClusterIP: 클러스터 내부에서만 접근
🔹 NodePort: 노드의 특정 포트로 외부 접근
🔹 LoadBalancer: 클라우드 로드밸런서 사용
🔹 ExternalName: 외부 서비스와 연결
```

### 4. ConfigMap & Secret

```
ConfigMap: 설정 정보 저장
- 애플리케이션 설정을 코드와 분리
- 환경별 다른 설정 적용 가능

Secret: 민감한 정보 저장
- 패스워드, API 키, 인증서 등
- Base64 인코딩되어 저장
- 실제로는 암호화 추가 필요
```

### Kubernetes 장점

```
확장성:
- 자동 스케일링 (HPA, VPA, CA)
- 수천 개 노드까지 확장 가능

안정성:
- 자동 복구 (Pod 재시작, 노드 교체)
- 롤링 업데이트로 무중단 배포

이식성:
- 클라우드 벤더 독립적
- 온프레미스, 하이브리드 환경 지원

효율성:
- 리소스 효율적 활용
- 멀티테넌시 지원
```
