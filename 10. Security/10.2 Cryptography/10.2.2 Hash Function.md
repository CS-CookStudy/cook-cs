# 10.2.2 Hash Function

## 1. 해시 함수 기본 개념

### 정의 및 동작 원리
**해시 함수는 임의의 크기 데이터를 고정된 크기의 해시값(다이제스트)으로 변환하는 함수**이다.
원본 데이터를 복원할 수 없는 단방향 함수로, 데이터의 무결성 검증과 보안에 핵심적으로 사용된다.

### 입력 → 해시값 변환 과정
```
입력 데이터 (임의 크기) → 해시 함수 → 해시값 (고정 크기)

예시:
"Hello World" → SHA-256 → a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e
"Hello World!" → SHA-256 → 7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069
```

입력 데이터가 1비트만 바뀌어도 완전히 다른 해시값이 생성된다.

---

## 2. 해시 함수 핵심 특성

### 결정적(Deterministic)
- **동일한 입력은 항상 동일한 해시값 생성**
- 같은 알고리즘으로 몇 번을 실행해도 결과가 동일

### 고정 크기 출력(Fixed-size Output)
- **입력 크기와 관계없이 항상 같은 길이의 해시값 출력**
- SHA-256: 256비트(32바이트) 고정
- MD5: 128비트(16바이트) 고정

### 일방향성(One-way)
- **해시값으로부터 원본 데이터 복원 불가능**
- 계산상 역방향 연산이 불가능하도록 설계

### 눈사태 효과(Avalanche Effect)
- **입력의 작은 변화가 출력에 큰 변화를 야기**
- 1비트 변경 시 해시값의 약 50%가 변경됨
- 유사한 입력값들의 해시값이 완전히 달라짐

---

## 3. 해시 함수 보안 3대 성질

### Preimage Resistance (선이미지 저항성)
- **해시값 h가 주어졌을 때, h = hash(m)인 메시지 m을 찾는 것이 계산상 불가능**
- "일방향성"과 같은 개념
- 공격자가 해시값만 보고 원본을 역추적할 수 없어야 함

### Second Preimage Resistance (제2 선이미지 저항성)
- **메시지 m1이 주어졌을 때, hash(m1) = hash(m2)인 다른 메시지 m2를 찾는 것이 불가능**
- 약한 충돌 저항성이라고도 함
- 특정 문서의 해시값과 같은 해시값을 가진 악의적 문서 생성 방지

### Collision Resistance (충돌 저항성)
- **hash(m1) = hash(m2)인 서로 다른 메시지 쌍 (m1, m2)를 찾는 것이 불가능**
- 강한 충돌 저항성이라고도 함
- 임의의 두 입력이 같은 해시값을 갖지 않아야 함

---

## 4. 주요 해시 알고리즘

### MD5 (Message Digest 5)
- **출력 크기**: 128비트 (32자리 16진수)
- **상태**: 충돌 공격 취약점 발견으로 **사용 금지**
- **문제점**: 2004년 이후 효율적인 충돌 공격 방법 발견
- **현재 용도**: 파일 무결성 검사 정도로만 제한적 사용

### SHA-1 (Secure Hash Algorithm 1)
- **출력 크기**: 160비트 (40자리 16진수)
- **상태**: 2017년 구글이 실제 충돌 사례 공개로 **사용 금지**
- **문제점**: 이론적으로 2^63 연산으로 충돌 생성 가능 (원래는 2^80)

### SHA-2 (SHA-256, SHA-512 등)
- **SHA-256**: 256비트 출력, **현재 표준**
- **SHA-512**: 512비트 출력, 더 높은 보안 강도
- **상태**: 현재까지 안전하며 널리 사용
- **용도**: TLS/SSL, 비트코인, 디지털 서명

### SHA-3 (Keccak)
- **출력 크기**: SHA-256/512와 동일하지만 **완전히 다른 구조**
- **상태**: 2015년 NIST 표준, SHA-2 대체 목적
- **특징**: 스폰지 함수 구조로 SHA-2와 다른 접근법

### BLAKE2/BLAKE3 (최신 고성능 대안)
- **BLAKE2**: SHA-3 후보였던 알고리즘의 개선 버전
- **BLAKE3**: 병렬 처리에 최적화된 최신 해시
- **특징**: SHA-256보다 빠르면서도 안전함
- **용도**: 고성능이 필요한 시스템에서 점점 채택

---

## 5. 솔트와 KDF

### 레인보우 테이블 공격과 솔트(Salt)
**레인보우 테이블**: 자주 사용되는 비밀번호와 해시값을 미리 계산해 놓은 테이블
```
password123 → ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
admin       → 8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918
```

**솔트(Salt)**: 비밀번호에 추가하는 임의의 값으로 레인보우 테이블 공격 방지
```
password123 + salt(a1b2c3) → SHA-256 → 완전히 다른 해시값
```

### KDF (Key Derivation Function)의 필요성
**일반 해시 함수의 한계**: 너무 빨라서 브루트포스 공격에 취약
- GPU로 초당 수십억 개의 해시 계산 가능
- 단순한 비밀번호는 쉽게 뚫림

**KDF의 목적**: **의도적으로 느리게** 만들어 공격 비용 증가

### 주요 KDF 알고리즘

#### PBKDF2 (Password-Based Key Derivation Function 2)
- **원리**: 해시 함수를 수천~수만 번 반복
- **매개변수**: 반복 횟수(iterations), 솔트
- **장점**: 널리 지원되고 검증됨
- **단점**: GPU 병렬 공격에 상대적으로 취약

#### bcrypt
- **원리**: Blowfish 암호화를 기반으로 한 적응형 함수
- **매개변수**: cost factor (2^cost 만큼 느려짐)
- **장점**: GPU 병렬화가 어려움
- **단점**: 메모리 사용량이 적어 ASIC 공격 가능

#### scrypt
- **원리**: 메모리 집약적 연산으로 병렬 공격 방어
- **매개변수**: N(메모리 비용), r(블록 크기), p(병렬화)
- **장점**: 메모리를 많이 사용해 ASIC 공격 어려움
- **단점**: 메모리 사용량이 많아 서버 부하

#### Argon2
- **상태**: 2015년 비밀번호 해싱 경쟁 우승작
- **종류**: Argon2d, Argon2i, Argon2id
- **특징**: 메모리·시간·병렬화 모두 조절 가능
- **권장**: **현재 가장 권장되는 KDF**

---

## 6. 해시 충돌과 이론적 한계

### 충돌의 개념
**해시 충돌**: 서로 다른 입력 데이터가 같은 해시값을 갖는 현상
```
hash(데이터A) = hash(데이터B)  # 데이터A ≠ 데이터B
```

### 생일 문제 (Birthday Paradox)
**원리**: n개 값 중에서 충돌이 일어날 확률은 예상보다 훨씬 높음

**수학적 계산**:
- 23명이 모이면 생일이 같은 사람이 있을 확률 > 50%
- 70명이 모이면 99.9% 확률

**해시에 적용**:
- n비트 해시에서 충돌 발생 예상 시도 횟수: **√(2^n) = 2^(n/2)**
- SHA-256 (256비트): 2^128번 시도하면 충돌 기대
- MD5 (128비트): 2^64번 시도하면 충돌 기대 (현실적으로 가능)

### 해시 길이와 보안 강도 관계

| 해시 알고리즘 | 출력 길이 | 충돌 난이도 | 보안 수준 |
|---------------|-----------|-------------|-----------|
| **MD5** | 128비트 | 2^64 | 취약 |
| **SHA-1** | 160비트 | 2^80 | 취약 |
| **SHA-256** | 256비트 | 2^128 | 안전 |
| **SHA-512** | 512비트 | 2^256 | 매우 안전 |

**권장사항**: 최소 SHA-256 이상 사용

---

## 7. 실제 사용 사례

### 비밀번호 저장 (솔트 + KDF)
```
사용자 비밀번호 → 솔트 추가 → KDF(Argon2) → 해시값 저장
로그인 시: 입력 비밀번호 → 동일 과정 → 저장된 해시와 비교
```

### 데이터 무결성 검증 (파일 해시, 체크섬)
```
파일 다운로드 시:
1. 서버에서 파일의 SHA-256 해시 제공
2. 클라이언트가 다운로드 후 해시 계산
3. 두 해시값 비교로 무결성 확인
```

### 디지털 서명 (해시 후 서명)
```
큰 문서 → 해시(SHA-256) → 해시값을 개인키로 서명
검증: 문서 해시 계산 → 서명을 공개키로 검증 → 해시값 비교
```

### 블록체인
#### 머클 트리 (Merkle Tree)
- 트랜잭션들을 해시로 연결하여 트리 구조 생성
- 루트 해시 하나로 모든 트랜잭션 무결성 검증 가능

#### 블록 해시
- 각 블록의 헤더를 해시하여 블록 식별
- 이전 블록 해시를 포함하여 체인 연결

#### PoW 난이도 (작업 증명)
- 특정 조건을 만족하는 해시값 찾기 경쟁
- 비트코인: 해시값이 특정 수보다 작아야 함 (0이 많이 나와야 함)

---

## 8. 핵심 요약

```
해시: 단방향·고정길이·충돌저항성
보안 3대 성질: Preimage, 2nd Preimage, Collision Resistance  
MD5/SHA-1: 취약 → SHA-256 이상 권장
비밀번호: 반드시 솔트 + KDF(Argon2) 사용
```

- **해시는 단방향·고정 길이·충돌에 강한 요약 함수**
- **보안성은 보안 3대 성질**로 정의 (Preimage, Second Preimage, Collision)
- **MD5·SHA-1은 취약** → SHA-256 이상 권장
- **비밀번호 저장은 반드시 솔트 + KDF** 사용 (Argon2 권장)
- **활용 분야**: 무결성 검증, 디지털 서명, 블록체인, 비밀번호 저장
- **생일 문제**: n비트 해시의 충돌 난이도는 2^(n/2)