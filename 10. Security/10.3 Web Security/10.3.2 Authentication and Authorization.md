# 10.3.2 Authentication and Authorization

## 1. 인증과 인가 기본 개념

### 정의 및 차이점
**인증(Authentication)** 과 **인가(Authorization)** 는 보안의 핵심 요소로, 서로 다른 목적을 가진다.

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
|------|----------------------|---------------------|
| **목적** | "당신이 누구인가?" | "당신이 무엇을 할 수 있는가?" |
| **정의** | 사용자 신원 확인 | 확인된 사용자의 권한 부여 |
| **시점** | 로그인 시점 | 리소스 접근 시점 |
| **예시** | 아이디/비밀번호 입력 | 관리자 페이지 접근 허용 |

### AAA 모델 (Authentication, Authorization, Accounting)
**AAA 모델**은 네트워크 보안의 표준 프레임워크이다.

- **Authentication (인증)**: 사용자 신원 확인
- **Authorization (인가)**: 권한에 따른 접근 제어
- **Accounting (계정관리)**: 사용자 활동 기록 및 감사

---

## 2. 인증 (Authentication)

### 정의 및 목적
**사용자가 주장하는 신원이 올바른지 확인하는 과정**이다.
시스템에 접근하려는 주체(사용자, 디바이스, 애플리케이션)의 정체성을 검증한다.

### 인증 방식 종류

#### 1) 지식 기반 인증 (Something You Know)
사용자가 **알고 있는 정보**로 인증하는 방식
- **비밀번호 (Password)**: 가장 일반적인 방식
- **PIN (Personal Identification Number)**: 숫자 조합
- **보안 질문**: 개인정보 기반 질문/답변

**장점**: 구현이 단순하고 비용이 적음  
**단점**: 브루트포스, 사회공학 공격에 취약

#### 2) 소유 기반 인증 (Something You Have)
사용자가 **소유한 물건**으로 인증하는 방식
- **OTP (One-Time Password)**: 시간/카운터 기반 일회용 비밀번호
- **스마트카드**: 암호화 칩이 내장된 카드
- **하드웨어 토큰**: RSA SecurID 등
- **모바일 앱**: Google Authenticator, SMS 인증

**장점**: 물리적 소유가 필요해 상대적으로 안전  
**단점**: 분실/도난 위험, 배포/관리 비용

#### 3) 생체 기반 인증 (Something You Are)
사용자의 **고유한 생체 정보**로 인증하는 방식
- **지문 인식**: 가장 널리 사용됨
- **홍채 인식**: 높은 정확도
- **얼굴 인식**: 모바일에서 활용 증가
- **음성 인식**: 콜센터 등에서 활용

**장점**: 복제 어려움, 분실 불가능  
**단점**: 높은 비용, 프라이버시 문제

### 다중 인증 (MFA, Multi-Factor Authentication)
**두 개 이상의 서로 다른 인증 요소를 결합**하는 방식
```
2단계 인증 예시:
1단계: 아이디/비밀번호 입력 (지식 기반)
2단계: 모바일 OTP 입력 (소유 기반)
```

**장점**: 하나의 인증 요소가 뚫려도 추가 보안  
**단점**: 사용자 편의성 저하, 구현 복잡도 증가

### 세션 관리
인증 후 사용자 상태를 유지하는 메커니즘

#### 세션 기반 인증
```
1. 로그인 성공 → 서버에서 세션 ID 생성
2. 세션 ID를 쿠키로 클라이언트에 전송
3. 이후 요청마다 세션 ID로 사용자 식별
```

#### 보안 고려사항
- **세션 ID 복잡도**: 추측하기 어려운 랜덤값
- **세션 타임아웃**: 일정 시간 후 자동 만료
- **Secure/HttpOnly 쿠키**: XSS, 중간자 공격 방지

---

## 3. 인가 (Authorization)

### 정의 및 목적
**인증된 사용자가 특정 리소스나 기능에 접근할 권한이 있는지 확인하는 과정**이다.
"누가 무엇을 할 수 있는가"를 결정하는 정책과 메커니즘이다.

### 접근 제어 모델

#### 1) DAC (Discretionary Access Control, 임의 접근 제어)
**리소스의 소유자가 다른 사용자에게 접근 권한을 부여**하는 방식
- 파일 시스템의 소유자/그룹/기타 권한 (rwx)
- 소유자가 자유롭게 권한 설정 가능

**장점**: 유연하고 관리가 쉬움  
**단점**: 보안 정책 일관성 부족, 권한 남용 가능

#### 2) MAC (Mandatory Access Control, 강제 접근 제어)
**중앙 집중식 보안 정책에 따라 접근 권한을 강제**하는 방식
- 보안 레이블 기반 (Top Secret, Secret, Confidential)
- 사용자나 소유자가 임의로 권한 변경 불가

**장점**: 일관된 보안 정책, 높은 보안 수준  
**단점**: 경직된 구조, 관리 복잡도 높음

#### 3) RBAC (Role-Based Access Control, 역할 기반 접근 제어)
**사용자의 역할(Role)에 따라 권한을 부여**하는 방식
```
사용자 → 역할 → 권한 → 리소스

예시:
- 관리자: 모든 기능 접근 가능
- 편집자: 컨텐츠 작성/수정 가능  
- 조회자: 읽기만 가능
```

**장점**: 관리 효율성, 확장성 좋음  
**단점**: 역할 설계의 복잡성

#### 4) ABAC (Attribute-Based Access Control, 속성 기반 접근 제어)
**다양한 속성들을 조합하여 동적으로 권한을 결정**하는 방식
```
속성 예시:
- 사용자 속성: 부서, 직급, 위치
- 리소스 속성: 분류, 소유자, 민감도
- 환경 속성: 시간, IP 주소, 디바이스

규칙 예시: "인사부 + 팀장급 이상 + 근무시간 + 사내 IP"일 때 인사 정보 접근 허용
```

**장점**: 세밀한 제어, 동적 정책  
**단점**: 복잡한 구현, 성능 오버헤드

### 권한 부여 방식

#### 최소 권한 원칙 (Principle of Least Privilege)
- 업무 수행에 **필요한 최소한의 권한만** 부여
- 정기적 권한 검토 및 불필요한 권한 회수

#### 직무 분리 (Separation of Duties)
- 중요한 작업을 **여러 사람에게 분산**하여 단독 수행 방지
- 예시: 결제 승인과 실행을 서로 다른 사람이 담당

---

## 4. 구현 방법

### JWT (JSON Web Token)
**클레임(Claim) 기반의 토큰** 인증 방식
```json
{
  "header": {
    "typ": "JWT",
    "alg": "HS256"
  },
  "payload": {
    "sub": "user123",
    "role": "admin",
    "exp": 1640995200
  },
  "signature": "서명값"
}
```

**장점**: 무상태(Stateless), 확장성 좋음  
**단점**: 토큰 크기, 만료 전 폐기 어려움

### OAuth 2.0
**제3자 서비스 인가**를 위한 개방형 표준 **인가 프레임워크**이다.
**주의**: OAuth 2.0은 인증이 아닌 **인가(Authorization) 전용**이며, 실제 인증은 OpenID Connect가 담당한다.

```
OAuth 2.0 플로우:
1. 사용자가 구글 로그인 버튼 클릭
2. 구글 인증 서버로 리다이렉트
3. 구글에서 인증 후 인가 코드 반환  
4. 애플리케이션이 인가 코드로 액세스 토큰 요청
5. 액세스 토큰으로 구글 API 호출 (인가된 범위 내에서)
```

**역할**:
- **Resource Owner**: 사용자
- **Client**: 애플리케이션
- **Authorization Server**: 구글 인증 서버
- **Resource Server**: 구글 API 서버

### 세션 기반 vs 토큰 기반

| 구분 | 세션 기반 | 토큰 기반 |
|------|-----------|-----------|
| **저장 위치** | 서버 메모리/DB | 클라이언트 |
| **상태 관리** | Stateful | Stateless |
| **확장성** | 서버 간 세션 공유 필요 | 서버 독립적 |
| **보안** | 서버 측 제어 가능 | 토큰 탈취 위험 |
| **성능** | 매번 세션 조회 | 토큰 검증만 필요 |

### SSO (Single Sign-On)
**한 번 로그인으로 여러 시스템 접근** 가능한 방식

#### SAML (Security Assertion Markup Language)
XML 기반의 SSO 표준, 주로 기업 환경에서 사용

#### OpenID Connect
**OAuth 2.0 기반의 인증 레이어**로, OAuth의 인가 기능에 인증 기능을 추가한 프로토콜이다.
웹/모바일에서 널리 사용되며, JWT 형태의 ID 토큰을 통해 사용자 인증 정보를 제공한다.

---

## 5. 보안 고려사항

### 세션 하이재킹 방지
- **HTTPS 강제 사용**: 네트워크 도청 방지
- **Secure 쿠키**: HTTPS에서만 전송
- **HttpOnly 쿠키**: JavaScript 접근 차단
- **세션 재생성**: 로그인 성공 시 새로운 세션 ID 발급

### 권한 상승 공격 방어
- **입력값 검증**: URL 매개변수, 폼 데이터 검증
- **접근 제어 검사**: 모든 요청에 대해 권한 확인
- **직접 객체 참조 방지**: 사용자가 직접 리소스 ID 조작 불가

### 패스워드 정책
- **길이 우선**: 최소 12자 이상 (NIST 최신 권장사항)
- **복잡도**: 대소문자, 숫자, 특수문자 조합 (선택적)
- **사용자 친화성**: 과도한 복잡도 요구보다는 긴 패스프레이즈 권장
- **이력 관리**: 최근 사용된 비밀번호 재사용 금지
- **계정 잠금**: 연속 실패 시 일정 시간 잠금
- **정기 변경 금지**: 강제 주기적 변경은 오히려 보안 약화 (NIST 권장)

---

## 6. 인증/인가 비교표

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
|------|---------------------|---------------------|
| **질문** | "당신은 누구인가?" | "무엇을 할 수 있는가?" |
| **목적** | 신원 확인 | 권한 확인 |
| **시점** | 로그인 시 | 리소스 접근 시 |
| **방법** | 비밀번호, OTP, 생체정보 | RBAC, ABAC, ACL |
| **결과** | 인증됨/안됨 | 허용됨/거부됨 |
| **구현** | 로그인 폼, MFA | 권한 체크, 접근 제어 |

### 관계성
```
인증 → 인가 → 리소스 접근

1. 사용자가 로그인 (인증)
2. 시스템이 사용자 권한 확인 (인가)  
3. 권한이 있다면 리소스 접근 허용
```

---

## 7. 핵심 요약

### 암기 포인트
```
인증: "누구인가?" → 비밀번호, OTP, MFA
인가: "무엇 가능?" → RBAC, 최소권한
AAA: Authentication + Authorization + Accounting
JWT: 토큰 기반, OAuth: 제3자 인가
```

- **인증**: 신원 확인 (Who) → 비밀번호, MFA, 생체인증
- **인가**: 권한 확인 (What) → RBAC, ABAC, 최소권한 원칙
- **AAA 모델**: 인증 + 인가 + 계정관리가 보안의 기본
- **실무 구현**: JWT(토큰), OAuth(제3자), SSO(단일 로그인)
- **보안 고려**: 세션 보안, 권한 상승 방지, 강력한 패스워드 정책
- **관계**: 인증이 선행되어야 인가가 가능함