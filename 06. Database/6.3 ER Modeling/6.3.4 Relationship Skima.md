# ER 모델을 관계형 스키마로 변환

## 1. 변환 개요

### 1.1 변환의 필요성

**ER 모델**은 개념적 설계 도구이므로, 실제 데이터베이스 구현을 위해서는 **관계형 스키마**로 변환해야 한다.

### 1.2 변환 과정

```
ER 모델 (개념적) → 관계형 스키마 (논리적) → 물리적 구현
```

### 1.3 변환 목표

- **정보 보존**: ER 모델의 모든 정보 유지
- **제약 조건 유지**: 무결성 제약 보장
- **성능 고려**: 효율적인 구조 설계

---

## 2. 기본 변환 규칙

### 2.1 개체 → 릴레이션 변환

#### 강한 개체의 변환

**ER 모델:**

```
학생 개체
├─ 학번 (키 속성)
├─ 이름
├─ 주소
└─ 전화번호
```

**관계형 스키마:**

```sql
학생(학번, 이름, 주소, 전화번호)
PRIMARY KEY: 학번
```

#### 변환 규칙

1. **개체 → 릴레이션**: 개체는 릴레이션이 됨
2. **속성 → 속성**: 개체의 속성은 릴레이션의 속성이 됨
3. **키 속성 → 기본 키**: 키 속성은 기본 키가 됨

### 2.2 약한 개체의 변환

#### ER 모델:

```
직원 ──◈소속◈── 부양가족
│               ├─ 이름 (부분 키)
├─ 사번 (키)     ├─ 관계
└─ 이름         └─ 생년월일
```

#### 관계형 스키마:

```sql
직원(사번, 이름)
부양가족(사번, 이름, 관계, 생년월일)
PRIMARY KEY: (사번, 이름)
FOREIGN KEY: 사번 REFERENCES 직원(사번)
```

#### 변환 규칙

1. **소유 개체의 키 포함**: 약한 개체에 소유 개체의 기본 키 추가
2. **복합 키 생성**: 소유 개체 키 + 부분 키 = 기본 키
3. **외래 키 제약**: 소유 개체와의 참조 무결성

---

## 3. 속성 변환 규칙

### 3.1 단순 속성

**변환**: 그대로 릴레이션의 속성이 됨

```
학생.이름 → 학생(이름)
```

### 3.2 복합 속성

#### ER 모델:

```
주소 = {시도, 시군구, 동, 상세주소}
```

#### 변환 방법 1: 분해

```sql
학생(학번, 이름, 시도, 시군구, 동, 상세주소)
```

#### 변환 방법 2: 통합

```sql
학생(학번, 이름, 주소)
-- 주소: "서울시 강남구 역삼동 123번지"
```

### 3.3 다중값 속성

#### ER 모델:

```
학생 ──◉ 전화번호 (다중값)
```

#### 변환: 별도 릴레이션 생성

```sql
학생(학번, 이름)
학생전화번호(학번, 전화번호)
PRIMARY KEY: (학번, 전화번호)
FOREIGN KEY: 학번 REFERENCES 학생(학번)
```

### 3.4 도출 속성

#### ER 모델:

```
학생
├─ 생년월일 (저장 속성)
└─ 나이 (도출 속성)
```

#### 변환: 저장 속성만 포함

```sql
학생(학번, 이름, 생년월일)
-- 나이는 생년월일로부터 계산
```

---

## 4. 관계 변환 규칙

### 4.1 이진 관계 변환

#### 4.1.1 일대일 관계 (1:1)

**ER 모델:**

```
사원 ←1:1→ 사원카드
```

**변환 방법 1: 외래 키 방식**

```sql
사원(사번, 이름, 카드번호)
사원카드(카드번호, 발급일자, 유효기간)
FOREIGN KEY: 카드번호 REFERENCES 사원카드(카드번호)
```

**변환 방법 2: 통합 방식**

```sql
사원(사번, 이름, 카드번호, 발급일자, 유효기간)
```

**변환 방법 3: 별도 릴레이션**

```sql
사원(사번, 이름)
사원카드(카드번호, 발급일자, 유효기간)
사원카드보유(사번, 카드번호)
```

#### 4.1.2 일대다 관계 (1:N)

**ER 모델:**

```
부서 ←1:N→ 사원
```

**변환: 다(N) 쪽에 외래 키 추가**

```sql
부서(부서코드, 부서명, 위치)
사원(사번, 이름, 급여, 부서코드)
FOREIGN KEY: 부서코드 REFERENCES 부서(부서코드)
```

#### 4.1.3 다대다 관계 (M:N)

**ER 모델:**

```
학생 ←M:N→ 과목 (관계 속성: 성적)
```

**변환: 별도 릴레이션 생성**

```sql
학생(학번, 이름, 학과)
과목(과목코드, 과목명, 학점)
수강(학번, 과목코드, 성적)
PRIMARY KEY: (학번, 과목코드)
FOREIGN KEY: 학번 REFERENCES 학생(학번)
FOREIGN KEY: 과목코드 REFERENCES 과목(과목코드)
```

### 4.2 삼진 관계 변환

**ER 모델:**

```
학생 ←→ 지도 ←→ 교수
      ↗     ↖
     과목
```

**변환: 별도 릴레이션 생성**

```sql
학생(학번, 이름)
교수(교수번호, 이름)
과목(과목코드, 과목명)
지도(학번, 교수번호, 과목코드, 지도시작일)
PRIMARY KEY: (학번, 교수번호, 과목코드)
```

### 4.3 순환 관계 변환

**ER 모델:**

```
사원 ←→ 관리 (상사-부하 관계)
```

**변환: 자기 참조 외래 키**

```sql
사원(사번, 이름, 직급, 상사사번)
FOREIGN KEY: 상사사번 REFERENCES 사원(사번)
```

---

## 5. 참여도와 대응수 제약 구현

### 5.1 전체 참여 (Total Participation)

**ER 모델:**

```
사원 ═══ 소속 ═══ 부서 (사원은 반드시 부서에 소속)
```

**구현:**

```sql
사원(사번, 이름, 부서코드 NOT NULL)
FOREIGN KEY: 부서코드 REFERENCES 부서(부서코드)
```

### 5.2 부분 참여 (Partial Participation)

**ER 모델:**

```
교수 ─── 관리 ─── 프로젝트 (일부 교수만 프로젝트 관리)
```

**구현:**

```sql
교수(교수번호, 이름)
프로젝트(프로젝트번호, 프로젝트명, 관리교수번호)
FOREIGN KEY: 관리교수번호 REFERENCES 교수(교수번호)
-- NULL 허용
```

### 5.3 대응수 제약

#### 최소/최대 대응수 표현

**ER 모델:**

```
부서 ←(1,1)─(5,50)→ 사원
-- 부서: 최소 5명, 최대 50명
-- 사원: 정확히 1개 부서에 소속
```

**구현 (제약 조건 사용):**

```sql
CREATE TABLE 부서 (
    부서코드 CHAR(3) PRIMARY KEY,
    부서명 VARCHAR(50),
    CHECK ((SELECT COUNT(*) FROM 사원 WHERE 부서코드 = 부서.부서코드)
           BETWEEN 5 AND 50)
);
```

---

## 6. 변환 최적화 전략

### 6.1 성능 최적화

#### 인덱스 고려

```sql
-- 자주 검색되는 외래 키에 인덱스
CREATE INDEX idx_사원_부서코드 ON 사원(부서코드);
```

#### 조인 성능 고려

```sql
-- 1:1 관계는 통합 고려
사원(사번, 이름, 카드번호, 발급일자) -- 통합
```

### 6.2 저장공간 최적화

#### NULL 값 최소화

```sql
-- 선택적 속성이 많은 경우 분리
기본사원정보(사번, 이름, 부서코드)
사원상세정보(사번, 취미, 특기, 비고)
```

#### 중복 제거

```sql
-- 다중값 속성의 정규화
학생(학번, 이름)
학생전화번호(학번, 전화번호, 전화번호유형)
```

---

## 7. 실전 예제

### 7.1 대학교 시스템 변환

#### ER 모델:

```
학생 ←M:N→ 수강(성적) ←N:1→ 과목 ←1:N→ 강의 ←N:1→ 교수
│                                                  │
└─ 소속 ←1:N→ 학과 ←1:N→ 근무 ←N:1→ ────────────────┘
```

#### 관계형 스키마:

```sql
-- 개체 변환
학과(학과코드, 학과명, 위치)
학생(학번, 이름, 학과코드)
교수(교수번호, 이름, 학과코드)
과목(과목코드, 과목명, 학점)

-- 관계 변환
수강(학번, 과목코드, 성적, 수강년도, 학기)
강의(교수번호, 과목코드, 강의시간, 강의실)

-- 외래 키 제약
FOREIGN KEY 학생.학과코드 REFERENCES 학과(학과코드)
FOREIGN KEY 교수.학과코드 REFERENCES 학과(학과코드)
FOREIGN KEY 수강.학번 REFERENCES 학생(학번)
FOREIGN KEY 수강.과목코드 REFERENCES 과목(과목코드)
FOREIGN KEY 강의.교수번호 REFERENCES 교수(교수번호)
FOREIGN KEY 강의.과목코드 REFERENCES 과목(과목코드)
```

### 7.2 온라인 쇼핑몰 변환

#### ER 모델:

```
고객 ←1:N→ 주문 ←1:N→ 주문상세 ←N:1→ 상품
                                    ↑
                            ┌───────┴───────┐
                          분류             공급
                            ↓               ↓
                          카테고리      공급업체
```

#### 관계형 스키마:

```sql
고객(고객ID, 이름, 주소, 전화번호, 이메일)
카테고리(카테고리코드, 카테고리명)
공급업체(업체코드, 업체명, 연락처)
상품(상품코드, 상품명, 가격, 재고수량, 카테고리코드, 업체코드)
주문(주문번호, 고객ID, 주문일자, 총금액, 배송주소)
주문상세(주문번호, 상품코드, 수량, 단가)

-- 기본 키
PRIMARY KEY 고객(고객ID)
PRIMARY KEY 상품(상품코드)
PRIMARY KEY 주문(주문번호)
PRIMARY KEY 주문상세(주문번호, 상품코드)

-- 외래 키
FOREIGN KEY 상품.카테고리코드 REFERENCES 카테고리(카테고리코드)
FOREIGN KEY 상품.업체코드 REFERENCES 공급업체(업체코드)
FOREIGN KEY 주문.고객ID REFERENCES 고객(고객ID)
FOREIGN KEY 주문상세.주문번호 REFERENCES 주문(주문번호)
FOREIGN KEY 주문상세.상품코드 REFERENCES 상품(상품코드)
```

---

## 8. 변환 검증

### 8.1 정보 보존 검증

#### 개체 정보 보존

```
✅ 모든 개체가 릴레이션으로 변환됨
✅ 모든 속성이 보존됨
✅ 키 속성이 기본 키로 설정됨
```

#### 관계 정보 보존

```
✅ 모든 관계가 외래 키로 표현됨
✅ 대응수 제약이 구현됨
✅ 관계 속성이 보존됨
```

### 8.2 제약 조건 검증

#### 개체 무결성

```sql
-- 모든 릴레이션에 기본 키 정의
ALTER TABLE 학생 ADD PRIMARY KEY (학번);
```

#### 참조 무결성

```sql
-- 모든 외래 키에 참조 제약 정의
ALTER TABLE 수강
ADD FOREIGN KEY (학번) REFERENCES 학생(학번);
```

#### 도메인 무결성

```sql
-- 속성 값의 유효성 검사
ALTER TABLE 학생
ADD CHECK (학번 LIKE '20%' AND LENGTH(학번) = 7);
```

---

## 9. 성능 최적화 고려사항

### 9.1 인덱스 전략

#### 기본 키 인덱스

```sql
-- 자동 생성됨
CREATE TABLE 학생 (
    학번 CHAR(7) PRIMARY KEY,  -- 자동 인덱스
    이름 VARCHAR(50)
);
```

#### 외래 키 인덱스

```sql
-- 조인 성능 향상
CREATE INDEX idx_수강_학번 ON 수강(학번);
CREATE INDEX idx_수강_과목코드 ON 수강(과목코드);
```

#### 복합 인덱스

```sql
-- 복합 조건 검색 최적화
CREATE INDEX idx_수강_학번_과목코드 ON 수강(학번, 과목코드);
```

### 9.2 정규화 vs 비정규화

#### 정규화 장점

- **데이터 일관성**: 중복 제거
- **저장공간 절약**: 효율적 저장
- **수정 이상 방지**: 업데이트 문제 해결

#### 비정규화 고려 상황

```sql
-- 자주 조인되는 테이블 통합 고려
학생기본정보(학번, 이름, 학과코드, 학과명)
-- 대신 학과명 중복 저장으로 조인 횟수 감소
```

### 9.3 파티셔닝 고려

#### 수평 파티셔닝

```sql
-- 연도별 분할
수강_2023(학번, 과목코드, 성적)
수강_2024(학번, 과목코드, 성적)
```

#### 수직 파티셔닝

```sql
-- 자주/드물게 사용되는 속성 분리
학생기본(학번, 이름, 학과코드)
학생상세(학번, 주소, 전화번호, 이메일)
```

---
