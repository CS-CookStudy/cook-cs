# 6.6 트랜잭션과 동시성 제어
# 6.6.4 락킹(Locking) 기법
---

# 락킹(Locking) 기법
> 트랜잭션들이 어떤 락킹 단위를 액세스 하기 전에 잠금(Lock)을 요청해서 Lock이 허락되어야만 그 락킹 단위를 액세스 할 수 있도록 하는 기법
- 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법
- 트랜잭션 간 **동시 실행 중 충돌 문제**(Lost Update, Dirty Read 등) 방지
- 주요 데이터의 액서스를 상호 배타적으로 함

## 락킹 단위(Locking Granularity)
> 병행제어에서 한꺼번에 락킹할 수 있는 객체의 크기
- 데이터베이스, 파일, 레코드, 필드 등이 락킹 단위가 될 수 있음
- 단위가 크면 Lock 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다.
- 단위가 작으면 Lock 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아진다.

> **❓ 병행성 수준**
>
> **데이터베이스 공유도**, 여러 작업이 동시에 실행될 수 있는 정도

## 락킹의 연산(`lock`, `unlock`) 과 락킹 규약
1. 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.
2. 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.
3. 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.
4. 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.

</br>

**이 때 읽기만 수행한다면 데이터를 수정하진 않기 때문에 굳이 접근 통제할 필요가 없다**
  
**➡️ `lock` 연산을 공용락, 배타락으로 나눌 수 있다**

## 공유 락(Shared lock, , S-lock)
- 트랜잭션이 데이터 x에 대해 `S-lock`을 설정할 경우, 이 트랜잭션은 x에 대해 **읽기(READ) 작업 가능**.
- 하지만, **쓰기(WRITE)는 불가능**
- 여러 트랜잭션이 **동시에** 공유 락을 걸 수 있음 (같이 읽는 건 OK)
  
   EX) T1이 S-lock 걸고 A 읽는 중 → T2도 A 읽기는 가능, 쓰기는 대기해야 함

## 배타 락(Exclusive Lock, X-lock)
- 트랜잭션이 데이터 x에 대해 `X-lock`을 설정할 경우, 이 트랜잭션은 x에 대해 **읽기(READ), 쓰기(WRITE) 작업 가능**.
- 해당 데이터, 자원에 대해 읽기/쓰기 모두 독점
- **다른 트랜잭션은 접근 불가**
  
    EX) T1이 X-lock 걸고 A 수정 중 → T2는 읽기든 쓰기든 A에 접근 못함
  
### 락 호환성 표
| 현재 락 | 새로운 요청 | 허용 여부          |
| ---- | ------ | -------------- |
| S    | S      | ✅ 가능 (공유 읽기)   |
| S    | X      | ❌ 대기 (쓰기 못 함)  |
| X    | S or X | ❌ 모두 대기 (독점 중) |

### 실제 DB 예시 (MySQL)
| 연산                              | 사용되는 락             |
| ------------------------------- | ------------------ |
| `SELECT ... LOCK IN SHARE MODE` | 공유 락               |
| `SELECT ... FOR UPDATE`         | 배타 락               |
| `UPDATE`, `DELETE`, `INSERT`    | 자동 배타 락(X-Lock) 부여 |

---
# 2단계 락킹 규약 (2PLP : Two Phase Locking Protocol)
- 락킹 규약을 따랐음에도 모순성이 발생 가능. 
- 트랜잭션 간 충돌을 방지하고 **직렬 가능성을 보장**하는 프로토콜
- 락을 **2단계**로 분리함.
    - **확장 단계(Growing phase)** : 새로운 lock 연산만을 수행할 수 있고, unlock 연산은 수행할 수 없는 단계
    - **축소 단계(shrinking phase)** : unlock 연산을 수행할 수 있고, lock연산은 수행할 수 없는 단계
- 트랜잭션 내의 모든 lock 연산이 첫 번째 unlock 연산 이전에 위치해야 함.
- 따라서 하나의 트랜잭션에서 데이터에 대한 연산을 완전히 끝낸 후 unlock 하므로 직렬성이 보장.

### 2단계 로킹을 따른 경우 (T1)
```sql
T1: S-Lock(X) → READ X
    X-Lock(X) → WRITE X
    UNLOCK(X)
    COMMIT
```
- T1은 락을 걸고 → 다 끝난 후에 해제 → 2단계 로킹을 지킴 → 문제 없음

### 2단계 로킹 위반한 경우 (T2)
```sql
T2: S-Lock(X) → READ X
    UNLOCK(X)
    X-Lock(X) → WRITE X
```
- 락을 해제한 후 다시 락을 걸었음 → 2PL 위반
- ➡️ 이런 방식은 직렬 실행처럼 동작하지 않으므로, 데이터 무결성이 깨질 수 있음

---

</br>

# 교착 상태(Deadlock)
> 둘 이상의 트랜잭션이 서로 상대가 갖고 있는 데이터 항목의 lock가 해제되기를 기다리기 때문에 트랜잭션의 실행이 중단되고 무한정 기다리는 상태를 의미
```
T1: LOCK A → WAIT FOR B
T2: LOCK B → WAIT FOR A
```
- T1은 A를 락 걸고 B를 기다림
- T2는 B를 락 걸고 A를 기다림
- 서로가 서로의 락이 풀리기를 기다리는 상태 → **데드락 발생**

## 데드락 발생 조건 (Coffman 조건)
1. 상호 배제(Mutual Exclusion): 자원을 한 트랜잭션만 사용할 수 있음
2. 점유 대기(Hold and Wait): 이미 자원을 점유한 상태로 다른 자원을 요청
3. 비선점(No Preemption): 자원을 강제로 회수할 수 없음
4. 순환 대기(Circle Wait): 트랜잭션 간에 원형 대기 그래프가 존재
  
- 이 네 가지가 **모두 충족**되면 데드락 발생 가능

## 데드락 탐지 : `Wait-For Graph (WFG, 대기 그래프) 분석`
> 트랜잭션을 노드, 자원 대기를 간선으로 표현한 그래프

- 그래프에 **사이클(Cycle)**이 존재하면 → 데드락 발생
```scss
T1 → T2 → T3 → T1 (사이클 존재) → 데드락
```
- 데이터베이스 엔진은 주기적으로 WFG를 분석하여 사이클을 탐지

## 데드락 해결 방법
- `회피` : 자원을 할당할 때마다 deadlock이 일어나지 않게 감시하는 방법. 각 트랜잭션의 타임스탬프를 이용하는 방법이 있다.
    - **wait-die 기법** : 트랜잭션 T1가 이미 트랜잭션 T2에 의해 lock한 데이터 항목을 요구할 때 만약 T1의 타임스탬프가 더 작을 경우, T1을 기다리게 하고, T1의 타임스탬프가 더 클 경우 T1을 포기(Rollback)하게 한다.
    - **wound-wait 기법** : 트랜잭션 T1가 이미 트랜잭션 T2에 의해 lock한 데이터 항목을 요구할 때 만약 T1의 타임스탬프가 더 작을 경우, T1은 데이터를 선점 하고, T1의 타임스탬프가 더 클 경우 T1을 기다리게 한다.

- `예방` : 트랜잭션을 실행하기 전에 필요한 모든 lock을 한번에 할당받고 전부 부여받지 못한다면 실행하지 않는 방법. 실현 가능성은 매우 낮다.

- `탐지` : lock 상태를 조사하여 일단 교착 상태가 발생하면 트랜잭션 중 하나를 취소(Rollback)시키는 것. 교착 상태를 탐지하는 방법은 대기 그래프를 그려보는 것이 효과적이며, 이 때 취소시킬 트랜잭션은 작업이 가장 적게 수행된 트랜잭션이 선정되는 것이 효율적이다.
    - 트랜잭션 선택 기준

        | 기준      | 설명                |
        | ------- | ----------------- |
       | 트랜잭션 길이 | 짧은 쪽을 종료 (작은 피해)  |
       | 리소스 소비량 | 적은 쪽을 종료          |
        | 우선순위    | 낮은 우선순위를 종료       |
        | 시간      | 가장 오래 대기한 트랜잭션 종료 |

  
> **❓ 타임스탬프**
>
> 데이터베이스에서 트랜잭션의 **시작 시점**에 부여되는 **고유한 번호**
> - 선입 선처리(먼저 시작한 트랜잭션을 우선시) 원칙을 따름
> - 일반적으로 단조 증가하는 정수값이나 시스템 시간 기반으로 부여됨
> - 트랜잭션이 시작될 때 DBMS가 자동으로 할당