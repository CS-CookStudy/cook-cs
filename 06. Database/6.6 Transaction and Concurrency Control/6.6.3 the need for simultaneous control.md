# 6.6 트랜잭션과 동시성 제어
# 6.6.3 동시성 제어의 필요성
---

# 동시성 제어(Comcurrency Control)이 필요한 이유
- **여러 사용자가 동시에 데이터베이스를 조작할 때, 데이터의 일관성과 무결성을 보장하기 위해**
- 여러 트랜잭션이 동시에 수행되면 다음과 같은 문제 발생 가능
| 문제 상황                            | 설명                                        |
| -------------------------------- | ----------------------------------------- |
| **데이터 손실 (Lost Update)**         | 두 트랜잭션이 같은 데이터를 읽고, 서로의 변경을 덮어씀           |
| **더티리드 (Dirty Read)**       | 한 트랜잭션이 아직 `COMMIT`되지 않은 데이터를 다른 트랜잭션이 읽음 |
| **반복 가능하지 않은 조회 (Non-repeatable Read)** | 같은 데이터에 대해 두 번 읽을 때 값이 다름                 |
| **팬텀리드 (Phantom Read)**         | 조건을 만족하는 행의 개수가 트랜잭션 중간에 달라짐              |

> 문제상황 설명 보러가기 : [6.6.1 트랜잭션의 ACID 특성](./6.6.1%20ACID%20characteristics%20of%20the%20transaction.md)

</br>

---
### 데이터 손실(Lost Update) 예시
```
1. T1: 잔액 1000 → 읽음
2. T2: 잔액 1000 → 읽음
3. T1: 1000 - 100 = 900 → 저장
4. T2: 1000 - 200 = 800 → 저장
```

- 실제로는 100 + 200 = 300이 빠졌어야 하지만, 결과는 800 → **100** 손실됨

# 동시성 제어의 목표
- **일관성 유지**: 동시에 여러 트랜잭션이 실행되어도 DB의 무결성은 유지
- **격리성 확보(Isolation)**: 각 트랜잭션이 마치 독립적으로 수행된 것처럼 보이게 함
- **정당한 병행 실행(Schedule)**: 트랜잭션의 실행 순서를 조정하여 올바른 결과 유도

# 대표적인 동시성 제어 기법
| 기법                     | 설명                                                               |
| ---------------------- | ---------------------------------------------------------------- |
| **로킹(Locking)**        | 데이터를 잠금하여 다른 트랜잭션의 접근을 제한 (예: 2단계 로킹 프로토콜)                       |
| **타임스탬프 순서제어**         | 트랜잭션 시작 시점의 시간 정보로 순서 제어                                         |
| **낙관적 기법(Validation)** | 충돌 가능성이 낮다고 가정하고, 커밋 직전에 충돌 여부 검사                                |
| **다중 버전 제어(MVCC)**     | 각 트랜잭션에게 데이터의 스냅샷을 제공하여 동시성 해결 (PostgreSQL, MySQL InnoDB 등에서 사용) |
