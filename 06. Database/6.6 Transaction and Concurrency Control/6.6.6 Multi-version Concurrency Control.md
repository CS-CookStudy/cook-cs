# 6.6 트랜잭션과 동시성 제어
# 6.6.6 다중 버전 병행 제어 (MVCC)
---

# 다중 버전 병행 제어(Multi-version Concurrency Control)
> 한 데이터에 대해 여러 버전의 타임스탬프 값을 유지하며 관리하는 방식
- 타임스탬프의 개념을 이용하며, 다중 버전 타임 스탬프 기법이라고도 함
- 여러 버전의 타임스탬프를 비교하여 스케줄상 직렬 가능성이 보장되는 타임스탬프를 선택
- 충돌이 발생할 경우 연쇄 복귀의 위험성 존재

# MVCC의 핵심 구조
**각 데이터 항목이 관리하는 정보**
| 정보        | 설명                              |
| --------- | ------------------------------- |
| **Value** | 실제 저장된 데이터 값                    |
| **Xmin**  | 이 버전을 생성한 트랜잭션 ID               |
| **Xmax**  | 이 버전을 삭제한 트랜잭션 ID (삭제되었을 때만 존재) |

# MVCC 트랜잭션의 동작 방식
## 📖 READ (읽기)
- 트랜잭션은 자기보다 이전에 커밋된 버전만 읽을 수 있음

</br>

**읽기 조건**:
- Xmin ≤ TS(T) (트랜잭션 시작 시점보다 생성이 빠름)
- Xmax == null 또는 Xmax > TS(T) (아직 삭제되지 않았거나 미래에서 삭제됨)

- 락 없이 읽을 수 있음 (Read-Only는 Non-blocking)

## ✍️ WRITE (쓰기 / 수정 / 삭제)
- 데이터를 직접 덮어쓰지 않고, 새로운 버전을 만들어 추가
- 기존 버전은 그대로 유지
- 변경사항은 Buffer Pool에 저장되며, Undo Log, Redo Log에도 기록됨

## DBMS 내부 컴포넌트
### 1️⃣ Undo Log
> 트랜잭션 실패 시, 변경 이전 상태로 복구하기 위한 로그
- 트랜잭션 실행 이전 상태를 기록하여 롤백이나 MVCC를 구현.
- 이전 데이터를 참조할 수 있도록 데이터 변경 내용을 저장.
- 예시: 사용자 A가 트랜잭션에서 특정 데이터를 수정하려 할 때, Undo Log에 원래 데이터를 기록해 두어 롤백이나 다른 트랜잭션에서 이를 참조할 수 있게 한다.


### 2️⃣ Redo Log
> 트랜잭션이 COMMIT된 후, 시스템 장애 시 변경 내용을 재적용
- 트랜잭션이 커밋된 후 장애 복구 시 변경 내용을 재적용.
- 데이터 무결성과 지속성을 보장.
- 예시: 시스템 장애가 발생한 경우, Redo Log를 참조하여 마지막 커밋된 변경 사항을 복원한다.


### 3️⃣ 버퍼풀(Buffer Pool)
> 디스크에서 읽어온 페이지를 캐싱하는 메모리 영역
- 메모리 내 데이터를 관리하여 디스크 I/O를 줄이고 성능을 높임.
- Undo Log와 Redo Log의 동작을 가속화.
- 예시: 데이터베이스의 빈번한 읽기/쓰기 작업이 버퍼풀에서 처리되어 디스크 접근을 최소화한다.

  
=> 사용자가 데이터를 읽을 때 Undo Log를 통해 이전 버전을 참조하여 읽기 일관성을 유지하며, 트랜잭션이 종료되면 Redo Log와 버퍼풀이 협력하여 데이터를 지속적으로 저장하고 복구를 지원한다.

### 전체 흐름 요약(트랜잭션 UPDATE)
```
flowchart TD
    A[트랜잭션 시작 (TS=T2)] --> B[Undo Log에 이전 값 저장]
    B --> C[Redo Log에 새 값 저장]
    C --> D[Buffer Pool에서 실제 데이터 페이지 수정]
    D --> E[트랜잭션 COMMIT → Redo Log flush]
    E --> F[디스크 페이지는 나중에 반영 (Lazy flush)]
```

---
# MVCC의 장단점
| 항목     | 장점                                    | 단점                                 |
| ------ | ------------------------------------- | ---------------------------------- |
| 읽기 동시성 | Read 시 락이 필요 없음 → 성능 높음               | 오래된 트랜잭션이 Undo Log를 너무 오래 점유하면 비효율 |
| 충돌 회피  | 읽기-쓰기 충돌 없음 (Read-Write non-blocking) | 다수의 버전 관리로 인한 공간 낭비                |
| 일관성 보장 | Snapshot Isolation                    | VACUUM이나 GC가 필요 (PostgreSQL 등)     |
| 복구성    | Redo/Undo Log를 통한 안정적 복구              | 로그 관리 및 트랜잭션 타임스탬프 처리 복잡           |

  
---
> MVCC는 하나의 데이터 항목에 대해 **트랜잭션마다 다른 시점의 버전을 보여줌으로써** 락 없이도 일관성과 동시성을 모두 보장하는 기법이다.
이때 변경 이력은 **Undo Log / Redo Log**, 실제 데이터는 **Buffer Pool**,
읽기 스냅샷은 **트랜잭션의 타임스탬프 기반**으로 처리된다.