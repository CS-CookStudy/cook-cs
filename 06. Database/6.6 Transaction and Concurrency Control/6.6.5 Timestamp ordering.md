# 6.6 트랜잭션과 동시성 제어
# 6.6.5 타임스탬프 순서 기법
---

# 타임스탬프 순서 기법
> 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 타임스탬프를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법
- 비직렬 트랜잭션을 타임스탬프 순서에 따라 직렬화 시키는 방법
- 데이터에 접근하는 시간(**타임스탬프**)을 미리 정해두어 부여된 시간 순서대로 데이터에 접근하며, **lock을 사용하지 않고** 시간을 나눠 사용하기 때문에 **교착 상태가 발생하지 않음**
- 하지만, **Rollback 발생률이 높고 연쇄 복귀를 초래할 수 있는 단점**이 존재

## 타임스탬프(Timestamp)
- 각 트랜잭션 T는 고유한 타임스탬프 TS(T)를 가짐
- 일반적으로 트랜잭션이 시작되는 순간 부여됨
- 이 타임스탬프를 기준으로 트랜잭션 간의 순서 결정
  

| 정보            | 설명                      |
| ------------- | ----------------------- |
| `read_TS(X)`  | X를 **마지막으로** 읽은 트랜잭션의 타임스탬프 |
| `write_TS(X)` | X를 **마지막으로** 쓴 트랜잭션의 타임스탬프  |


### 주요 연산과 판정 규칙
1. **트랜잭션 T가 `read(x)를` 수행하려고 할 때**
- `TS(T) < write_TS(x)` : read(x)를 거부하고 T 취소 & 복귀 (Rollback)
    - 자신보다 **미래에 쓰인 값**을 읽으려 하므로 실패
- `TS(T) ≥ write_TS(x)` : read(x)를 허용하고 read_TS(x) = TS(T)로 갱신
  

2. **트랜잭션 T가 write(x)를 수행하려고 할 때**
- `TS(T) < read_TS(x)` :  write(x)를 거부하고 T 취소 & 복귀
    - 내가 쓰려고 할 때, 이미 나보다 미래에 X를 읽은 트랜잭션이 있기 때문에 **일관성 위배**
- `TS(T) < write_TS(x)` : write(x)를 수행한 것으로 간주하고 무시(Thomas write rule, 트랜잭션 취소 감소 목적)
이외의 경우, write(x)를 허용하고 write_TS(x) = TS(T)로 갱신
    - 다만, 일반적으로 지금 나보다 미래에 쓴 값이 있는데 덮어쓰려해서 위험할 수 있음

### 예시
**초기 상태**:
```
X = 100
read_TS(X) = 0
write_TS(X) = 0
```

1. **트랜잭션 T1 (TS = 5)** → READ(X) 실행
- 조건 확인: TS(T1)=5 ≥ write_TS(X)=0 → ⭕
- 결과: read_TS(X) ← 5
  
2. **트랜잭션 T2 (TS = 3)** → WRITE(X) 시도

- 조건 확인: TS(T2)=3 < read_TS(X)=5 → ❌
- 결과: T2 롤백
  
**이유**: T2는 과거에 시작됐지만 미래 트랜잭션(T1)이 X를 읽었기 때문에,
T2가 X를 덮어쓰면 불일치 발생 → 방지