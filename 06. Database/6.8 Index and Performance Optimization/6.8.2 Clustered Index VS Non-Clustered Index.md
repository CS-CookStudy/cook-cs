# 6.8 인덱스와 성능 최적화
# 6.8.2 클러스터형 vs 비클러스터형 인덱스

</br>

# 클러스터드 인덱스 (Clustered Index)
> 인덱스 순서대로 실제 데이터도 함께 정렬되어 저장되는 인덱스

```sql
-- 기본 키는 자동으로 클러스터드 인덱스 생성
CREATE TABLE 학생 (
    학번 CHAR(7) PRIMARY KEY,  -- 클러스터드 인덱스
    이름 VARCHAR(50),
    학과코드 CHAR(3)
);

-- 실제 데이터가 인덱스 순서로 물리적 정렬됨
```
  
- 테이블당 클러스터형 인덱스는 **하나만 존재**할 수 있음
    - 일반적으로 PK, unique not null을 사용함
- 데이터 행들이 인덱스 키 값에 따라 **정렬됨**
  

### 구조
> 데이터와 인덱스가 같은 구조
```sql
B-Tree 인덱스
├── key=1 → 실제 row 저장
├── key=2 → 실제 row 저장
└── key=3 → 실제 row 저장
```
- **데이터 테이블 자체가** 인덱스 순서대로 물리적으로 정렬되어 있음
- 추가 인덱스 없이도 빠르게 접근 가능
- **정렬된 데이터**에 직접 접근할 수 있어 검색 속도가 빠름
- 삽입, 업데이트, 삭제 시 데이터의 물리적 순서를 유지해야 하므로, 빈번한 데이터 변경이 발생하는 경우 성능에 영향을 끼칠 수 있음

</br>

---
# 비클러스터드 인덱스 (Non-Clustered Index)
> 인덱스는 따로 있고, 해당 인덱스가 실제 데이터의 위치(포인터)를 가리키는 인덱스

```sql
-- 일반 인덱스 생성 (비클러스터드)
CREATE INDEX idx_학생_학과코드 ON 학생(학과코드);
CREATE INDEX idx_학생_이름 ON 학생(이름);

-- 인덱스는 별도 구조, 실제 데이터는 정렬되지 않음
```
  
- 비클러스터드 인덱스는 **인덱스와 데이터가 분리**되어 관리되는 형태
- 데이터 행으로부터 **독립적**이며 데이터를 간접적으로 두고 참조하기 때문에, 중간에 **참조용 테이블 하나가 반드시 필요**
- 특정 열에 대한 빠른 검색은 가능하게 하지만, **데이터가 인덱스에 따라 정렬되지 않으므로** 범위 검색보다는 **특정 값 검색에 효율적**
  

### 구조
```
B-Tree 인덱스
├── key=1 → [row pointer] → 실제 테이블 위치로 점프
├── key=2 → [row pointer] → ...
└── key=3 → [row pointer] → ...
```
- 인덱스만 정렬되어 있고, **데이터는 원래 테이블에 따로 저장되어 있음**
- 인덱스 → 데이터 접근 시 I/O 한 번 더 필요
- row pointer의 구조는 **데이터 페이지가 힙 또는 클러스터형 테이블에 저장되는지 여부에 따라 달라**짐
    - **힙**에서 row pointer는 row에 대한 포인터.
    - **클러스터형 테이블**에서 row pointer는 클러스터형 인덱스 키
- 데이터 변경 시, 포인터만 수정하면 되므로 클러스터드 인덱스 보다 성능에 영향을 덜 받음

</br>

---
## 주요 차이점
| 항목          | 클러스터형 인덱스                        | 비클러스터형 인덱스                |
| ----------- | -------------------------------- | ------------------------- |
| **정의**      | 인덱스 정렬 = 실제 데이터 정렬               | 인덱스만 정렬, 데이터는 따로          |
| **저장 구조**   | 데이터와 인덱스가 하나의 구조                 | 인덱스와 데이터 분리 저장            |
| **속도**      | 범위 검색 빠름 (`BETWEEN`, `ORDER BY`) | 포인터 따라가야 하므로 한 단계 더       |
| **테이블당 개수** | 테이블당 **1개만** 가능                  | 여러 개 생성 가능                |
| **공간**      | 추가 공간 적음                         | 인덱스 저장용 공간 별도 필요          |
| **갱신 비용**   | 정렬 유지 위해 높은 비용 발생                | 상대적으로 낮음                  |
| **대표 활용**   | 기본 키(PK), 정렬 필요한 컬럼              | 자주 조회되는 서브 키 (e.g. email) |


## 장단점
| 인덱스 유형     | 장점                                    | 단점                                 |
| ---------- | ------------------------------------- | ---------------------------------- |
| **클러스터형**  | ✅ 정렬된 상태로 범위 검색 빠름<br>✅ 추가 인덱스 없이도 빠름 | ❌ 데이터 삽입·삭제 시 부담 큼<br>❌ 1개만 생성 가능  |
| **비클러스터형** | ✅ 여러 개 생성 가능<br>✅ 특정 컬럼만 인덱싱 가능       | ❌ 포인터 따라가야 하므로 성능 저하<br>❌ 정렬된 결과 X |


## 실무 예시
| 예시                | 클러스터형 인덱스              | 비클러스터형 인덱스              |
| ----------------- | ---------------------- | ----------------------- |
| **주문 테이블(order)** | `order_id` (PK, 클러스터형) | `user_id`, `order_date` |
| **회원 테이블(users)** | `user_id` (PK, 클러스터형)  | `email`, `phone_number` |
