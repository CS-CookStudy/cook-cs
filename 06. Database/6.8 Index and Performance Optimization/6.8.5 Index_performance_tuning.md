# 성능 튜닝 기법 (performance tuning)

> 인덱스를 과도하게 생성하면 성능을 저하시킬 수 있기 때문에 인덱스의 효과와 성능 최적화 기법을 적용하는 것
- 인덱스 최적화 기법은 데이터베이스마다 조금 다르지만 기본적으로 골조는 동일

## 1. 성능 최적화 기법

### 1-1. 적절한 인덱스 설계
    - 인덱스를 설계할 때는 데이터의 특성과 접근 패턴을 고려
    - 자주 검색되는 열이나 조건으로 사용되는 열에 인덱스를 생성하는 것이 좋음
    - 인덱스의 크기를 최소화하고 중복된 인덱스를 제거하여 성능을 최적화

#### 예시

```
-- employees 테이블 생성
CREATE TABLE employees (
    id INT PRIMARY KEY,
    last_name VARCHAR(50),
    first_name VARCHAR(50),
    age INT,
    department VARCHAR(50)
);

-- 적절한 인덱스 설계
-- 1. id 컬럼에 클러스터드 인덱스 생성
CREATE CLUSTERED INDEX idx_id ON employees(id);

-- 2. last_name 컬럼에 비클러스터드 인덱스 생성
CREATE NONCLUSTERED INDEX idx_last_name ON employees(last_name);

```
- "employees" 테이블에 대해 적절한 인덱스 설계
- "id" 컬럼에는 클러스터드 인덱스를 생성하여 데이터 행을 인덱스의 정렬 순서와 동일하게 유지
- "last_name" 컬럼에는 비클러스터드 인덱스를 생성하여 데이터 행을 별도로 유지

   
### 1-2. 인덱스 통계 유지
    - 인덱스의 통계 정보를 주기적으로 업데이트하여 최신 정보를 유지

#### 예시
```
-- 인덱스 통계 유지
-- employees 테이블의 인덱스 통계 갱신
UPDATE STATISTICS employees;
```
- 데이터베이스는 최신의 인덱스 통계를 유지하고, 쿼리 옵티마이저는 정확한 실행 계획을 수립
   
### 1-3. 인덱스의 갱신 비용 고려
    - 인덱스의 갱신 비용을 고려하여 필요한 인덱스만 생성
    - 인덱스를 생성 시 데이터 갱신으로 인한 성능저하 발생이 있기 때문

#### 예시
```
-- 인덱스 갱신 비용 고려
-- employees 테이블의 데이터 삽입 작업 후 인덱스 갱신
INSERT INTO employees (id, last_name, first_name, age, department)
VALUES (1, 'Smith', 'John', 30, 'Sales');

-- 인덱스 갱신
UPDATE STATISTICS employees;
```
- "employees" 테이블에 데이터를 삽입한 후, 적절한 시점에 인덱스를 갱신

-- 인덱스 갱신
UPDATE STATISTICS employees;

   
### 1-4. 쿼리의 재작성과 최적화
   - 불필요한 조인이나 조건식을 제거하고, 인덱스 스캔을 인덱스 범위 스캔으로 변경하는 등의 최적화 작업을 수행

#### 예시
```
-- 쿼리의 재작성과 최적화
-- last_name 컬럼을 이용한 검색 쿼리
SELECT * FROM employees WHERE last_name = 'Smith';

-- 쿼리의 재작성과 최적화
-- 인덱스를 활용한 검색 쿼리
SELECT * FROM employees WITH(INDEX(idx_last_name)) WHERE last_name = 'Smith';

```
- 첫 번째 쿼리는 인덱스를 사용하지 않고 전체 테이블을 스캔하여 검색
- 두 번째 쿼리에서는 WITH(INDEX(idx_last_name)) 문을 사용하여 "last_name" 컬럼에 대한 비클러스터드 인덱스를 명시적으로 지정하여 검색 성능을 향상


## 2. 성능 최적화 기법(MongoDB)

### 2-1. 덱스를 무작정 다 설정하는 것은 좋지 않음
- 인덱스는 읽기 비용, 조회, 수정 비용이 들게 됨
- 그렇기 때문에 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적

### 2-2. 항상 테스팅하기
- 서비스에서 사용하는 객체의 깊이, 테이블의 양이 다 다르기 때문에 항상 테스팅하는 것이 중요
- MySQL 경우 아래와 같이 테스팅 수행

```SQL
EXPLAIN
SELECT * FROM t1
JOIN t2 ON t1.c1 = t2.C1
```

### 2-3. 복합 인덱스 경우, 같음 → 정렬 → 다중 값 → 카디널리티 순으로 생성

- 복합 인덱스 생성이 되었을 시, 인덱스 생성 순서에 따라 인덱스 성능이 달라짐
- 그래서 같음 , 정렬 , 다중 값 , 카디널리티 순으로 생성해야 함
  - 같음 : 같음을 비교하는 = 이나 equal 이라는 쿼리가 있다면 제일 먼저 인덱스로 설정
  - 정렬 : 정렬에 쓰는 필드
  - 다중 값 : 리 자체가 > 이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드
  - 카디널리티 값 : 유니크한 정도가 높은 순서를 기반으로 인덱스 생성하는 필드


> 모든 경우에 인덱스를 생성하는 것이 항상 최적의 선택은 아니므로, `데이터베이스의 특성과 요구사항`을 고려하여 적절한 인덱스 설계와 성능 최적화를 수행
---
#### 용어
- 카디널리티 : 유니크한 값의 정도
  - 예) age 와 email 중 email이 카디널리티가 높음
---
[참고 : 인덱스의 효과와 성능 최적](https://wikidocs.net/225363)