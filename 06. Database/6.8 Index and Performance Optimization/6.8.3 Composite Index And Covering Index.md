# 6.8 인덱스와 성능 최적화
# 6.8.3 복합 인덱스와 커버링 인덱스

</br>

# 복합 인덱스(Composite Index)
> 두 개 이상의 컬럼을 결합하여 만든 인덱스 (다중 컬럼 인덱스)

- B-Tree나 B+Tree 인덱스로, 한 개의 인덱스 노드에 다중 칼럼의 값이 묶여 저장됨
- MySQL에서 최대 16개까지 칼럼 조합 가능


## Prefix Rule
> 복합 인덱스 사용 시 쿼리가 왼쪽부터 인덱스 컬럼을 참조해야 효율적으로 사용될 수 있다는 규칙

- 선행 컬럼은 **카디널리티가 높은** 칼럼으로 하는 것이 좋음
    - 선행 칼럼에 대한 조건으로 필터링한 후 뒤 칼럼으로 필터링 하는데,
    선행 칼럼의 카디널리티가 높으면 뒤에 조건을 확인해야할 레코드 수가 줄기 때문


```sql```
CREATE INDEX idx_user_email
ON users (username, email);
```
| username | email                             | user\_id |
| -------- | --------------------------------- | -------- |
| alice    | [alice@a.com](mailto:alice@a.com) | 1        |
| alice    | [alice@b.com](mailto:alice@b.com) | 2        |
| bob      | [bob@a.com](mailto:bob@a.com)     | 3        |
```
- `WHERE username = ?` → ✔️사용 가능 
- `WHERE username = ? AND email = ?` → ✔️사용 가능
- `WHERE email = ?` → ❌사용 불가

## 복합 인덱스 순서
**같음, 정렬, 다중값, 카디널리티 순**
  
1. **어떠한 값과 같음**을 비교하는 == 이나 equal이라는 쿼리가 있다면 **제일 먼저** 인덱스로 설정한다.
2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정한다.
3. 다중 값을 출력해야 하는 필드, 즉 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정한다.
4. 유니크한 값의 정도를 카디널리티. 이 **카디널리티가 높은 순서를 기반으로 인덱스를 생성**해야 한다. 예를 들어 age와 email에서 email이 카디널리티가 높다. 즉, email이라는 필드에 대한 인덱스를 먼저 생성해야 한다.


## 인덱스 탐색 알고리즘 (B-Tree 기반)
**예**: `CREATE INDEX idx ON t(a, b, c);`
  
1. Root 노드부터 탐색
2. 첫 번째 컬럼 a 기준으로 가지 분기
3. a가 같으면 두 번째 컬럼 b로 탐색
4. b까지 같으면 세 번째 컬럼 c로 탐색
5. leaf 노드에 도달 → 일치하는 row ID 또는 전체 row 추출

</br>

---
# 커버링 인덱스 (Covering Index)
> 쿼리에서 **필요한 모든 컬럼이 인덱스에 포함되어 있어 테이블 접근 없이** 인덱스만으로 결과를 반환할 수 있는 인덱스

- **SELECT 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 있어서, 실제 테이블(데이터 블록)에 접근하지 않고 인덱스만으로 쿼리를 처리할 수 있는 인덱스**
- 읽기 쿼리 성능을 높이기 위해 사용되는 방법
- 특정 칼럼을 자주 조회하거나 조인 연산 비용을 줄이기 위해 사용
- **디스크 I/O를 줄여줌**
    - 인덱스는 메모리에서 관리, 데이터는 디스크에서 관리.
    - 인덱스 트리에서 찾은 노드는 디스크로부터 데이터를 읽어와 사용자에게 쿼리를 줌. 하지만, **사용되는 칼럼이 인덱스의 칼럼이라면 굳이 디스크 I/O를 발생할 이유가 없음**

```sql
-- 복합 인덱스 생성
CREATE INDEX idx_composite
ON users(username, email);

-- 커버링 인덱스 되는 경우
SELECT username, email
FROM users
WHERE username = 'alice';

-- 위 쿼리는 idx_composite 인덱스만으로 수행 가능 (커버링)
```
```
B+ Tree Leaf Node:
+-----------------------------+
| username | email | row_id |
+-----------------------------+
```
- 커버링 인덱스에서는 email도 **leaf node 안에 포함**되어 있기 때문에
굳이 row_id를 따라 테이블에 갈 필요가 없음!


## 커버링 인덱스가 되기 위한 조건
1. **WHERE 조건**의 컬럼이 **인덱스에 포함**되어 있어야 함
2. **SELECT 대상 컬럼**이 **모두 인덱스에 포함**되어 있어야 함
3. 인덱스 컬럼 순서가 WHERE절 또는 SELECT절과 **정확히 일치할 필요는 없음**
(단, 성능 최적화엔 중요할 수 있음)

---
## 장단점
| 구분          | 장점                                                | 단점                                                   |
| ----------- | ------------------------------------------------- | ---------------------------------------------------- |
| **복합 인덱스**  | - 다중 컬럼 조합 조건에 빠른 검색 성능<br> - WHERE절 필터링 성능 향상 - 정렬 기준이 명확하므로 `ORDER BY a, b`도 커버 가능<br> - 커버링 인덱스 구성에 유리함           | - 컬럼 순서 중요<br> - 모든 조건에 항상 사용되진 않음<br> - 인덱스 크기 커질 수 있음 (특히 TEXT나 VARCHAR 긴 컬럼 포함 시)             |
| **커버링 인덱스** | - 테이블 접근 생략 가능 (디스크 I/O 최소화 (최대 성능))<br> - Index Only Scan 가능<br> - 커버링 + 복합으로 더 강력한 최적화 | - SELECT 컬럼이 인덱스에 모두 있어야 함<br> - 컬럼 추가 많아지면 인덱스 크기 증가 (전체 성능 저하)<br> - INSERT/UPDATE 비용 증가 |

</br>

---
| 항목     | 일반 인덱스 | 복합 인덱스          | 커버링 인덱스              |
| ------ | ------ | --------------- | -------------------- |
| 컬럼 수   | 1개     | 2개 이상           | SELECT에 필요한 모든 컬럼 포함 |
| 사용 목적  | 단일 조건  | 다중 WHERE 조건 최적화 | SELECT + WHERE 모두 처리 |
| 테이블 접근 | 필요     | 필요              | ❌ 불필요 (인덱스만)         |
| 성능     | 기본 수준  | WHERE 최적화       | **최고 성능**            |
