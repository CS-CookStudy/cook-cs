# 2. 컨테이너화 (Docker, Kubernetes)

## 2-0. 컨테이너화란?

- 정의 : 애플리케이션과 실행 환경을 하나의 패키지로 묶는 기술
- 목적 : "내 컴퓨터에서는 잘 되는데" 문제 해결
- 원리 : OS 수준 가상화로 격리된 실행 환경 제공

## 2-1. Docker

### Docker의 핵심 개념

```
기존 개발 환경 문제:
😰 "내 컴퓨터에서는 잘 되는데..."
😰 개발/스테이징/프로덕션 환경 차이
😰 라이브러리 버전 충돌
😰 복잡한 배포 과정

Docker 해결책:
✅ 애플리케이션 + 실행 환경을 하나로 패키징
✅ 어디서든 동일하게 실행
✅ 빠른 시작과 종료
✅ 가벼운 리소스 사용
```

### 가상머신 vs Docker 컨테이너

```
가상머신 (Virtual Machine):
┌──────────────────────────────┐
│         애플리케이션           │
├──────────────────────────────┤
│          게스트 OS            │  ← 각각 독립적인 OS
├──────────────────────────────┤
│         하이퍼바이저           │
├──────────────────────────────┤
│          호스트 OS            │
├──────────────────────────────┤
│         물리 하드웨어          │
└──────────────────────────────┘

Docker 컨테이너:
┌──────────────────────────────┐
│         애플리케이션           │
├──────────────────────────────┤
│      Docker 컨테이너          │  ← OS 공유, 빠르고 가벼움
├──────────────────────────────┤
│         Docker 엔진           │
├──────────────────────────────┤
│          호스트 OS            │
├──────────────────────────────┤
│         물리 하드웨어          │
└──────────────────────────────┘
```

### Docker 주요 구성요소

```
🖼️ Image (이미지):
- 실행 가능한 패키지 (애플리케이션 + 환경)
- 읽기 전용, 불변
- 예: nginx:latest, node:16, python:3.9

📦 Container (컨테이너):
- 이미지를 실행한 인스턴스
- 실제로 동작하는 애플리케이션
- 여러 컨테이너가 같은 이미지 사용 가능

📝 Dockerfile:
- 이미지를 만들기 위한 명령어 스크립트
- 코드로 인프라 정의 (Infrastructure as Code : IaC)

🏪 Registry (레지스트리):
- 이미지를 저장하고 공유하는 저장소
- Docker Hub (공개), ECR, Harbor 등
```

### Dockerfile 예시

```dockerfile
# Node.js 애플리케이션 Dockerfile
FROM node:16-alpine           # 베이스 이미지

WORKDIR /app                  # 작업 디렉터리 설정

COPY package*.json ./         # 의존성 파일 복사
RUN npm install               # 패키지 설치

COPY . .                      # 소스 코드 복사

EXPOSE 3000                   # 포트 노출

CMD ["npm", "start"]          # 실행 명령
```

## 2-2. Kubernetes

### Kubernetes란?

- 정의 : 컨테이너 오케스트레이션 플랫폼
- 목적 : 수많은 컨테이너를 자동으로 관리
- Google 개발 : 15년간의 컨테이너 운영 경험을 오픈소스화

### 왜 Kubernetes가 필요한가?

```
Docker만으로는 해결할 수 없는 문제들:

🤔 컨테이너가 죽으면 누가 다시 시작시킬까?
🤔 트래픽이 증가하면 컨테이너를 자동으로 늘릴 수 있을까?
🤔 여러 서버에 컨테이너를 어떻게 배포할까?
🤔 컨테이너끼리 어떻게 네트워킹할까?
🤔 설정과 비밀번호를 어떻게 관리할까?

Kubernetes 해결책:
✅ 자동 복구 (Self-healing)
✅ 자동 스케일링 (Auto-scaling)
✅ 서비스 디스커버리 (Service Discovery)
✅ 로드 밸런싱 (Load Balancing)
✅ 롤링 업데이트 (Rolling Update)
✅ 설정 관리 (ConfigMap, Secret)
```

### Kubernetes 클러스터 구조

```
Master Node (Control Plane):
┌─────────────────────────────┐
│ API Server: 모든 요청 처리    │
│ etcd: 클러스터 상태 저장       │
│ Scheduler: Pod 배치 결정     │
│ Controller: 상태 관리        │
└─────────────────────────────┘
               │
         ┌─────┴─────┐
 Worker Node 1     Worker Node 2
┌─────────────┐   ┌─────────────┐
│ kubelet     │   │ kubelet     │  ← 노드 에이전트
│ kube-proxy  │   │ kube-proxy  │  ← 네트워크 관리
│ Container   │   │ Container   │  ← Docker 등
│ Runtime     │   │ Runtime     │
│             │   │             │
│ Pod │ Pod   │   │ Pod │ Pod   │  ← 실제 애플리케이션
└─────────────┘   └─────────────┘
```

### Kubernetes 주요 오브젝트

### 1. POD

```
Pod: 가장 작은 배포 단위
- 1개 이상의 컨테이너 묶음
- 같은 Pod 내 컨테이너는 IP와 볼륨 공유
- 일반적으로 1 Pod = 1 Container
```

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
    - name: nginx
      image: nginx:1.20
      ports:
        - containerPort: 80
```

### 2. Deployment

```
Deployment: Pod의 배포와 관리
- 원하는 상태 선언 (Desired State)
- 자동 복구, 롤링 업데이트
- ReplicaSet을 통한 Pod 복제 관리
```

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3 # 3개 Pod 유지
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
        - name: nginx
          image: nginx:1.20
          ports:
            - containerPort: 80
```

### 3. Service

```
Service: Pod에 접근하는 방법 정의
- Pod는 언제든 죽고 다시 생성될 수 있음
- Service는 변하지 않는 접근점 제공
- 로드 밸런싱 기능 포함

종류:
🔹 ClusterIP: 클러스터 내부에서만 접근
🔹 NodePort: 노드의 특정 포트로 외부 접근
🔹 LoadBalancer: 클라우드 로드밸런서 사용
🔹 ExternalName: 외부 서비스와 연결
```

### 4. ConfigMap & Secret

```
ConfigMap: 설정 정보 저장
- 애플리케이션 설정을 코드와 분리
- 환경별 다른 설정 적용 가능

Secret: 민감한 정보 저장
- 패스워드, API 키, 인증서 등
- Base64 인코딩되어 저장
- 실제로는 암호화 추가 필요
```

### Kubernetes 장점

```
확장성:
- 자동 스케일링 (HPA, VPA, CA)
- 수천 개 노드까지 확장 가능

안정성:
- 자동 복구 (Pod 재시작, 노드 교체)
- 롤링 업데이트로 무중단 배포

이식성:
- 클라우드 벤더 독립적
- 온프레미스, 하이브리드 환경 지원

효율성:
- 리소스 효율적 활용
- 멀티테넌시 지원
```
