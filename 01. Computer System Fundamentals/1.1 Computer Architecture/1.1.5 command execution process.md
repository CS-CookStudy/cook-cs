# 📘 1.1 컴퓨터 구조

# 1.1-3 명령어 실행 과정

## 1. 개요

CPU는 프로그램을 실행하기 위해 메모리에 저장된 명령어를 하나씩 가져와 해석하고 실행한다. 이 일련의 과정을 **명령어 사이클(Instruction Cycle)**이라 하며, 다음 세 단계로 구성된다:

1. **Fetch (인출)**
2. **Decode (해석)**
3. **Execute (실행)**

현대 고성능 CPU는 이 과정을 파이프라인 방식으로 겹쳐 처리하여 성능을 향상시킨다.

### 🧰 명령어 실행에 필요한 레지스터 집합
| 구성 요소                             | 설명                      |
| --------------------------------- | ----------------------- |
| **프로그램 카운터, PC**<br>(Program Counter)         | 다음에 실행할 명령어의 메모리 주소를 보관 |
| **누산기, AC**<br>(Accumulator)    | 데이터를 일시적 저장      |
| **명령어 레지스터, IR**<br>(Instruction Register)     | 현재 실행 중인 명령어 저장         |
| **기억장치 주소 레지스터, MAR**<br>(Memory Address Register) | 메모리에 접근할 주소 저장          |
| **기억장치 데이터 레지스터, MDR**<br>(Memory Data Register)    | 메모리에서 읽거나 쓸 데이터 저장      |



## 2. 명령어 처리 단계

### 2.1 Fetch (명령어 인출)
* **PC (Program Counter)**가 가리키는 메모리 주소에서 명령어를 읽어온다
* 메모리에서 해당 주소의 명령어를 MDR에 가져온다
* 읽어온 명령어를 **IR (Instruction Register)**에 저장한다
* PC는 자동으로 다음 명령어의 주소로 증가한다
```
PC → MAR              // PC가 가리키는 명령어 주소를 MAR에 넣음
Memory[MAR] → MDR     // 해당 주소에서 명령어(LOAD R1, 0x1000)를 읽음
MDR → IR              // MDR에 있는 명령어를 IR로 전달
PC + 1 → PC           // 다음 명령어 실행을 위해 PC 증가
```

### 2.2 Decode (명령어 해석)
* IR에 저장된 명령어의 **Opcode(연산 코드)**를 분석하여 수행할 동작을 결정한다
* **Operand(피연산자)** 정보를 확인하여 필요한 레지스터나 메모리 주소를 파악한다
* 제어 유닛(CU)이 해당 명령어 실행을 위한 제어 신호를 준비한다

### 2.3 Execute (명령어 실행)
* 해석된 명령어에 따라 실제 연산이나 동작을 수행한다
* 산술/논리 연산은 **ALU**가 담당하고, 데이터 이동이나 분기는 제어 유닛이 처리한다
* 실행 결과를 레지스터나 메모리에 저장한다

## 3. 명령어 실행 예시

### ADD R1, R2, R3 (R1 = R2 + R3)

**명령어 의미**: R2 레지스터와 R3 레지스터의 값을 더해서 R1 레지스터에 저장

**단계별 처리 과정**:

**1단계 - Fetch (인출)**
- PC가 현재 0x1000 주소를 가리키고 있다고 가정
- 메모리 주소 0x1000에서 "ADD R1, R2, R3" 명령어를 읽어온다
- 이 명령어를 IR에 저장한다
- PC를 0x1004로 증가시킨다 (다음 명령어 준비)
```yaml
[ PC ] = 0x1000
   ↓
[ MAR ] = 0x1000
   ↓
[ Memory[0x1000] ] = "ADD R1, R2, R3"
   ↓
[ MDR ] = "ADD R1, R2, R3"
   ↓
[ IR ] = "ADD R1, R2, R3"
```

**2단계 - Decode (해석)**
- IR의 명령어를 분석한다:
  - Opcode: "ADD" → 덧셈 연산임을 파악
  - 첫 번째 피연산자: R1 → 결과를 저장할 레지스터
  - 두 번째 피연산자: R2 → 첫 번째 더할 값이 있는 레지스터  
  - 세 번째 피연산자: R3 → 두 번째 더할 값이 있는 레지스터
- 제어 유닛이 ALU에 덧셈 연산 수행 신호를 준비한다
```yaml
IR → Control Unit
           └─▶ ALU ← 연산 종류: ADD
                     ├─ 입력 1: R2 = 10
                     └─ 입력 2: R3 = 20
```

**3단계 - Execute (실행)**
- R2에서 값을 읽어온다 (예: 값이 10이라고 가정)
- R3에서 값을 읽어온다 (예: 값이 20이라고 가정)
- ALU가 10 + 20 = 30을 계산한다
- 계산 결과 30을 R1 레지스터에 저장한다
```
[ R2 ] = 10        [ R3 ] = 20
      ↓                  ↓
           [ ALU ] = 10 + 20 = 30
                      ↓
                 [ R1 ] ← 30
```

### LOAD R1, [100] (메모리 주소 100의 값을 R1으로 로드)

**명령어 의미**: 메모리 주소 100번지에 있는 데이터를 R1 레지스터로 가져오기

**단계별 처리 과정**:

**1단계 - Fetch (인출)**
- PC가 가리키는 주소에서 "LOAD R1, [100]" 명령어를 IR로 가져온다
- PC를 다음 명령어 주소로 증가시킨다

**2단계 - Decode (해석)**
- Opcode: "LOAD" → 메모리에서 데이터를 읽어오는 명령임을 파악
- 목적지: R1 → 데이터를 저장할 레지스터
- 소스: [100] → 메모리 주소 100번지에서 데이터를 가져와야 함

**3단계 - Execute (실행)**
- 메모리 주소 100번지에 접근한다
- 해당 주소의 데이터를 읽어온다 (예: 값이 50이라고 가정)
- 읽어온 값 50을 R1 레지스터에 저장한다


## 4. 파이프라이닝 (Pipelining)

### 등장 배경
명령어를 순차적으로 처리하면 한 번에 하나의 단계만 활용되어 CPU 자원이 비효율적으로 사용된다. 파이프라이닝은 **여러 명령어의 서로 다른 단계를 동시에 처리하여 성능을 향상**시키는 기법이다.

### 기본 명령어 사이클
| 단계  | 이름                 | 설명           |
| --- | ------------------ | ------------ |
| IF  | Instruction Fetch  | 명령어 메모리에서 읽기 |
| ID  | Instruction Decode | 명령어 해석       |
| EX  | Execute            | 연산 수행        |
| MEM | Memory Access      | 메모리 읽기/쓰기    |
| WB  | Write Back         | 결과 저장        |


### 동작 방식
> 전통적인 CPU는 한 명령어를 모두 완료한 후, 다음 명령어를 시작.

** EX) 명령어 4걔 (I1, I2, I3, I4)**
| 사이클 | IF | ID | EX | MEM | WB |
| --- | -- | -- | -- | --- | -- |
| 1   | I1 |    |    |     |    |
| 2   | I2 | I1 |    |     |    |
| 3   | I3 | I2 | I1 |     |    |
| 4   | I4 | I3 | I2 | I1  |    |
| 5   |    | I4 | I3 | I2  | I1 |
| 6   |    |    | I4 | I3  | I2 |
| 7   |    |    |    | I4  | I3 |
| 8   |    |    |    |     | I4 |

> 명령어 I1~I4가 서로 겹쳐서 실행됨 → 전체 실행 속도 비약적으로 향상


### 장점
* 전체 처리량(Throughput) 향상 : 한 사이클마다 하나의 명령어 완료 가능 (이론상)
* CPU 내부 자원의 효율적 활용 : ALU, 메모리 등 하드웨어 유닛을 동시에 활용
* 이론적으로 파이프라인 단계 수(IPC)만큼 CPU 성능 향상 가능

### 주요 문제점
* **데이터 해저드**: 이전 명령어의 결과를 다음 명령어가 필요로 할 때
* **제어 해저드**: 분기 명령어로 인해 실행 흐름이 바뀔 때
* **구조적 해저드**: 하드웨어 자원 부족으로 충돌이 발생할 때

### 해결 방법
* **분기 예측**: 조건 분기의 결과를 미리 예측
* **데이터 포워딩**: 이전 단계의 결과를 바로 다음 단계로 전달
* **파이프라인 스톨**: 필요시 파이프라인을 일시 정지

## 5. 명령어 사이클 흐름도

```
시작
 ↓
┌─────────────────┐
│ PC → 메모리 주소  │
│  명령어 인출     │
└────────┬────────┘
         ↓
┌─────────────────┐
│ 명령어 → IR     │
│   명령어 저장    │
└────────┬────────┘
         ↓
┌─────────────────┐
│ Opcode 분석     │
│ 피연산자 확인    │
└────────┬────────┘
         ↓
┌─────────────────┐
│ ALU/제어유닛    │
│   실제 실행     │
└────────┬────────┘
         ↓
      다음 명령어
```

---

## 핵심 용어 정리

* **명령어 사이클**: CPU가 하나의 명령어를 처리하는 전체 과정 (Fetch-Decode-Execute)
* **Opcode**: 명령어에서 수행할 연산의 종류를 나타내는 부분
* **Operand**: 연산의 대상이 되는 데이터나 주소 정보
* **Program Counter (PC)**: 다음에 실행할 명령어의 주소를 가리키는 레지스터
* **Instruction Register (IR)**: 현재 처리 중인 명령어를 저장하는 레지스터
* **파이프라이닝**: 명령어 처리 단계를 겹쳐서 병렬로 수행하는 성능 향상 기법
* **Pipeline Hazard**: 파이프라인 처리 중 발생하는 충돌이나 지연 상황

