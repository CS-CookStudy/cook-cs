# 📘 1.1 컴퓨터 구조

# 1.1-3 명령어 실행 과정

## 1. 개요

CPU는 프로그램을 실행하기 위해 메모리에 저장된 명령어를 하나씩 가져와 해석하고 실행한다. 이 일련의 과정을 **명령어 사이클(Instruction Cycle)**이라 하며, 다음 세 단계로 구성된다:

1. **Fetch (인출)**
2. **Decode (해석)**
3. **Execute (실행)**

현대 고성능 CPU는 이 과정을 파이프라인 방식으로 겹쳐 처리하여 성능을 향상시킨다.

## 2. 명령어 처리 단계

### 2.1 Fetch (명령어 인출)
* **PC (Program Counter)**가 가리키는 메모리 주소에서 명령어를 읽어온다
* 읽어온 명령어를 **IR (Instruction Register)**에 저장한다
* PC는 자동으로 다음 명령어의 주소로 증가한다

### 2.2 Decode (명령어 해석)
* IR에 저장된 명령어의 **Opcode(연산 코드)**를 분석하여 수행할 동작을 결정한다
* **Operand(피연산자)** 정보를 확인하여 필요한 레지스터나 메모리 주소를 파악한다
* 제어 유닛이 해당 명령어 실행을 위한 제어 신호를 준비한다

### 2.3 Execute (명령어 실행)
* 해석된 명령어에 따라 실제 연산이나 동작을 수행한다
* 산술/논리 연산은 **ALU**가 담당하고, 데이터 이동이나 분기는 제어 유닛이 처리한다
* 실행 결과를 레지스터나 메모리에 저장한다

## 3. 명령어 실행 예시

### ADD R1, R2, R3 (R1 = R2 + R3)

**명령어 의미**: R2 레지스터와 R3 레지스터의 값을 더해서 R1 레지스터에 저장

**단계별 처리 과정**:

**1단계 - Fetch (인출)**
- PC가 현재 0x1000 주소를 가리키고 있다고 가정
- 메모리 주소 0x1000에서 "ADD R1, R2, R3" 명령어를 읽어온다
- 이 명령어를 IR에 저장한다
- PC를 0x1004로 증가시킨다 (다음 명령어 준비)

**2단계 - Decode (해석)**
- IR의 명령어를 분석한다:
  - Opcode: "ADD" → 덧셈 연산임을 파악
  - 첫 번째 피연산자: R1 → 결과를 저장할 레지스터
  - 두 번째 피연산자: R2 → 첫 번째 더할 값이 있는 레지스터  
  - 세 번째 피연산자: R3 → 두 번째 더할 값이 있는 레지스터
- 제어 유닛이 ALU에 덧셈 연산 수행 신호를 준비한다

**3단계 - Execute (실행)**
- R2에서 값을 읽어온다 (예: 값이 10이라고 가정)
- R3에서 값을 읽어온다 (예: 값이 20이라고 가정)
- ALU가 10 + 20 = 30을 계산한다
- 계산 결과 30을 R1 레지스터에 저장한다

### LOAD R1, [100] (메모리 주소 100의 값을 R1으로 로드)

**명령어 의미**: 메모리 주소 100번지에 있는 데이터를 R1 레지스터로 가져오기

**단계별 처리 과정**:

**1단계 - Fetch (인출)**
- PC가 가리키는 주소에서 "LOAD R1, [100]" 명령어를 IR로 가져온다
- PC를 다음 명령어 주소로 증가시킨다

**2단계 - Decode (해석)**
- Opcode: "LOAD" → 메모리에서 데이터를 읽어오는 명령임을 파악
- 목적지: R1 → 데이터를 저장할 레지스터
- 소스: [100] → 메모리 주소 100번지에서 데이터를 가져와야 함

**3단계 - Execute (실행)**
- 메모리 주소 100번지에 접근한다
- 해당 주소의 데이터를 읽어온다 (예: 값이 50이라고 가정)
- 읽어온 값 50을 R1 레지스터에 저장한다

## 4. 주요 레지스터

| 레지스터 | 역할 |
|----------|------|
| **PC (Program Counter)** | 다음에 실행할 명령어의 메모리 주소를 저장 |
| **IR (Instruction Register)** | 현재 처리 중인 명령어를 저장 |
| **MAR (Memory Address Register)** | 메모리 접근 시 사용할 주소를 저장 |
| **MDR (Memory Data Register)** | 메모리와 주고받을 데이터를 임시 저장 |
| **ACC (Accumulator)** | 연산 결과를 임시로 저장하는 레지스터 |

## 5. 파이프라이닝 (Pipelining)

### 등장 배경
명령어를 순차적으로 처리하면 한 번에 하나의 단계만 활용되어 CPU 자원이 비효율적으로 사용된다. 파이프라이닝은 여러 명령어의 서로 다른 단계를 동시에 처리하여 성능을 향상시키는 기법이다.

### 동작 방식
```
시간 →   1    2    3    4    5    6
명령어1: F    D    E
명령어2:      F    D    E
명령어3:           F    D    E
명령어4:                F    D    E

F=Fetch, D=Decode, E=Execute
```

### 장점
* 전체 처리량(Throughput) 향상
* CPU 내부 자원의 효율적 활용
* 이론적으로 파이프라인 단계 수만큼 성능 향상 가능

### 주요 문제점
* **데이터 해저드**: 이전 명령어의 결과를 다음 명령어가 필요로 할 때
* **제어 해저드**: 분기 명령어로 인해 실행 흐름이 바뀔 때
* **구조적 해저드**: 하드웨어 자원 부족으로 충돌이 발생할 때

### 해결 방법
* **분기 예측**: 조건 분기의 결과를 미리 예측
* **데이터 포워딩**: 이전 단계의 결과를 바로 다음 단계로 전달
* **파이프라인 스톨**: 필요시 파이프라인을 일시 정지

## 6. 명령어 사이클 흐름도

```
시작
 ↓
┌─────────────────┐
│ PC → 메모리 주소  │
│  명령어 인출     │
└────────┬────────┘
         ↓
┌─────────────────┐
│ 명령어 → IR     │
│   명령어 저장    │
└────────┬────────┘
         ↓
┌─────────────────┐
│ Opcode 분석     │
│ 피연산자 확인    │
└────────┬────────┘
         ↓
┌─────────────────┐
│ ALU/제어유닛    │
│   실제 실행     │
└────────┬────────┘
         ↓
      다음 명령어
```

---

## 핵심 용어 정리

* **명령어 사이클**: CPU가 하나의 명령어를 처리하는 전체 과정 (Fetch-Decode-Execute)
* **Opcode**: 명령어에서 수행할 연산의 종류를 나타내는 부분
* **Operand**: 연산의 대상이 되는 데이터나 주소 정보
* **Program Counter (PC)**: 다음에 실행할 명령어의 주소를 가리키는 레지스터
* **Instruction Register (IR)**: 현재 처리 중인 명령어를 저장하는 레지스터
* **파이프라이닝**: 명령어 처리 단계를 겹쳐서 병렬로 수행하는 성능 향상 기법
* **Pipeline Hazard**: 파이프라인 처리 중 발생하는 충돌이나 지연 상황


# 1.1-6 입출력 시스템과 버스

## 1. 입출력 시스템 개요

컴퓨터는 키보드, 마우스, 디스크, 프린터 등 다양한 **입출력 장치(I/O)** 와 데이터를 주고받는다. CPU는 이러한 장치들과 직접 연결되지 않고, **버스**와 **제어 유닛**을 통해 간접적으로 데이터를 주고받는다.

입출력 장치는 CPU나 메모리보다 상대적으로 느리기 때문에, 효율적인 연결 및 처리 방식이 중요하다.

## 2. 버스(Bus)의 개념과 종류

**버스(Bus)** 는 CPU, 메모리, 입출력 장치 간에 데이터를 전달하는 **공통 통로**이다. 종류에 따라 역할이 구분된다.

### 2.1 버스 구조도 (흐름 강조)

```
       [ CPU ]
          │
          ├─ 데이터 버스 (양방향) ─────────────┐
          ├─ 주소 버스 (일방향: CPU → 장치) ──┤
          └─ 제어 버스 (양방향) ─────────────┘
                 ↕                          ↕
          [ 메모리 ]               [ 입출력 장치 ]
```

### 2.2 버스 종류별 설명

| 버스 종류 | 방향 | 역할 |
|-----------|------|------|
| **데이터 버스** | 양방향 | 명령어, 연산 결과 등 실제 데이터를 전달 |
| **주소 버스** | CPU → 장치 | 데이터를 주고받을 **주소 지정** |
| **제어 버스** | 양방향 | 읽기/쓰기 등 **제어 신호 전송** (예: Read, Write, Interrupt 등) |

## 3. 입출력 방식 3가지

### 3.1 폴링 방식 (Polling I/O)
* CPU가 **지속적으로 장치 상태를 확인**
* 장치가 준비될 때까지 반복 검사

**폴링이 사용되는 경우:**
- **간단한 임베디드 시스템**: 아두이노에서 버튼이 눌렸는지 while문으로 계속 체크
- **센서 모니터링**: 온도계, 압력계 등에서 주기적으로 값 확인
- **게임 프로그래밍**: 키보드나 조이스틱 입력을 실시간으로 체크

**장점**: 구현이 간단하고 직관적
**단점**: CPU 자원 낭비가 심함 (다른 작업을 못함)

### 3.2 인터럽트 방식 (Interrupt I/O)
* 장치가 준비되면 CPU에 **인터럽트 신호**를 보냄
* CPU는 기존 작업을 멈추고 I/O 처리 후 다시 복귀
* CPU 자원 낭비가 적고 효율적임

**인터럽트 예시:**
마우스 클릭 시, 장치가 "클릭됨" 신호를 CPU에 보냄. CPU는 잠시 작업을 멈추고 클릭 이벤트를 처리한 후 원래 작업으로 복귀한다. 마치 알람이 울리면 반응하는 것처럼, **필요할 때만 CPU가 개입하는 방식**이다.

### 3.3 DMA (Direct Memory Access)
* **CPU 개입 없이**, I/O 장치가 **메모리와 직접 데이터 전송**
* CPU는 설정만 해주고 관여하지 않음
* 대용량 전송에 매우 효율적

**DMA 예시:**
동영상 파일을 **SSD에서 RAM으로 복사**할 때, CPU가 데이터를 옮기면 비효율적. **DMA를 사용하면 SSD가 RAM으로 직접 전송**하며, CPU는 동시에 다른 작업을 수행할 수 있다.

## 4. 입출력 방식 비교

| 방식 | CPU 부담 | 효율성 | 적용 분야 |
|------|----------|--------|-----------|
| **폴링** | 높음 | 낮음 | 간단한 임베디드 시스템, 센서 모니터링 |
| **인터럽트** | 보통 | 높음 | 일반적인 PC, 키보드/마우스 입력 |
| **DMA** | 낮음 | 매우 높음 | 대용량 파일 전송, 영상/음성 처리 |

---

## 핵심 요약

| 항목 | 요약 |
|------|------|
| **입출력 시스템** | CPU와 I/O 장치는 버스를 통해 간접 연결됨 |
| **버스 종류** | 데이터(양방향), 주소(CPU→장치), 제어(양방향) |
| **폴링** | CPU가 반복 확인 (간단하지만 비효율적) |
| **인터럽트** | 장치가 CPU를 호출 (효율적, 가장 일반적) |
| **DMA** | CPU 없이 장치가 메모리와 직접 통신함 (고속 전송용) |