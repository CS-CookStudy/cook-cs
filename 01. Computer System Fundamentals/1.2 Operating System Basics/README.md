# 📘 1.2 운영체제 기본 개념

# 1.2-1 운영체제의 역할과 기능

## 1. 운영체제란?

운영체제(OS: Operating System)는 컴퓨터 하드웨어와 사용자 사이에서 **중재자** 역할을 하는 핵심 **시스템 소프트웨어**이다. 사용자가 컴퓨터를 사용할 수 있도록 환경을 제공하고, 내부 자원을 효율적으로 관리하여 프로그램이 원활히 실행되도록 한다.

## 2. 운영체제의 주요 역할

### 2.1 사용자와 하드웨어 간 인터페이스 제공
* 사용자가 하드웨어를 직접 제어하지 않고, 운영체제를 통해 파일 저장, 프로그램 실행, 장치 사용 등을 간편하게 수행
* 예: Windows의 바탕화면, 안드로이드의 홈 화면도 OS의 인터페이스

### 2.2 자원(Resource) 관리
운영체제는 다양한 하드웨어 자원을 효율적으로 관리한다:

| 자원 종류 | 관리 예시 |
|-----------|-----------|
| CPU | 여러 프로그램이 동시에 실행될 때 CPU 할당 조정 |
| 메모리 | 각 프로그램에 필요한 메모리 공간을 분할하여 제공 |
| 저장장치 | 파일의 저장 위치, 접근 권한 관리 |
| 입출력 장치 | 키보드, 마우스, 프린터 등 장치 제어 및 입출력 스케줄링 |
| 네트워크 | 네트워크 연결 관리, 프로토콜 처리, 보안 등 |

* 예: 게임을 하면서 동시에 음악을 듣고 채팅을 할 때, OS가 각 프로그램에 CPU와 메모리를 적절히 배분하여 모든 작업이 원활하게 동작하도록 함

### 2.3 프로그램 실행과 제어
* 실행 중인 프로그램을 **프로세스(Process)**로 관리
* 프로세스 간 전환(문맥 교환), 스케줄링 등을 통해 CPU를 효율적으로 활용
* 예: 여러 앱이 동시에 돌아가는 스마트폰에서 앱 간 전환을 관리하는 것이 OS의 역할

## 3. 운영체제의 핵심 기능 요약

| 기능 분류 | 설명 |
|-----------|------|
| **프로세스 관리** | 프로그램 실행, 프로세스 생성/제거, 스케줄링, 동기화, **교착상태 방지** 등 |
| **메모리 관리** | 메모리 할당/해제, 가상 메모리 제공 등 |
| **파일 시스템** | 파일 생성, 삭제, 디렉토리 구조 관리, 접근 권한 제어 등 |
| **입출력 관리** | I/O 장치 제어, 버퍼링, 인터럽트 처리 등 |
| **사용자 인터페이스** | 셸(Shell), GUI 제공. 명령어 입력 또는 그래픽 환경으로 사용자 조작 가능 |

## 용어 설명
* **운영체제(OS)**: 하드웨어와 사용자 간의 중재자 역할을 하는 핵심 소프트웨어
* **시스템 소프트웨어**: 하드웨어를 제어하고 다른 소프트웨어의 실행을 지원하는 소프트웨어 (응용 소프트웨어와 구분됨)
* **자원(Resource)**: CPU, 메모리, 저장장치, 입출력 장치 등 컴퓨터의 구성 요소
* **프로세스(Process)**: 실행 중인 프로그램 단위
* **스케줄링(Scheduling)**: CPU 등 자원을 여러 작업에 효율적으로 배분하는 기법
* **셸(Shell)**: 사용자가 OS에 명령을 입력할 수 있는 인터페이스 (예: 터미널, 명령 프롬프트)

# 1.2-2 커널과 시스템 콜

## 1. 커널(Kernel)이란?

커널은 운영체제의 **핵심 부분이자 가장 낮은 수준의 추상화 계층**으로, 컴퓨터의 **하드웨어 자원을 직접 제어**하고 **모든 프로그램 실행을 관리**한다. 사용자와 하드웨어 사이의 **중간 관리자** 역할을 하며, 운영체제에서 가장 먼저 로드되고 가장 마지막에 종료되는 부분이다.

### 사용자 영역 vs 커널 영역

운영체제는 **보안성과 안정성 확보**를 위해 메모리 공간을 크게 두 영역으로 나눈다:

| 영역                     | 설명                       |
| ---------------------- | ------------------------ |
| **커널 영역(Kernel Mode)** | 운영체제와 하드웨어를 직접 다루는 특권 영역 |
| **사용자 영역(User Mode)**  | 일반 사용자 프로그램이 실행되는 제한된 영역 |

사용자 프로그램은 하드웨어에 직접 접근할 수 없고, **커널의 도움을 받아야만** 자원에 접근할 수 있다.

## 2. 시스템 콜(System Call)이란?

시스템 콜은 **사용자 프로그램이 운영체제의 커널 기능을 요청하는 메커니즘**이다. 즉, 프로그램이 CPU, 메모리, 파일, 네트워크 등 **하드웨어 자원이나 OS 서비스를 사용하고 싶을 때 커널에게 요청하는 통로**이다.

### 왜 시스템 콜이 필요한가?

* **보안**: 사용자 프로그램이 임의로 하드웨어에 접근하는 것을 방지
* **안정성**: 커널이 자원을 중앙에서 통제하므로 충돌이나 오류를 줄임
* **추상화**: 복잡한 하드웨어 제어를 단순한 함수 호출처럼 제공

## 3. 시스템 콜 처리 흐름

1. 사용자 프로그램이 시스템 콜 함수를 호출 (ex. `read()`)
2. CPU가 \*\*트랩(Trap)\*\*을 통해 **커널 모드로 전환**
3. 커널이 해당 요청을 처리
4. 처리 결과를 사용자 프로그램으로 반환
5. CPU는 다시 **사용자 모드로 복귀**

**실생활 예시**: 메모장에서 "저장" 버튼을 누르면

1. 프로그램이 write() 시스템 콜 호출
2. 커널 모드 전환 → 파일 시스템이 디스크에 쓰기
3. 완료 후 사용자 모드로 복귀 → "저장 완료" 메시지 표시

### 시스템 콜 오버헤드

* **모드 전환 비용**: 사용자 모드 ↔ 커널 모드 전환 시 **성능 저하** 발생
* 시스템 콜은 일반 함수 호출보다 **수십 배 이상 느릴 수 있음**

## 4. 주요 시스템 콜 예시

| 시스템 콜                                         | 설명                      |
| --------------------------------------------- | ----------------------- |
| `open(path, flags)`                           | 파일을 열어서 파일 디스크립터 반환     |
| `read(fd, buf, size)`                         | 파일에서 데이터를 읽어옴           |
| `write(fd, buf, size)`                        | 데이터를 파일에 씀              |
| `fork()`                                      | 현재 프로세스를 복제 (새 프로세스 생성) |
| `exec(path, args)`                            | 다른 프로그램을 실행             |
| `malloc(size)` (내부적으로 `brk()`, `mmap()` 등 호출) | 메모리 동적 할당 요청            |

이러한 시스템 콜을 통해 **사용자 프로그램은 간접적으로 OS와 대화하며**, 자원 접근, 프로세스 생성, 입출력 작업 등을 수행한다.

## 핵심 요약

* 커널은 운영체제의 핵심으로 하드웨어를 직접 제어하는 특권 영역이다
* 시스템 콜을 통해 사용자 프로그램이 안전하게 OS 기능을 사용할 수 있다
* 모드 전환(사용자 모드 ↔ 커널 모드) 시 오버헤드가 발생한다
* 보안과 안정성을 위해 하드웨어 직접 접근을 제한하고 커널이 중재한다

## 용어 설명

* **커널(Kernel)**: 운영체제의 핵심, 하드웨어 자원을 직접 제어
* **시스템 콜(System Call)**: 사용자 프로그램이 커널 기능을 요청하는 방법
* **트랩(Trap)**: 사용자 모드에서 커널 모드로 전환하는 인터럽트
* **오버헤드**: 시스템 콜 호출 시 발생하는 성능 비용
* **추상화**: 복잡한 하드웨어 동작을 간단한 함수 호출로 제공
* **특권 영역**: 하드웨어에 직접 접근할 수 있는 커널 모드

# 1.2-3 프로세스와 스레드

## 1. 프로세스(Process)란?

프로세스는 **실행 중인 프로그램의 인스턴스**로, 프로그램이 메모리에 적재되어 CPU 자원을 할당받아 수행되는 단위이다. 하나의 프로그램은 여러 개의 프로세스로 실행될 수 있다.

### 프로세스의 주요 특징
* 독립된 메모리 공간(코드, 데이터, 스택, 힙 영역)을 가짐
* 운영체제가 CPU, 메모리 등 자원을 할당함
* 프로세스 간에는 직접적인 메모리 공유가 불가능하며, 통신 시 별도 방식(IPC)을 사용해야 함

### 프로세스 구조 (메모리 관점)
```
┌────────────┐
│  코드 영역   │ (text segment)
├────────────┤
│  데이터 영역 │ (data segment)
├────────────┤
│    힙 영역   │ (heap)
├────────────┤
│   스택 영역  │ (stack)
└────────────┘
```

## 2. 스레드(Thread)란?

스레드는 **프로세스 내에서 실행되는 실행 단위(작업 흐름)**이다. 하나의 프로세스 안에는 여러 개의 스레드가 존재할 수 있으며, 이를 통해 병렬 처리(멀티스레딩)가 가능하다.

### 스레드의 특징
* 코드, 데이터, 힙 영역은 **동일 프로세스 내 스레드 간 공유**
* **스택 영역은 각 스레드마다 별도로 존재**
* 문맥 전환(Context Switching) 비용이 낮음 (프로세스 전환보다 가벼움)
* 한 스레드의 오류로 전체 프로세스가 영향을 받을 수 있음

### 멀티스레드 프로세스 구조
```
┌─────────────────────────────┐
│      하나의 프로세스         │
│ ┌─────────┬─────────────────┐│
│ │코드 영역 │    데이터 영역   ││ ← 공유
│ └─────────┴─────────────────┘│
│ ┌───────────────────────────┐│
│ │        힙 영역            ││ ← 공유  
│ └───────────────────────────┘│
│ ┌─────┐ ┌─────┐ ┌─────────┐ │
│ │스택1│ │스택2│ │ 스택3   │ │ ← 각각 독립
│ └─────┘ └─────┘ └─────────┘ │
└─────────────────────────────┘
```

## 3. 프로세스 vs 스레드 비교

| 항목 | 프로세스 | 스레드 |
|------|----------|--------|
| 기본 단위 | 프로그램 실행 단위 | 작업 실행 단위 |
| 메모리 | 독립적 메모리 공간 | 코드/데이터/힙 공유, 스택만 분리 |
| 생성 비용 | 큼 | 작음 |
| 통신 방식 | IPC 필요 | 공유 메모리 사용 |
| 안정성 | 높음 (독립성 보장) | 낮음 (영향 공유) |

## 4. 왜 스레드를 사용하는가?

* **빠른 처리**: 병렬 작업을 통해 응답성과 처리 속도 향상
* **자원 효율성**: 동일한 메모리 공간을 공유하므로 자원 절약
* **구체적 예시**:
  - 동영상 플레이어: 영상 재생 + 오디오 재생 + UI 처리 스레드 분리
  - 게임: 캐릭터 이동, 몬스터 AI, 그래픽 렌더링을 각각 다른 스레드로 처리

## 5. 멀티프로세싱 vs 멀티스레딩

| 항목 | 멀티프로세싱 | 멀티스레딩 |
|------|--------------|------------|
| 정의 | 여러 프로세스를 동시에 실행 | 하나의 프로세스 내 여러 스레드 실행 |
| 안정성 | 높음 (프로세스 간 영향 없음) | 낮음 (스레드 간 영향 있음) |
| 메모리 사용 | 더 많음 | 더 적음 |
| 예시 | 크롬 브라우저의 탭마다 독립 프로세스 | 게임에서 캐릭터, 배경, 효과 처리 스레드 분리 |

## 핵심 요약

* 프로세스는 독립된 메모리를 가진 실행 단위, 스레드는 프로세스 내 작업 단위
* 스레드는 메모리를 공유하므로 빠르지만, 하나의 오류가 전체에 영향을 줄 수 있음
* 멀티프로세싱은 안정성, 멀티스레딩은 효율성에 유리함
* 현대 프로그램은 대부분 멀티스레드 구조로 동작함

## 용어 설명

* **IPC(Inter-Process Communication)**: 프로세스 간 데이터를 주고받기 위한 기술 (ex. 파이프, 메시지 큐, 소켓 등)
* **Context Switching**: 현재 실행 중인 프로세스/스레드 상태를 저장하고 다른 것으로 전환하는 작업
* **병렬 처리**: 여러 작업을 동시에 수행하여 속도를 높이는 기법
* **힙/스택**: 힙은 동적 메모리 영역, 스택은 함수 호출 시 사용하는 임시 메모리 공간
* **메모리 공유**: 같은 메모리 주소를 여러 스레드가 동시에 접근하는 것



## 4. 프로세스 생명주기
- 프로세스 상태: 생성, 준비, 실행, 대기, 종료
- 상태 전이 다이어그램

## 5. 컨텍스트 스위칭
- 컨텍스트의 의미
- 컨텍스트 스위칭이 일어나는 시점
- 오버헤드 개념

## 6. 멀티프로세싱 vs 멀티스레딩
- 멀티프로세싱: 다중 CPU 환경
- 멀티스레딩: 하나의 프로세스 내 다중 스레드
- 장단점 비교

## 7. CPU 스케줄링
- 스케줄링의 필요성
- 선점형 vs 비선점형
- 주요 스케줄링 알고리즘
  - FCFS (First Come First Serve)
  - SJF (Shortest Job First)
  - RR (Round Robin)
  - Priority Scheduling

## 8. 메모리 관리
- 물리 메모리 vs 가상 메모리
- 메모리 할당 방식 (연속/불연속)
- 페이징(Paging)과 세그멘테이션(Segmentation)

## 9. 동기화와 상호배제
- 경쟁 상태(Race Condition)
- 뮤텍스(Mutex), 세마포어(Semaphore)의 개념
- 임계구역 문제와 해결 방안
- 데드락(Deadlock)과 예방/회피/회복

## 10. 파일 시스템
- 파일과 디렉토리 구조
- 파일 할당 방식 (연속, 연결, 인덱스)
- 저널링 파일 시스템(Journaling File System)

---
