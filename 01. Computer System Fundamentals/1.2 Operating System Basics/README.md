# 📘 1.2 운영체제 기본 개념

# 1.2-1 운영체제의 역할과 기능

## 1. 운영체제란?

운영체제(OS: Operating System)는 컴퓨터 하드웨어와 사용자 사이에서 **중재자** 역할을 하는 핵심 **시스템 소프트웨어**이다. 사용자가 컴퓨터를 사용할 수 있도록 환경을 제공하고, 내부 자원을 효율적으로 관리하여 프로그램이 원활히 실행되도록 한다.

## 2. 운영체제의 주요 역할

### 2.1 사용자와 하드웨어 간 인터페이스 제공
* 사용자가 하드웨어를 직접 제어하지 않고, 운영체제를 통해 파일 저장, 프로그램 실행, 장치 사용 등을 간편하게 수행
* 예: Windows의 바탕화면, 안드로이드의 홈 화면도 OS의 인터페이스

### 2.2 자원(Resource) 관리
운영체제는 다양한 하드웨어 자원을 효율적으로 관리한다:

| 자원 종류 | 관리 예시 |
|-----------|-----------|
| CPU | 여러 프로그램이 동시에 실행될 때 CPU 할당 조정 |
| 메모리 | 각 프로그램에 필요한 메모리 공간을 분할하여 제공 |
| 저장장치 | 파일의 저장 위치, 접근 권한 관리 |
| 입출력 장치 | 키보드, 마우스, 프린터 등 장치 제어 및 입출력 스케줄링 |
| 네트워크 | 네트워크 연결 관리, 프로토콜 처리, 보안 등 |

* 예: 게임을 하면서 동시에 음악을 듣고 채팅을 할 때, OS가 각 프로그램에 CPU와 메모리를 적절히 배분하여 모든 작업이 원활하게 동작하도록 함

### 2.3 프로그램 실행과 제어
* 실행 중인 프로그램을 **프로세스(Process)**로 관리
* 프로세스 간 전환(문맥 교환), 스케줄링 등을 통해 CPU를 효율적으로 활용
* 예: 여러 앱이 동시에 돌아가는 스마트폰에서 앱 간 전환을 관리하는 것이 OS의 역할

## 운영체제의 핵심 기능 요약

| 기능 분류 | 설명 |
|-----------|------|
| **프로세스 관리** | 프로그램 실행, 프로세스 생성/제거, 스케줄링, 동기화, **교착상태 방지** 등 |
| **메모리 관리** | 메모리 할당/해제, 가상 메모리 제공 등 |
| **파일 시스템** | 파일 생성, 삭제, 디렉토리 구조 관리, 접근 권한 제어 등 |
| **입출력 관리** | I/O 장치 제어, 버퍼링, 인터럽트 처리 등 |
| **사용자 인터페이스** | 셸(Shell), GUI 제공. 명령어 입력 또는 그래픽 환경으로 사용자 조작 가능 |

## 용어 설명
* **운영체제(OS)**: 하드웨어와 사용자 간의 중재자 역할을 하는 핵심 소프트웨어
* **시스템 소프트웨어**: 하드웨어를 제어하고 다른 소프트웨어의 실행을 지원하는 소프트웨어 (응용 소프트웨어와 구분됨)
* **자원(Resource)**: CPU, 메모리, 저장장치, 입출력 장치 등 컴퓨터의 구성 요소
* **프로세스(Process)**: 실행 중인 프로그램 단위
* **스케줄링(Scheduling)**: CPU 등 자원을 여러 작업에 효율적으로 배분하는 기법
* **셸(Shell)**: 사용자가 OS에 명령을 입력할 수 있는 인터페이스 (예: 터미널, 명령 프롬프트)

# 1.2-2 커널과 시스템 콜

## 1. 커널(Kernel)이란?

커널은 운영체제의 **핵심 부분이자 가장 낮은 수준의 추상화 계층**으로, 컴퓨터의 **하드웨어 자원을 직접 제어**하고 **모든 프로그램 실행을 관리**한다. 사용자와 하드웨어 사이의 **중간 관리자** 역할을 하며, 운영체제에서 가장 먼저 로드되고 가장 마지막에 종료되는 부분이다.

### 사용자 영역 vs 커널 영역

운영체제는 **보안성과 안정성 확보**를 위해 메모리 공간을 크게 두 영역으로 나눈다:

| 영역                     | 설명                       |
| ---------------------- | ------------------------ |
| **커널 영역(Kernel Mode)** | 운영체제와 하드웨어를 직접 다루는 특권 영역 |
| **사용자 영역(User Mode)**  | 일반 사용자 프로그램이 실행되는 제한된 영역 |

사용자 프로그램은 하드웨어에 직접 접근할 수 없고, **커널의 도움을 받아야만** 자원에 접근할 수 있다.

## 2. 시스템 콜(System Call)이란?

시스템 콜은 **사용자 프로그램이 운영체제의 커널 기능을 요청하는 메커니즘**이다. 즉, 프로그램이 CPU, 메모리, 파일, 네트워크 등 **하드웨어 자원이나 OS 서비스를 사용하고 싶을 때 커널에게 요청하는 통로**이다.

### 왜 시스템 콜이 필요한가?

* **보안**: 사용자 프로그램이 임의로 하드웨어에 접근하는 것을 방지
* **안정성**: 커널이 자원을 중앙에서 통제하므로 충돌이나 오류를 줄임
* **추상화**: 복잡한 하드웨어 제어를 단순한 함수 호출처럼 제공

## 3. 시스템 콜 처리 흐름

1. 사용자 프로그램이 시스템 콜 함수를 호출 (ex. `read()`)
2. CPU가 \*\*트랩(Trap)\*\*을 통해 **커널 모드로 전환**
3. 커널이 해당 요청을 처리
4. 처리 결과를 사용자 프로그램으로 반환
5. CPU는 다시 **사용자 모드로 복귀**

**실생활 예시**: 메모장에서 "저장" 버튼을 누르면

1. 프로그램이 write() 시스템 콜 호출
2. 커널 모드 전환 → 파일 시스템이 디스크에 쓰기
3. 완료 후 사용자 모드로 복귀 → "저장 완료" 메시지 표시

### 시스템 콜 오버헤드

* **모드 전환 비용**: 사용자 모드 ↔ 커널 모드 전환 시 **성능 저하** 발생
* 시스템 콜은 일반 함수 호출보다 **수십 배 이상 느릴 수 있음**

## 주요 시스템 콜 예시

| 시스템 콜                                         | 설명                      |
| --------------------------------------------- | ----------------------- |
| `open(path, flags)`                           | 파일을 열어서 파일 디스크립터 반환     |
| `read(fd, buf, size)`                         | 파일에서 데이터를 읽어옴           |
| `write(fd, buf, size)`                        | 데이터를 파일에 씀              |
| `fork()`                                      | 현재 프로세스를 복제 (새 프로세스 생성) |
| `exec(path, args)`                            | 다른 프로그램을 실행             |
| `malloc(size)` (내부적으로 `brk()`, `mmap()` 등 호출) | 메모리 동적 할당 요청            |

이러한 시스템 콜을 통해 **사용자 프로그램은 간접적으로 OS와 대화하며**, 자원 접근, 프로세스 생성, 입출력 작업 등을 수행한다.

## 핵심 요약

* 커널은 운영체제의 핵심으로 하드웨어를 직접 제어하는 특권 영역이다
* 시스템 콜을 통해 사용자 프로그램이 안전하게 OS 기능을 사용할 수 있다
* 모드 전환(사용자 모드 ↔ 커널 모드) 시 오버헤드가 발생한다
* 보안과 안정성을 위해 하드웨어 직접 접근을 제한하고 커널이 중재한다

## 용어 설명

* **커널(Kernel)**: 운영체제의 핵심, 하드웨어 자원을 직접 제어
* **시스템 콜(System Call)**: 사용자 프로그램이 커널 기능을 요청하는 방법
* **트랩(Trap)**: 사용자 모드에서 커널 모드로 전환하는 인터럽트
* **오버헤드**: 시스템 콜 호출 시 발생하는 성능 비용
* **추상화**: 복잡한 하드웨어 동작을 간단한 함수 호출로 제공
* **특권 영역**: 하드웨어에 직접 접근할 수 있는 커널 모드

# 1.2-3 프로세스와 스레드

## 1. 프로세스(Process)란?

프로세스는 **실행 중인 프로그램의 인스턴스**로, 프로그램이 메모리에 적재되어 CPU 자원을 할당받아 수행되는 단위이다. 하나의 프로그램은 여러 개의 프로세스로 실행될 수 있다.

### 프로세스의 주요 특징
* 독립된 메모리 공간(코드, 데이터, 스택, 힙 영역)을 가짐
* 운영체제가 CPU, 메모리 등 자원을 할당함
* 프로세스 간에는 직접적인 메모리 공유가 불가능하며, 통신 시 별도 방식(IPC)을 사용해야 함

### 프로세스 구조 (메모리 관점)
```
┌────────────┐
│  코드 영역   │ (text segment)
├────────────┤
│  데이터 영역 │ (data segment)
├────────────┤
│    힙 영역   │ (heap)
├────────────┤
│   스택 영역  │ (stack)
└────────────┘
```

## 2. 스레드(Thread)란?

스레드는 **프로세스 내에서 실행되는 실행 단위(작업 흐름)**이다. 하나의 프로세스 안에는 여러 개의 스레드가 존재할 수 있으며, 이를 통해 병렬 처리(멀티스레딩)가 가능하다.

### 스레드의 특징
* 코드, 데이터, 힙 영역은 **동일 프로세스 내 스레드 간 공유**
* **스택 영역은 각 스레드마다 별도로 존재**
* 문맥 전환(Context Switching) 비용이 낮음 (프로세스 전환보다 가벼움)
* 한 스레드의 오류로 전체 프로세스가 영향을 받을 수 있음

### 멀티스레드 프로세스 구조
```
┌─────────────────────────────┐
│      하나의 프로세스         │
│ ┌─────────┬─────────────────┐│
│ │코드 영역 │    데이터 영역   ││ ← 공유
│ └─────────┴─────────────────┘│
│ ┌───────────────────────────┐│
│ │        힙 영역            ││ ← 공유  
│ └───────────────────────────┘│
│ ┌─────┐ ┌─────┐ ┌─────────┐ │
│ │스택1│ │스택2│ │ 스택3   │ │ ← 각각 독립
│ └─────┘ └─────┘ └─────────┘ │
└─────────────────────────────┘
```

## 3. 프로세스 vs 스레드 비교

| 항목 | 프로세스 | 스레드 |
|------|----------|--------|
| 기본 단위 | 프로그램 실행 단위 | 작업 실행 단위 |
| 메모리 | 독립적 메모리 공간 | 코드/데이터/힙 공유, 스택만 분리 |
| 생성 비용 | 큼 | 작음 |
| 통신 방식 | IPC 필요 | 공유 메모리 사용 |
| 안정성 | 높음 (독립성 보장) | 낮음 (영향 공유) |

## 4. 왜 스레드를 사용하는가?

* **빠른 처리**: 병렬 작업을 통해 응답성과 처리 속도 향상
* **자원 효율성**: 동일한 메모리 공간을 공유하므로 자원 절약
* **구체적 예시**:
  - 동영상 플레이어: 영상 재생 + 오디오 재생 + UI 처리 스레드 분리
  - 게임: 캐릭터 이동, 몬스터 AI, 그래픽 렌더링을 각각 다른 스레드로 처리

## 5. 멀티프로세싱 vs 멀티스레딩

| 항목 | 멀티프로세싱 | 멀티스레딩 |
|------|--------------|------------|
| 정의 | 여러 프로세스를 동시에 실행 | 하나의 프로세스 내 여러 스레드 실행 |
| 안정성 | 높음 (프로세스 간 영향 없음) | 낮음 (스레드 간 영향 있음) |
| 메모리 사용 | 더 많음 | 더 적음 |
| 예시 | 크롬 브라우저의 탭마다 독립 프로세스 | 게임에서 캐릭터, 배경, 효과 처리 스레드 분리 |

## 핵심 요약

* 프로세스는 독립된 메모리를 가진 실행 단위, 스레드는 프로세스 내 작업 단위
* 스레드는 메모리를 공유하므로 빠르지만, 하나의 오류가 전체에 영향을 줄 수 있음
* 멀티프로세싱은 안정성, 멀티스레딩은 효율성에 유리함
* 현대 프로그램은 대부분 멀티스레드 구조로 동작함

## 용어 설명

* **IPC(Inter-Process Communication)**: 프로세스 간 데이터를 주고받기 위한 기술 (ex. 파이프, 메시지 큐, 소켓 등)
* **Context Switching**: 현재 실행 중인 프로세스/스레드 상태를 저장하고 다른 것으로 전환하는 작업
* **병렬 처리**: 여러 작업을 동시에 수행하여 속도를 높이는 기법
* **힙/스택**: 힙은 동적 메모리 영역, 스택은 함수 호출 시 사용하는 임시 메모리 공간
* **메모리 공유**: 같은 메모리 주소를 여러 스레드가 동시에 접근하는 것

# 1.2-4 프로세스 생명주기

## 1. 프로세스 상태란?

프로세스는 실행되는 동안 여러 상태를 거치며, 운영체제는 이 상태들을 관리하며 CPU를 효율적으로 할당한다. 각 상태는 프로세스의 현재 실행 상황을 의미한다.

## 2. 주요 상태 5단계

| 상태 | 설명 |
|------|------|
| **New** | 프로세스가 생성 중인 상태 (메모리 할당 전) |
| **Ready** | 실행 준비 완료, CPU 할당을 기다리는 상태 |
| **Running** | CPU를 할당받아 명령어를 실행 중인 상태 |
| **Waiting (Blocked)** | 입출력, 파일 읽기, 사용자 입력 등 외부 이벤트를 기다리는 상태 |
| **Terminated** | 실행 완료 또는 강제 종료된 상태 |

## 3. 상태 전이 도식

```
    New
     ↓
   Ready ←──────────┐
     ↓             │
  Running          │
   ↙   ↘           │
Waiting  Ready ─────┘
   ↓
  Ready
   
(종료 시)
Running → Terminated
```

## 예시로 이해하기

 **예: 워드 프로세서(한글/MS Word) 실행 과정**

1. **New**: 사용자가 한글 아이콘을 더블클릭 → 프로그램 로딩 중
2. **Ready**: 메모리에 로딩 완료, CPU 할당 대기
3. **Running**: 한글 실행 중 (화면 표시, 메뉴 처리)
4. **Waiting**: 사용자가 "파일 열기" 클릭 → 디스크에서 파일 읽는 동안 대기
5. **Ready**: 파일 읽기 완료, 다시 CPU 할당 대기
6. **Running**: 파일 내용을 화면에 표시
7. **Waiting**: 사용자가 키보드 입력할 때까지 대기
8. **Ready**: 키보드 입력 발생, CPU 할당 대기
9. **Running**: 입력된 문자를 화면에 표시
10. **Terminated**: 사용자가 프로그램 종료

## 핵심 요약

* **Ready**: CPU 할당 대기, 스케줄러 대상
* **Running**: CPU 점유 중, 계산 수행
* **Waiting**: I/O 등 외부 이벤트 대기, CPU 반납
* **Terminated**: 실행 종료 상태
* 운영체제는 이 상태 전이를 스케줄링, 인터럽트, 이벤트 처리로 제어함

## 용어 설명

* **스케줄러(Scheduler)**: Ready 상태 중 어떤 프로세스에 CPU를 줄지 결정
* **컨텍스트 스위칭**: 실행 중인 프로세스 정보를 저장하고 다른 프로세스를 실행하는 과정
* **시분할(Time-sharing)**: 각 프로세스에 CPU 시간을 짧게 분할하여 번갈아 실행함
* **선점(Preemption)**: 실행 중인 프로세스를 강제로 중단하고 다른 프로세스에 CPU 할당
* **타임슬라이스**: 각 프로세스에 할당되는 CPU 사용 시간



# 1.2-5 컨텍스트 스위칭

## 1. 컨텍스트(Context)란?

컨텍스트는 프로세스나 스레드의 **실행 상태를 저장한 정보의 집합**을 의미한다. CPU는 여러 작업을 번갈아 수행하기 위해, 각 프로세스의 상태(Context)를 저장하고 복원해야 한다.

### 컨텍스트에 포함되는 정보

* **프로그램 카운터(PC)**: 다음에 실행할 명령어의 주소
* **레지스터 값들**: 연산 중인 데이터
* **메모리 관리 정보**: 페이지 테이블 등
* **스케줄링 정보**: 우선순위, 상태 등

## 2. 컨텍스트 스위칭이란?

컨텍스트 스위칭(Context Switching)은 **운영체제가 실행 중인 프로세스나 스레드의 컨텍스트를 저장하고, 다른 작업의 컨텍스트를 복원하여 CPU 제어를 전환하는 과정**이다.

### 발생 시점

* **타임슬라이스가 끝난 경우** (시분할 시스템)
* **I/O 요청 등으로 프로세스가 대기 상태로 전환될 때**
* **인터럽트 발생 시** (외부 이벤트에 대응)
* **우선순위 높은 프로세스가 도착한 경우** (선점형 스케줄링)

## 3. 컨텍스트 스위칭 과정

1. 현재 실행 중인 프로세스의 컨텍스트 저장 (레지스터, PC 등)
2. 새로 실행할 프로세스의 컨텍스트 복원
3. CPU 제어권을 새로운 프로세스에 넘김

이러한 저장/복원 작업은 매우 빠르게 이뤄지지만, **완전히 무료는 아니다**.

## 오버헤드(Overhead)

컨텍스트 스위칭은 **시스템 자원을 소비하는 작업**이며, 다음과 같은 오버헤드가 발생할 수 있다:

| 항목           | 설명                                |
| ------------ | --------------------------------- |
| **시간 지연**    | 저장/복원 과정에서 수백\~수천 사이클 소모          |
| **캐시 무효화**   | CPU 캐시에 있던 데이터가 새로운 프로세스와 다를 수 있음 |
| **전력 소비 증가** | 빈번한 스위칭은 에너지 낭비로 이어짐              |

## 핵심 요약

* 컨텍스트는 프로세스의 실행 상태(레지스터, PC 등)를 저장한 정보 집합이다
* 컨텍스트 스위칭은 운영체제가 CPU 제어를 다른 작업으로 넘기는 메커니즘이다
* 타임슬라이스 종료, I/O 대기, 인터럽트 등에서 발생하며
* 저장/복원, 캐시 무효화로 인한 **성능 손실(오버헤드)** 이 존재한다

## 용어 설명

* **프로그램 카운터(PC)**: 현재 또는 다음에 실행할 명령어의 주소를 저장
* **레지스터**: CPU 내부의 고속 임시 저장 공간
* **캐시 무효화(Cache Invalidation)**: CPU 캐시에 저장된 데이터가 다른 작업에는 유효하지 않아 다시 로딩해야 하는 상황
* **문맥 전환 비용**: 컨텍스트 저장/복원, 캐시 초기화 등에 소요되는 시간과 자원
* **타임슬라이스(Time Slice)**: 시분할 시스템에서 하나의 프로세스에 할당된 CPU 시간


# 1.2-6 멀티프로세싱 vs 멀티스레딩

## 1. 멀티프로세싱이란?

멀티프로세싱(Multiprocessing)은 **두 개 이상의 CPU(Core)를 사용하는 구조**로, 동시에 여러 프로세스를 병렬로 실행할 수 있다.

### 멀티프로세싱의 특징

* 각 프로세스가 **독립된 메모리 공간**을 가짐
* CPU가 많을수록 처리 속도 증가
* \*\*프로세스 간 통신(IPC)\*\*이 필요함 (비용 발생)
* 안정성이 높음: 하나의 프로세스 오류가 다른 프로세스에 영향 없음

## 2. 멀티스레딩이란?

멀티스레딩(Multithreading)은 **하나의 프로세스 내에서 여러 스레드가 동시에 실행**되는 구조이다. 각 스레드는 코드, 데이터, 힙을 공유하고 스택만 독립적으로 가진다.

### 멀티스레딩의 특징

* 같은 프로세스 내에서 실행되므로 **메모리 사용 효율이 좋음**
* 문맥 전환 비용이 적음 (가볍다)
* 스레드 간 메모리를 공유하므로 **빠른 통신 가능**
* 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있음

## 구조 비교 도식

```
[멀티프로세싱]
┌────────────┐     ┌────────────┐
│ 프로세스 A │     │ 프로세스 B │
│ 코드/데이터│     │ 코드/데이터│
│ 힙/스택     │     │ 힙/스택     │
└────────────┘     └────────────┘
    │                    │
    └────CPU 분배──────┘

[멀티스레딩]
┌────────────────────────────┐
│           프로세스            │
│ ┌────공유: 코드/데이터/힙────┐ │
│ │                            │ │
│ │  스레드1   스레드2   스레드3  │ │
│ │ (스택만 별도)                │ │
│ └────────────────────────────┘ │
└────────────────────────────┘
```

## 3. 멀티프로세싱 vs 멀티스레딩

| 항목     | 멀티프로세싱      | 멀티스레딩                 |
| ------ | ----------- | --------------------- |
| 기본 단위  | 프로세스        | 스레드                   |
| 메모리 구조 | 독립          | 공유 (스택 제외)            |
| 통신 방식  | IPC 필요      | 공유 메모리                |
| 안정성    | 높음          | 낮음 (오류 전파 가능성)        |
| 전환 비용  | 높음          | 낮음                    |
| 예시     | 크롬 탭마다 프로세스 | 게임 엔진의 렌더링/물리/사운드 스레드 |

## 핵심 요약

* 멀티프로세싱은 CPU 코어가 여러 개일 때 병렬 처리에 효과적이며, 안정성이 높다
* 멀티스레딩은 자원을 공유하여 효율이 높지만, 오류 전파 가능성과 디버깅 어려움이 있다
* 문맥 전환 비용이나 메모리 효율 등을 고려해 상황에 따라 선택해야 한다

## 용어 설명

* **IPC (Inter-Process Communication)**: 프로세스 간 통신 방식 (ex. 파이프, 메시지 큐, 소켓 등)
* **스레드 풀(Thread Pool)**: 미리 생성해둔 스레드를 재사용하여 작업 처리 효율을 높이는 기법
* **Forking**: 프로세스를 복제하여 새로운 프로세스를 생성하는 행위
* **Race Condition**: 여러 스레드가 공유 자원에 동시에 접근하여 결과가 예측 불가능해지는 상황

# 1.2-7 CPU 스케줄링

## 1. CPU 스케줄링이란?

CPU 스케줄링은 **Ready 상태의 여러 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 작업**이다. CPU는 한 번에 하나의 프로세스만 실행할 수 있으므로, 효율적인 자원 배분을 위해 스케줄링이 필요하다.

### 스케줄링이 일어나는 시점

* 프로세스가 종료될 때
* 프로세스가 I/O 등으로 Waiting 상태로 전환될 때
* 새로운 프로세스가 Ready 상태로 진입할 때
* 타이머 인터럽트에 의해 시간 할당이 끝날 때 (선점형)

## 2. 선점형 vs 비선점형

| 유형       | 설명                                                          | 예시                      |
| -------- | ----------------------------------------------------------- | ----------------------- |
| **비선점형** | 한 번 CPU를 할당받은 프로세스가 스스로 종료하거나 I/O 요청을 하기 전까지 CPU를 계속 사용     | FCFS, SJF               |
| **선점형**  | 더 높은 우선순위의 프로세스가 Ready 상태로 진입하면 현재 실행 중인 프로세스를 중단하고 CPU를 양도 | RR, Priority(선점형), SRTF |

## 3. 주요 스케줄링 알고리즘

### 3.1 FCFS (First Come First Serve)

* 먼저 도착한 순서대로 CPU를 할당
* 큐 방식
* **단점**: 긴 작업이 앞에 있으면 전체 지연 발생 (Convoy Effect)
* **예시**: 프로세스 A(도착시간 0, 실행시간 4), B(도착시간 1, 실행시간 1), C(도착시간 2, 실행시간 1) → 평균 대기시간 증가

### 3.2 SJF (Shortest Job First)

* 실행 시간이 가장 짧은 프로세스에 먼저 CPU 할당
* **장점**: 평균 대기 시간 최소화
* **단점**: 실행 시간을 정확히 예측하기 어려움
* **예시**: A(8), B(4), C(1) → 실행 순서: C → B → A

### 3.3 RR (Round Robin)

* 각 프로세스에 일정 시간(Time Quantum)만큼 CPU를 할당하고, 순환하면서 실행
* **장점**: 응답 시간이 좋고 공정성 보장
* **단점**: Time Quantum이 너무 짧으면 컨텍스트 스위칭 오버헤드 발생
* **예시**: A(도착 0, 실행 6), B(도착 1, 실행 4), Time Quantum = 2 → 순환 실행

### 3.4 Priority Scheduling

* 프로세스마다 우선순위를 부여하고, 높은 우선순위부터 실행
* **단점**: 낮은 우선순위 프로세스가 무한정 대기 (Starvation)
* **보완**: Aging 기법 (대기 시간이 길어질수록 우선순위 상승)
* **예시**: A(우선순위 3), B(우선순위 1), C(우선순위 2) → 실행 순서: B → C → A

## 4. 알고리즘 비교

| 알고리즘     | 유형     | 장점             | 단점                     | 적용 분야                |
| -------- | ------ | -------------- | ---------------------- | -------------------- |
| FCFS     | 비선점형   | 구현이 간단         | 긴 작업 앞에 있을 경우 대기 시간 증가 | 단일 작업 처리, 일괄 시스템     |
| SJF      | 비선점형   | 평균 대기 시간 최소화   | 실행 시간 예측 어려움           | 배치 처리 시스템            |
| RR       | 선점형    | 공정하고 응답성 높음    | 잦은 컨텍스트 스위칭            | 타임쉐어링 시스템, 다중 사용자 환경 |
| Priority | 선/비선점형 | 중요 작업 우선 처리 가능 | 기아 현상 발생 가능성           | 실시간 시스템, 우선순위 기반 서비스 |

## 핵심 요약

* CPU 스케줄링은 Ready 상태의 프로세스 중 CPU를 누가 사용할지 결정하는 작업이다
* 선점형은 중간에 프로세스를 중단할 수 있고, 비선점형은 그렇지 않다
* FCFS, SJF, RR, Priority는 각각의 특성과 용도에 맞게 선택해야 한다
* Time Quantum, Starvation, Context Switching 등은 실전 설계에서 중요한 요소다

## 용어 설명

* **Convoy Effect**: 짧은 작업들이 긴 작업 뒤에 묶여 지연되는 현상
* **Time Quantum**: Round Robin에서 프로세스에 주어지는 시간 단위
* **Starvation**: 우선순위가 낮은 작업이 계속 대기하게 되는 문제
* **Aging**: Starvation을 방지하기 위해 대기 시간이 길수록 우선순위를 높이는 기법
* **SRTF (Shortest Remaining Time First)**: SJF의 선점형 버전으로, 남은 실행 시간이 가장 짧은 프로세스에 CPU를 할당


# 1.2-8 메모리 관리

## 1. 메모리 관리란?

운영체제는 **여러 프로세스에 메모리를 효율적으로 분배하고 관리**해야 한다. 제한된 메모리 자원을 효율적으로 사용하는 것이 중요하며, 이를 위해 다양한 기법이 사용된다.

## 2. 물리 메모리 vs 가상 메모리

| 구분    | 물리 메모리    | 가상 메모리                       |
| ----- | --------- | ---------------------------- |
| 정의    | 실제 RAM 공간 | 논리적으로 확장된 메모리 공간 (디스크 일부 활용) |
| 접근 방식 | 직접 접근     | 운영체제가 매핑하여 간접 접근             |
| 용도    | 실제 데이터 저장 | 프로세스가 사용하는 논리 주소 공간          |

* \*\*가상 메모리(Virtual Memory)\*\*는 프로세스마다 독립적인 메모리 공간을 제공하며, **물리 메모리보다 더 큰 주소 공간을 사용할 수 있게 한다**.

## 3. 메모리 할당 방식

### 3.1 연속 할당 방식

* 메모리를 **연속된 블록**으로 할당
* 단점: **외부 단편화(External Fragmentation)** 발생 가능

#### 고정 분할

* 메모리를 미리 정해진 크기로 나누어 할당
* 분할 간 **크기 차이로 인한 낭비** 발생 가능 (내부 단편화)

#### 가변 분할

* 요청 크기만큼 메모리를 할당
* 사용 후 해제가 반복되면 **외부 단편화** 발생 가능

### 3.2 불연속 할당 방식

* 물리 메모리의 **여러 영역에 나누어 저장 가능** (프로세스가 연속되지 않아도 됨)
* 대표 기법: **페이징, 세그멘테이션**

## 4. 페이징(Paging)

* 메모리를 **고정 크기**의 블록인 페이지(Page)로 나누어 관리
* **프레임(Frame)**: 물리 메모리의 고정 크기 블록
* **페이지(Page)**: 가상 주소 공간의 블록
* 페이지 테이블을 통해 가상 주소 → 물리 주소 매핑

### 특징

* 연속된 공간이 필요 없으므로 **외부 단편화를 줄임**
* 단, 마지막 페이지에 남는 공간으로 인해 **내부 단편화** 발생 가능

### 주소 변환 과정

```
[가상 주소] → [페이지 번호 + 오프셋]
→ 페이지 테이블 참조 → 프레임 번호로 변환 → [물리 주소]
```

## 5. 세그멘테이션(Segmentation)

* **논리적 단위(세그먼트)** 단위로 메모리를 분할 (예: 코드, 데이터, 스택)
* 각 세그먼트는 크기가 다르고 독립적임
* 세그먼트 테이블을 통해 접근 (세그먼트 번호 + 오프셋)

### 특징

* 프로그래머가 논리 구조대로 메모리 관리 가능
* **외부 단편화** 발생 가능 (가변 크기 세그먼트)
* 내부 단편화는 거의 없음

## 핵심 요약

* 연속 할당은 단순하지만 외부 단편화 문제가 있음
* 페이징은 고정 크기 분할로 **외부 단편화를 줄이고**, 내부 단편화는 일부 발생
* 세그멘테이션은 논리 단위 분할로 유연하지만 외부 단편화 발생 가능
* 가상 메모리를 통해 물리 메모리를 초과하는 주소 공간을 사용할 수 있음

## 용어 설명

* **가상 메모리**: 물리 메모리보다 큰 주소 공간을 제공하는 기법
* **페이지(Page)**: 가상 메모리를 고정 크기로 나눈 블록
* **프레임(Frame)**: 물리 메모리를 고정 크기로 나눈 블록
* **페이지 테이블**: 가상 주소를 물리 주소로 변환하는 자료구조
* **세그먼트(Segment)**: 코드, 데이터, 스택 등 논리적 단위의 메모리 블록
* **내부 단편화**: 할당된 메모리 블록 내에서 사용되지 않는 공간이 생기는 현상
* **외부 단편화**: 전체 메모리 공간은 충분하지만 연속되지 않아 사용할 수 없는 현상

# 1.2-9 동기화와 상호배제

## 1. 경쟁 상태(Race Condition)

경쟁 상태는 **둘 이상의 스레드 또는 프로세스가 동시에 같은 자원에 접근**하고, 그 중 **하나 이상이 쓰기 연산을 수행할 때** 발생하는 문제이다. 실행 순서에 따라 결과가 달라질 수 있어 **예측 불가능한 버그**로 이어진다.

### 예시

* 은행 시스템에서 동시에 같은 계좌에 입출금을 할 경우, 순서에 따라 잔액이 다르게 계산될 수 있음

## 2. 임계구역(Critical Section)과 상호배제(Mutual Exclusion)

**임계구역**은 둘 이상의 스레드가 동시에 접근하면 안 되는 공유 자원 접근 코드 영역이다.

**상호배제**는 한 번에 하나의 스레드만 임계구역에 들어가도록 제어하는 개념이다. 이를 통해 경쟁 상태를 방지한다.

### 임계구역 문제 해결 조건

| 조건        | 설명                              |
| --------- | ------------------------------- |
| **상호배제**  | 동시에 둘 이상 진입 불가                  |
| **진행 조건** | 임계구역 진입 여부는 참여 중인 프로세스에 의해서만 결정 |
| **한정 대기** | 특정 프로세스가 무한히 기다리지 않도록 보장        |

## 3. 뮤텍스(Mutex)와 세마포어(Semaphore)

### 뮤텍스 (Mutual Exclusion Object)

* 이진 상태(locked/unlocked)를 가지며, **한 번에 하나의 스레드만 자원 접근 가능**
* 잠금 획득 → 임계구역 진입 → 작업 종료 후 잠금 해제
* 자원 보호에 적합 (ex. 파일 쓰기, 리스트 수정 등)

### 세마포어 (Semaphore)

* **정수 값 기반의 동기화 도구**, 두 가지 종류가 있음:

  * **카운팅 세마포어**: 동시에 여러 개까지 접근 허용 (ex. DB 커넥션 풀)
  * **바이너리 세마포어**: 0 또는 1의 값을 가지며 뮤텍스와 유사
* `P()` 연산: 값 감소, 자원 요청
* `V()` 연산: 값 증가, 자원 반환

### 예시 비교

| 상황            | 적합한 도구            |
| ------------- | ----------------- |
| 단일 파일 접근 보호   | 뮤텍스               |
| 동시에 3명만 접속 허용 | 카운팅 세마포어 (초기값: 3) |

## 4. 데드락(Deadlock)

데드락은 **여러 프로세스가 서로 자원을 점유한 채 상대방의 자원을 기다리며 무한 대기**하는 상태다.

### 데드락 발생 조건 (Coffman 조건)

| 조건         | 설명                        |
| ---------- | ------------------------- |
| **상호배제**   | 자원을 한 번에 한 프로세스만 사용할 수 있음 |
| **점유와 대기** | 자원을 점유한 채 다른 자원을 기다림      |
| **비선점**    | 자원을 강제로 빼앗을 수 없음          |
| **순환 대기**  | 프로세스 간 원형 대기 형태 존재        |

### 해결 방법

* **예방**: 네 가지 조건 중 하나라도 성립하지 않게 설계
* **회피**: 자원 요청 시 데드락 가능성을 평가해 결정 (ex. 은행가 알고리즘)
* **발견**: 주기적으로 자원 그래프를 점검해 데드락 상태 탐지
* **복구**: 데드락 상태 프로세스를 종료하거나 자원을 회수함

## 핵심 요약

* 경쟁 상태는 동시에 공유 자원 접근 시 발생하는 예측 불가능한 문제이다.
* 임계구역은 공유 자원을 다루는 코드 블록이며, 상호배제를 통해 하나씩 접근하도록 제어해야 한다.
* 뮤텍스는 1개 스레드만 자원에 접근하게 하며, 세마포어는 여러 접근을 제어할 수 있다.
* 데드락은 자원을 기다리며 무한 대기하는 상태로, 이를 방지하거나 회피해야 한다.

## 용어 설명

* **경쟁 상태 (Race Condition)**: 여러 스레드가 동시에 자원에 접근해 실행 순서에 따라 결과가 달라지는 문제
* **임계구역 (Critical Section)**: 동시에 접근하면 문제가 발생하는 공유 자원 영역
* **상호배제 (Mutual Exclusion)**: 임계구역에 하나의 스레드만 접근하도록 보장
* **뮤텍스 (Mutex)**: 상호배제를 위해 사용하는 이진 잠금 장치
* **세마포어 (Semaphore)**: 정수값으로 접근을 제어하는 동기화 기법
* **데드락 (Deadlock)**: 서로 자원을 점유한 채 상대방 자원을 기다려 발생하는 교착 상태
* **은행가 알고리즘 (Banker’s Algorithm)**: 시스템이 안전 상태일 때만 자원 할당을 허용하는 회피 기법


# 1.2-10 파일 시스템

## 1. 파일과 디렉토리 구조

운영체제는 저장장치에 있는 데이터를 **파일(File)** 단위로 관리하며, 이러한 파일들을 계층 구조로 정리한 것이 **디렉토리(Directory)** 구조이다.

### 파일의 구성 요소

* 파일 이름
* 파일 위치 (디렉토리 경로)
* 크기, 생성/수정 시각
* 접근 권한 (읽기/쓰기/실행)

### 디렉토리 구조 유형

| 유형     | 설명                             | 예시              |
| ------ | ------------------------------ | --------------- |
| 단일 레벨  | 모든 파일이 하나의 디렉토리에 위치            | 간단하지만 이름 중복 불가  |
| 2단계 구조 | 사용자별 서브디렉토리 제공                 | 사용자 격리 가능       |
| 트리 구조  | 디렉토리 안에 하위 디렉토리 포함             | 대부분의 현대 OS에서 사용 |
| 그래프 구조 | 파일이 여러 디렉토리에 연결될 수 있음 (하드링크 등) | 유연하나 복잡도 증가     |

## 2. 파일 할당 방식

운영체제는 파일의 데이터를 디스크 블록에 저장할 때, 효율적인 공간 관리와 빠른 접근을 위해 다음과 같은 **할당 방식**을 사용한다.

### 2.1 연속 할당(Contiguous Allocation)

* 파일이 디스크 상에 **연속된 블록**에 저장됨
* 장점: 빠른 접근 속도 (순차 접근 유리)
* 단점: 파일 크기 변경 시 공간 재배치 필요, **외부 단편화 발생**
* 예시: 고정된 크기의 영상 파일

### 2.2 연결 할당(Linked Allocation)

* 파일 블록들이 디스크 상에서 **포인터로 연결**됨
* 장점: 파일 크기 변경이 유연, 단편화 문제 없음
* 단점: 임의 접근 속도 느림 (포인터 따라야 함)
* 예시: 로그 파일

### 2.3 인덱스 할당(Indexed Allocation)

* 별도의 **인덱스 블록**에 모든 블록의 위치 저장
* 장점: 임의 접근 가능 + 단편화 적음
* 단점: 인덱스 블록 크기 제한이 있을 수 있음
* 예시: 대부분의 현대 파일 시스템에서 사용

## 3. 저널링 파일 시스템

**저널링(Journaling) 파일 시스템**은 시스템 장애나 예기치 않은 종료가 발생했을 때 **데이터 손실을 최소화**하기 위해 변경 내용을 먼저 \*\*로그(저널)\*\*에 기록한 뒤, 실제 디스크에 반영하는 방식이다.

### 동작 흐름

1. 파일에 대한 변경 요청 발생
2. 변경 내용을 저널에 기록
3. 변경 완료 후 디스크에 적용
4. 장애 발생 시 저널 로그를 기반으로 복구 시도

### 장점

* 전원 끊김, 시스템 오류 발생 시에도 **파일 시스템 일관성 유지**
* 복구 속도 빠름 (전체 검사 대신 로그만 검사)

### 대표적 저널링 파일 시스템

* Linux: `ext3`, `ext4`, `ReiserFS`, `XFS`
* Windows: `NTFS`

## 핵심 요약

* 운영체제는 파일을 디렉토리 구조로 계층적으로 관리하며, 디스크에 할당된 블록을 통해 저장함
* 할당 방식은 연속/연결/인덱스 방식이 있으며, 각각 성능과 유연성에서 차이를 보임
* 저널링 파일 시스템은 장애 복구와 안정성 측면에서 현대 OS에서 필수적으로 채택됨

## 용어 설명

* **파일 시스템(File System)**: 데이터를 파일 단위로 저장하고 관리하는 체계
* **디렉토리(Directory)**: 파일들을 계층적으로 관리하는 구조
* **외부 단편화**: 연속 공간이 부족해 파일 저장이 어려운 현상
* **저널링(Journaling)**: 변경 사항을 로그에 먼저 기록한 뒤 적용하는 기법
* **인덱스 블록**: 파일의 데이터 블록 위치를 저장하는 테이블 형태의 구조

---
