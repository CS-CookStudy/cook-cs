## 4. 성능 최적화 전략 (Performance Optimization)

- **정의** : 시스템의 자원을 효율적으로 활용하여 응답 시간 단축, 처리량 증가, 안정성 확보를 목적

---

### ○ 메모리 접근 최적화

#### 1. 공간 지역성 (Spatial Locality)
- 인접한 메모리 주소를 순차적으로 접근하면 캐시 적중률 증가
- 배열 순차 탐색 등에서 유리

#### 2. 시간 지역성 (Temporal Locality)
- 동일 데이터에 반복 접근할 경우, 캐시에 머무르게 하여 접근 시간 단축


### ○ 캐시 활용 및 메모리 계층 이해
- CPU → L1 → L2 → L3 → RAM → Disk 순의 계층 구조 존재
- 캐시 적중률 향상이 곧 성능 향상
- 데이터 구조, 접근 방식에 따라 캐시 효율 달라짐

### ○ 루프 및 연산 최적화

#### 1. 루프 전개 (Loop Unrolling)
- 반복 횟수를 줄여 루프 오버헤드 최소화

#### 2. 루프 불변식 제거
- 반복문 내에서 변하지 않는 연산은 바깥으로 이동

#### 3. 인라인 함수 사용
- 함수 호출 오버헤드 제거 (단, 남용 시 코드 크기 증가 주의)


### ○  데이터 접근 패턴 개선
- 순차 접근이 랜덤 접근보다 빠르므로 구조적으로 최적화
- 2차원 배열: row-major 방식(행 우선)이 더 빠름

### ○ 불필요한 객체 생성 제거
- 매번 객체 생성 대신 재사용 또는 풀링(Object Pool) 기법 활용
- GC 부담 완화 및 성능 향상

### ○ HTTP 최적화
#### 1. Keep-Alive
- 매 요청마다 TCP 연결하지 않고 재사용하여 오버헤드 줄임

#### 2. gzip 압축
- HTTP 응답을 압축하여 전송량 감소 및 로딩 속도 개선

### ○ DB 성능 최적화

#### 1. Connection Pool 사용
- 커넥션 생성/해제 비용 최소화

#### 2. 쿼리 튜닝
- N+1 문제 해결 (Join, Fetch Join 등)
- 적절한 인덱스 설계, SELECT 대상 최소화

### ○ 정적 리소스 최적화
- Cache-Control, CDN 활용하여 이미지, JS, CSS 등을 캐싱
- 네트워크 요청 최소화

### ○ 비동기 처리
- 블로킹 작업(IO 등)을 비동기로 분리하여 사용자 응답 속도 개선

### ○ 로드 밸런싱
- 트래픽을 여러 서버로 분산하여 과부하 방지 및 고가용성 확보

---

## 🔗 참고 자료
- [참고 : F-Lab 성능 최적화 전략](https://f-lab.kr/insight/backend-performance-optimization-strategies)  
- [참고 : Velog 성능 최적화 전략](https://velog.io/@dotofi/백엔드-성능-최적화-전략)
